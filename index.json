[{"categories":["学习笔记"],"content":"这篇文章展示了软件工程的学习记录","date":"2023-09-04","objectID":"/posts/se/l/","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"这篇文章展示了软件工程的学习记录 Software Engineering ","date":"2023-09-04","objectID":"/posts/se/l/:0:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"1 Introduction to Software Engineering ","date":"2023-09-04","objectID":"/posts/se/l/:1:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"1.1 Software Attributes Acceptability MUST be acceptable to the type of users for which it is designed Understandable, usable, and compatible with other systems Dependability Include reliability, security, and safety Should NOT cause physical or economic damage in event of system failure MUST be secure Efficiency Software should NOT make wasteful use of system resources such as memory and processor cycles include responsiveness, processing time, memory/resource utilization, etc. Maintainability Software should be written in such a way so that it can evolve to meet changing requirements Critical attribute since software change is an inevitable requirement of a changing business environment ","date":"2023-09-04","objectID":"/posts/se/l/:1:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2 Software Process A structured set of activities required to develop a software system. There are many different software processes, but they all involve: Specification – defining what the system should do; Development – producing the software that meets the specification; Validation – checking that it does what it should do; Evolution – changing the system in response to changing needs. Description Process descriptions may also include: Products, or deliverables, which are the outcomes of a process activity; Roles, which reflect the responsibilities of the people involved in the process; Pre- and post-conditions, which are statements that are true before and after a process activity has been enacted or a product produced. ","date":"2023-09-04","objectID":"/posts/se/l/:2:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.1 Plan-Driven and Agile Processes Plan-driven processes are processes where all of the process activities are planned in advance and progress is measured against this plan. In agile processes, planning is incremental, and changing the process to reflect changing customer requirements is easier. In practice, most practical processes include elements of both plan-driven and agile approaches. There are no right or wrong software processes. ","date":"2023-09-04","objectID":"/posts/se/l/:2:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.2 Software Process Models 2.2.1 Waterfall Model There are separate identified phases in the waterfall model, and in principle, a phase must be completed before moving on to the next phase Requirements analysis and definition System and software design Implementation and unit testing Integration and system testing Operation and maintenance 2.2.2 Waterfall Model Problems Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements. Therefore, this model is only appropriate when the requirements are well-understood and changes will be fairly limited during the design process. Types of systems for which the waterfall model is appropriate Embedded systems where the software has to interface with hardware systems Critical systems where there is a need for extensive safety and security analysis of the software specification and design Large software systems that are part of broader engineering systems developed by several partner companies ","date":"2023-09-04","objectID":"/posts/se/l/:2:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.2.3 Incremental Development Incremental development is based on the idea of developing an initial implementation, getting feedback from users and others, and evolving the software through several versions until the required system has been developed This approach can be either plan-driven, agile or, more usually, a mixture of these approaches. You don’t have to deliver each increment to the system customer. 2.2.4 Incremental Development Benefits and Problems Benefits It is easier to get customer feedback on the development work that has been done. The cost of accommodating changing customer requirements is reduced. More rapid delivery and deployment of useful software to the customer is possible. Problems There may be a mismatch between the organizations’ bureaucratic procedures and a more informal iterative or agile process System structure tends to degrade as new increments are added. 2.2.5 Integration and Configuration Based on software reuse where systems are integrated from existing components or application systems, or COTS (Commercial-off-the-shelf) systems. Reused elements may be configured to adapt their behaviour and functionality to a user’s requirements Reuse is now the standard approach for building many types of business systems Types of reusable software Stand-alone application systems that are configured for use in a particular environment. Collections of objects that are developed as a component or a package to be integrated with frameworks like .NET or J2EE. Web services that are developed according to service standards and that are available for remote invocation. 2.2.6 Reuse-oriented Software Engineering Advantages and disadvantages Reduced costs and risks as less software is developed from scratch Faster delivery and deployment of systems Requirements compromises are inevitable so the system may not meet the real needs of users Loss of control over the system evolution ","date":"2023-09-04","objectID":"/posts/se/l/:2:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.3 Process Activities Real software processes are inter-leaved sequences of technical, collaborative and managerial activities with the overall goal of specifying, designing, implementing and testing a software system. The four basic process activities of specification, development, validation and evolution are organized differently in different development processes. For example, in the waterfall model, they are organized in sequence, whereas in incremental development they are interleaved. 2.3.1 Software Specification The process of establishing what services are required and identifying the constraints on the system’s operation and development. Requirements engineering process Requirements elicitation and analysis What do the system stakeholders require or expect from the system? Requirements specification Defining the requirements in detail Requirements validation Checking the validity of the requirements 2.3.2 Software Development The process of developing an executable system for delivery to the customer. Design and implementation are interleaved activities for most types of software systems. Software design Design a software structure to realize the requirements Architectural design, database design, interface design, component selection and design, … Implementation Translate this structure into an executable program Programming is an individual activity with no standard process 2.3.3 Software Validation - needs Verification and validation (V \u0026 V) is intended to show that a system conforms to its specification and meets the requirements of the system customer. Verification Check implementation again the perceived req.(user and system from developer point of view) as internal checking of a developer group; Validation Check real user requirements. Validation: Are we building the right product? Verification: Are we building the product right? It involves checking processes (such as inspections and reviews) and system testing (static vs. dynamic) Testing is the most commonly used V \u0026 V activity. Component testing (Verification): Testing of individual components; System testing (Verification): Testing of the system as a whole; Customer testing (Validation): Testing with customer data; Defect testing and debugging are different processes. Testing establishes the existence of defects. Debugging is concerned with locating and correcting these defects. 2.3.4 Software Evolution Software is inherently flexible and can change. As requirements change, the software that supports the business must also evolve and change. Although there has been a demarcation between development and evolution (maintenance), the distinction is increasingly irrelevant as fewer and fewer systems are completely new. It is more realistic to think of software engineering as an evolutionary process where software is continually changed in response to changing requirements and customer needs. ","date":"2023-09-04","objectID":"/posts/se/l/:2:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.4 Coping with Change Change is inevitable in all large software projects. A software product is a model of the real world, which is continually changing Software professionals are human, and they make mistakes. The moving target problem: The requirements change while the software product is being developed Any change made to a software product can potentially cause a regression fault If there are too many changes, the entire product may have to be redesigned and reimplemented There is no solution to the moving target problem Change leads to rework so the costs of change include both rework (e.g., re-analyzing requirements) as well as the costs of implementing new functionality 2.4.1 Reducing The Costs of Rework Two related approaches Change anticipation, where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show customers some key features of the system. Change tolerance, where the process is designed so that changes can be accommodated at a relatively low cost. This normally involves some form of incremental development. The longer a change is delayed, the more it costs to implement. 2.4.2 Two Ways of Coping with Changing Requirements System prototyping A version or part of the system is developed quickly to check the customer’s requirements and the feasibility of design decisions. This is a method of change anticipation as it allows users to experiment with the system before delivery and refine their requirements. Incremental delivery System increments are delivered to the customer for comment and experimentation. This supports both change anticipation and change tolerance. 2.4.3 Software Prototyping A prototype is an initial version of a system used to demonstrate concepts, try out design options, and find out more about the problem and its possible solutions. A prototype can be used in the requirements engineering process to help with requirements elicitation and validation; in the design process to explore options and develop a UI design; Benefits Improved system usability. A closer match to users’ real needs. Improved design quality. Improved maintainability. Reduced development effort. 2.4.4 Prototyping Development May be based on rapid prototyping languages or tools May involve leaving out functionality Prototype should focus on areas of the product that are not well- understood Error checking and recovery may not be included in the prototype Focus on functional rather than non-functional requirements such as reliability and security 2.4.5 Incremental Delivery The development and delivery is broken down into increments with each increment delivering part of the required functionality User requirements are prioritized and the highest priority requirements are included in early increments. Once the development of an increment is started, the requirements are frozen though requirements for later increments can continue to evolve. Advantages: elicit requirements for later increments. Customer value can be delivered with each increment, so system functionality is available earlier relatively easy to incorporate changes into the system The highest priority system services tend to receive the most testing Problems: difficult to implement for replacement systems as increments have less functionality than the system being replaced. common facilities can be difficult to identify with incremental delivery but most systems require a set of basic facilities Its essence is that the spec is developed in conjunction with the software, which conflicts with the procurement model of many organizations ","date":"2023-09-04","objectID":"/posts/se/l/:2:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"2.5 PROCESS IMPROVEMENT 2.5.1 Software Process Performance and Capability Software Process Performance Represents the actual results achieved by following a software process. E.g., our actual defect rate is 2 defect/KLOC Software process performance focuses on the achieved results Software Process Capability Describes the expected results that can be achieved by following a software process. E.g., the final defect rate will likely be 1.5 defect/KLOC Software process capability focuses on the expected results 2.5.2 Software Process Maturity Process Maturity It is the extent to which an organization’s processes are explicitly, defined, managed, measured, controlled, and effective. Maturity implies a potential for growth in capability Immature software organization Processes being improvised by practitioners Managers being forced to solve immediate crises (fire fighting) No objective basis for judging quality Mature software organization Processes are documented, usable, and consistent with the way the work is actually done 2.5.3 Quality Assurance (QA) the identification, planning, adoption, and implementation of the disciplines and actions (the process) necessary to assure that the product satisfies its users. focus on improving the process Use error and trend analysis to locate weaknesses in: Development process Test process Maintenance process Support process (Quality, Configuration management) 2.5.4 Capability Maturity Model Integration (CMMI) CMMI is a framework to improve product quality and development efficiency for systems (both hardware and software) CMMI supports 2 representations: staged and continuous. To initiate the process improvement, an organization must first select a representation. 2.5.4.1 Staged Representation of CMMI Staged models provide a proven sequence of improvements, beginning with basic management practices and progressing through successive levels. 2.5.4.2 Continuous Representation of CMMI Continuous representation designates capability levels: numbered 0 through 3: incomplete, performed, managed, and defined ","date":"2023-09-04","objectID":"/posts/se/l/:2:6","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"3 Agile Software Development ","date":"2023-09-04","objectID":"/posts/se/l/:3:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"3.1 Agile Methods (or Agile Development) Dissatisfaction with the overheads involved in plan-driven software design methods The plan-driven approach was mainly used for developing large, long-lived software systems. Aim: reduce overheads in the software process, such as limiting documentation; respond quickly to changing requirements without excessive rework. All agile methods suggest that software should be developed and delivered incrementally. 3.1.2 Plan-Driven and Agile Development Plan-driven development Based around separate development stages with the outputs to be produced at each stage. Iteration occurs within activities. Agile development Specification, design, implementation, and testing are inter-leaved and the outputs from the development process are negotiated during the software development process. Iteration occurs across activities. 3.1.3 Agile Methods Applicability Agile methods have been particularly successful for two kinds of system development. Product development where a software company is developing a small or medium-sized product for sale. Most software products and apps are now developed using an agile approach Custom system development within an organization, where there is a clear commitment from the customer to become involved in the development process and where there are few external rules and regulations that affect the software. 3.1.4 Principles of Agile Manifesto Customer involvement Customers should be closely involved throughout the development process Incremental delivery The software is developed in increments with the customer specifying the requirements to be included in each increment. People not process The skills of the development team should be recognized and exploited. Embrace change Expect the system requirements to change and so design the system to accommodate these changes. Maintain simplicity Focus on simplicity in both the software being developed and in the development process. Wherever possible, actively work to eliminate complexity from the system. ","date":"2023-09-04","objectID":"/posts/se/l/:3:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"3.2 AGILE DEVELOPMENT TECHNIQUES Agile methods are incremental development methods that focus on rapid software development, frequent releases of the software, reducing process overheads by minimizing documentation and producing high-quality code. 3.2.1 Extreme Programming (XP) A very influential agile method Pushing recognized good practice to “extreme” levels New versions may be built several times per day; Increments are delivered to customers every 2 weeks All tests must be run for every build and the build is only accepted if tests run successfully. The extreme programming release cycle 3.2.2 XP Principles and Practices 3.2.3 Support for Agile Principles in XP Practices Incremental delivery is supported through small releases. Customer involvement is supported through on-site customers. People, not process, are supported through pair programming, collective ownership, and sustainable pace. Change is embraced through small releases, test-first development, refactoring, and continuous integration. Maintaining simplicity is supported by refactoring and simple design. 3.2.4 Influential XP Practices Key practices User stories for specification Refactoring Test-first development Pair programming 3.2.4.1 User Stories for Requirements A user story is a description of a system requirement from a user perspective, is a scenario of use that a system user might experience User making decisions on requirements. written on cards, and the customer chooses the stories for inclusion in the next release based on their priorities and the schedule estimates. development team breaks the selected user stories into implementation tasks. easier to relate to these stories than a conventional requirements document or use cases. Drawbacks difficult to judge if enough user stories have been developed to cover all the essential requirements if a single story gives a true picture of an activity. user stories $\\to$ tasks 3.2.4.2 Refactoring Look for possible software improvements and make them even when there is no immediate need. Local changes tend to degrade software structure and readability This improves the understandability of the software and reduces the need for documentation. Changes are easier to make because the code is well-structured and clear. However, refactoring sometimes gets delayed, and some changes require expensive architecture refactoring. 3.2.4.3 Test in XP/ Test-Driven Development With XP, no system specification can be used by an external testing team to develop system tests User stories are user requirements but not system requirements as they often miss important information about the system XP has developed an approach to test the program after every change. XP testing features: Incremental test development from scenarios. Test-first development - Tests are written as programs after code User involvement in test development and validation. Use of automated testing frameworks Test-Driven Development(TDD): Tests are written as programs before code, only need a rough idea of the functionality of the program Each test includes a check of whether its execution is correct. write a falling test $\\to$ make the test pass $\\to$ refactor the code $\\to$ next falling test $\\to$ … Customer involvement: The customer helps develop acceptance tests for the stories to be implemented in the next release of the system. limitations: People adopting the customer role have limited time and cannot work full-time with the development team. They may feel that providing the requirements was enough of a contribution and may be reluctant to get involved in the testing process. Test Automation: tests are written as executable components (before the task is implemented) These testing components should be stand-alone, simulate the submission of input to be tested, and check that the result meets the output specification. An automated test framework (e.g., JUnit) is a system that makes it easy to write executable tests and submit a set of tests for executio","date":"2023-09-04","objectID":"/posts/se/l/:3:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"3.3 Agile Project Management Plan-driven software development requires a manager to have a stable view of everything that has to be developed and the development processes. Agile methods Self-organizing teams Little or no documentation Short-term development plans adapted to incremental development 3.3.1 Scrum Scrum is an agile method that focuses on managing iterative development rather than specific agile practices. Three phases: Initial phase is an outline planning phase A series of sprint cycles, where each cycle develops an increment of the system. The project closure phase wraps up the project, completes required documentation, and assesses the lessons learned. Benefits The product is broken down into a set of manageable and understandable chunks that stakeholders can relate to. Unstable requirements do not hold up progress. The whole team has visibility of everything, and consequently, team communication is improved. Customers see on-time delivery of increments and gain feedback on how the product works. Trust between customers and developers is established ","date":"2023-09-04","objectID":"/posts/se/l/:3:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4 Requirements Engineering ","date":"2023-09-04","objectID":"/posts/se/l/:4:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.1 Requirements and Requirements Engineering requirements descriptions of the services that a system should provide and constraints on its operation. Requirements Engineering The process of finding out, analyzing, documenting, and checking these services and constraints Two types of requirements User requirements: Statements in natural language plus diagrams System requirements: A detailed, structured document Example 4.1.1 Agile Methods and Requirements Requirements in agile processes Use incremental requirements engineering and often express requirements as “user stories” may a waste of time Practical for business systems but problematic for many others For a “traditional” view of requirements. For most large systems, there is a clearly identifiable requirements engineering phase before system implementation begins ","date":"2023-09-04","objectID":"/posts/se/l/:4:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.2 FUNCTIONAL AND NON-FUNCTIONAL REQUIREMENTS The line between them is not always clear since requirements are not independent; The system requirements should include both types of requirements; Non-functional requirements may generates functional requirements; 4.2.1 Functional Requirements and Non-Functional Requirements 4.2.1.1 Functional Requirements statements of services the system should provide, also may state what the system should not do. May be in different forms and at different levels of detail may be high-level statements of what the system should do. should describe the system services in detail. should be complete and consistent. Functional User Requirements The high-level (overview) of the what the system should do; Functional System Requirements Detailed description of the services provided by the system; Example 4.2.1.2 Non-Functional Requirements System properties and constrains properties: reliability, response time, and storage requirements; constrains: I/O device capability and the data representations; May be more critical than functional requirements more difficult to identify which system components implement specific non-functional requirements may affect the overall architecture of a system rather than the individual components.(e.g. a 4 parts system, if only one part is safe, the whole system is not safe) may generate other related functional and/or non-functional requirements 4.2.1.3 Verifying Non-Functional Requirements Non-functional requirements may be difficult to state precisely, and imprecise requirements may be difficult to verify. Two parts: Goals: A general intention of the user, like Ease of Use; Verifiable (Testable): Some measure (satisfaction) that can be objectively tested. Metrics for Specifying Non-Functional Requirements Property(Goals) Measure(Verifiable) Speed Processed transactions/second; User/event response time; Screen refresh time Size Mbytes; Number of ROM chips Ease of use Training time; Number of help frames Reliability Mean time to failure; Probability of unavailability; Rate of failure occurrence; Availability Robustness Time to restart after failure; Percentage of events causing failure; Probability of data corruption on failure Portability Percentage of target dependent statements; Number of target systems [Example] Goals The system should be easy to use by medical staff and should be organized in such a way that user errors are minimized. Verifiable Medical staff shall be able to use all the system functions after four hours of training (easy to use). After this training, the average number of errors made by experienced users shall not exceed two per hour (minimized) of system use. 4.2.1.4 Challenges in Specifying Non-Functional Requirements Difficult for customer to translate their goals into measurable requirements. No simple metrics for some goals (e.g., maintainability) Unclear connection between metrics and everyday experience High costs for verification conflict and interact with other functional and/or non-functional requirements difficult to separate functional and non-functional requirements in the requirements document. ","date":"2023-09-04","objectID":"/posts/se/l/:4:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.3 REQUIREMENTS ENGINEERING PROCESSES Generic activities common to all processes Requirements elicitation; Requirements specification; Requirements validation; In practice, RE is an iterative activity in which these processes are interleaved. ","date":"2023-09-04","objectID":"/posts/se/l/:4:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.4 REQUIREMENTS ELICITATION 4.4.1 Requirements Elicitation working with stakeholders to find out about the application domain, work activities, services, system features that stakeholders want, etc. Stages: discovery and understanding: Interacting with stakeholders to discover their requirements classification and organization: Groups related requirements and organises them into coherent clusters. Prioritisation and negotiation: Prioritising requirements and resolving requirements conflicts. Documentation: The requirements are documented and input into the next round of the spiral. Techniques - 1 Interviewing Closed interviews vs. Open interviews Normally a mixture of closed and open interviewing. Problems Application specialists may use language that isn’t easy for the requirements engineer to understand to describe their work. Interviews are not good for understanding domain requirements Effective interviewing Be open-minded, avoid pre-conceived ideas about the requirements, and be willing to listen to stakeholders. Prompt the interviewee to talk about the system by suggesting requirements rather than simply asking them what they want. Techniques - 2 Observation or ethnography Benefits: People do not have to explain or articulate their work. It is relatively inexpensive. The observer will get a practical insight into the work. Social and organizational factors of importance may be observed. Improvement areas can be easily identified. Drawbacks: Participants might get disturbed. Participants might change their way of working during observation and the observer might not get a clear picture. Knowledge-based activities (e.g., debugging) are hard to observe. Problems of Requirements Elicitation Stakeholders don’t know what they really want. They express requirements in their own terms and with implicit knowledge of their work. Different stakeholders, with diverse requirements, may express their requirements in different ways. Organisational and political factors may influence the system requirements. The requirements change during the analysis process. New stakeholders may emerge, and the business environment may change. ","date":"2023-09-04","objectID":"/posts/se/l/:4:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.5 REQUIREMENTS SPECIFICATION The process of writing down the user and system requirements in a requirements document. 4.5.1 Requirements Specification The process of writing down the user and system requirements in a requirements document. User requirements: understandable by end-users and customers who do not have a technical background. System requirements: more detailed requirements and may include more technical information. Common notations for writing system requirements Natural language sentences Structured natural language Graphical notations Mathematical specifications requirements: what the system should do design: how it does this. They are inseparable; 4.5.2 Natural Language Specifications Guidelines on writing natural language requirements standard format and use it for all requirements. Use “shall” for mandatory requirements; Use “should” for desirable requirements. Use text highlighting to identify key parts of the requirement. Avoid the use of computer jargon. Include an explanation (rationale) of why a requirement is necessary. Example 4.5.3 Structured Natural Language Specifications An approach to writing requirements in a standard way rather than as free-form text. Maintains most expressiveness and understandability of NL Removes some of the problems of NL specification It is still sometimes difficult to write requirements in a clear and unambiguous way Example 4.5.4 Use Cases Describe interactions between users and a system using a graphical model and structured text. Identify the actors involved in an interaction and name the type of the interaction. Additional information can be added to describe the interaction Use case diagram Each use case (a named ellipse) represents a class of interaction. An actor (a stick figure) is a person or a system. Lines link actors with the interaction. Documented with a textual description [Example] - UML 4.5.5 Requirements and Design requirements should state what the system should do design should describe how it does this. requirements and design are inseparable 4.5.6 The Software Requirements Specification (SRS) The official statement of what the system developers should implement It is NOT a design document. As far as possible, it should set out WHAT the system should do rather than HOW it should do it. The information in the SRS depends on the type of system and the development process used. Should include both user and system requirements. Requirements specification standards have been designed (e.g., IEEE standard). 4.5.7 The Structure of A Requirements Specification ","date":"2023-09-04","objectID":"/posts/se/l/:4:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.6 REQUIREMENTS VALIDATION 4.6.1 Requirements Validation The process of checking that requirements define the system that the customer really wants Overlaps with elicitation and analysis Types of checks Validity checks. Do the requirements reflect the real needs of system users? Consistency checks. Are there any requirements conflicts? Completeness checks. Are all functions required by the customer included? Realism checks. Can the requirements be implemented, given the available budget and technology? Verifiability checks. Can the requirements be verified? 4.6.2 Requirements Validation Techniques Various techniques that can be used individually or together ==Requirements reviews==: Systematically and manually analyze the requirements to check for errors and inconsistencies Should be held regularly Should involve both client and contractor staff May be formal (with completed documents) or informal. ==Prototyping==: Using an executable model of the system to check requirements. ==Test-case generation==: Developing tests for requirements to check verifiability. ","date":"2023-09-04","objectID":"/posts/se/l/:4:6","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"4.7 REQUIREMENTS CHANGE 4.7.1 Changing Requirements Once a system is installed and regularly used, new requirements inevitably emerge. original requirements may have errors and omissions. business and technical environment of the system always changes after installation. stakeholders as well as their priorities and requirements may change 4.7.2 Requirements Traceability Matrix It helps to link requirements to business and project objectives, track requirements throughout the software life cycle, and manage changes. ","date":"2023-09-04","objectID":"/posts/se/l/:4:7","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5 System Modeling The process of developing abstract models of a system model an abstraction of the system being studied not an alternative representation of that system. each model presents a different view/perspective of the system External, structural, behavioral, interaction, etc. Models can be from different perspectives in different forms graphical formal/mathematical natural language for systems at different stages existing to be developed Abstraction \u0026 Representation Abstraction Focus on the essential aspects of the system, without the irrelevant details, leave out the details; Model is an abstraction of the system; Not an alternative representation; For a English book: the representation is the Chinese version; the slide is the abstraction of the book; Representation Each model represents a system from a particular perspective; External perspective: context or environment of the system; Interaction perspective: Interactions between systems and external agent between system components; Structural perspective: components, organizations, data structures; Behavioral perspective: dynamic behavior, responds; example: UML (Unified Modeling Language) diagrams ","date":"2023-09-04","objectID":"/posts/se/l/:5:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.1 Usage of Graphical System Models stimulate and focus discussion about a system incomplete and informal (normal in agile modeling) document an existing system correct but incomplete generate a system implementation correct and complete ","date":"2023-09-04","objectID":"/posts/se/l/:5:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.2 UML (Unified Modeling Language) UML is a standard language for specifying, visualizing, constructing, and documenting (software) systems. A general purpose modeling language for (OO software) systems Diagram Types A UML model consists of diagrams and documentation that complements\\ the diagrams ","date":"2023-09-04","objectID":"/posts/se/l/:5:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.3 Context Models illustrate a system’s operational context shows other systems used by or depend on the system being developed not how the system interact with each other System boundary what is inside and outside social and organizational concerns may affect the system boundary add arrow to indicate the direction of the work flow 5.3.1 Process Perspective A type of the context; Context models simply show the other systems in the environment, but NOT the types of relationships between, no details; ","date":"2023-09-04","objectID":"/posts/se/l/:5:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.4 Interaction Models All systems involve interactions of some kind user interaction helps to identify user requirements component interaction helps to understand the performance and dependability of the system system-to-system interaction highlights the communication problems may arise Two related approaches Use case diagrams model interactions between systems and external agents (human users or other systems); Sequence diagrams model interactions between system components (and external agents) 5.4.1 Use Case Modelling Use Case diagram ellipse: use case stick figure: actor, person, system 5.4.2 Sequence Diagrams Interactions between the actors and the objects within a system and those between the objects themselves. Shows the sequence of interactions that take place during a particular use case or use case instance. Sequence diagram: Loop: Condition: Sequence Diagram ","date":"2023-09-04","objectID":"/posts/se/l/:5:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.5 Structural Models Organization of a system in terms of the components Class, Objects The organization of a system in terms of the components Used when discussing and designing the system architecture Static models: Class; used at both the analysis and the implementation phase of software development Dynamic models: Object; 5.5.1 Classes encapsulates state (attributes) and behavior(operations) each attribute has a type, each operation has a signature 5.5.2 Relationships Dependency Instance-level (objects are also called instances) Association Aggregation Composition Class-level Generalization Realization/Implementation Dependency semantic connection between dependent and independent classes (modules). If changes to the definition of one class (module) (the server or target) may cause changes to the other (the client or source). 5.5.2.1 Instance-level Relationship Associations a type of relation between class instances using association to communicate classes Class A has an attribute of type B Class A creates instances of B Class A received a message with argument of type B Association Multiplicity Multiplicity denotes how many objects of the class take part in the relation [1-to-1] [1-to-many] [many-to-many] Special Associations (Has-A Relation) - Aggregation \u0026 Composition Aggregation: “part-of” relation between objects Component can be part of multiple aggregates Component can be created and destroyed independently of the aggregate Composition: strong aggregation Component can be part of only one aggregate Exists only together with the aggregate Navigability of Association whether objects can be accessed through this association(directed) 5.5.2.2 Class-level Relationship Generalization relation Is-A relationship inheritance Generalization simplifies the model by eliminating redundancy ","date":"2023-09-04","objectID":"/posts/se/l/:5:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"5.6 Behavioral Models a system responds to a stimulus from its environment. a system’s dynamic behavior as it executes. system responds to a stimulus from its environment Data Event 5.6.1 Data-Driven Modeling show the sequence of actions involved in processing input data and generating an associated output. business system(data-processing system) is driven by data [Activity diagrams example] [Sequence diagrams example] 5.6.2 Event-Driven Modeling shows how a system responds to external and internal events. a finite number of states events (stimuli) may cause transitions between states. UML state diagrams show system states and events that cause transitions from one state to another. states are nodes; events are arcs between nodes 5.6.3 States and Stimuli for The Microwave Oven 5.6.4 Superstates looks like a single state in a high-level model expanded to show more detail in a separate diagram ","date":"2023-09-04","objectID":"/posts/se/l/:5:6","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"6 Architectural Design how a software system should be organized and designing the overall structure output is an architectural model, describing how the system is organized as a set of communications components critical link between design and requirements engineering should be designed at the early stage of an agile development process Architectural Abstraction Architecture in the small is concerned with the architecture of individual programs. Architecture in the large is concerned with the architecture of complex enterprise systems that include other systems, programs, and program components. Advantages of Explicit Architecture Stakeholder communication: high-level presentation; Be understandable by non-technical people; Discussed by a range of different stakeholders; System analysis: Whether or not the system can meet critical requirements; Large-scale reuse: be reusable across a range of systems product-line architectures Representations using simple block diagrams Box: component Boxes in boxes: component decomposition Arrows: data and control flow no types of relationship or components externally visible properties ","date":"2023-09-04","objectID":"/posts/se/l/:6:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"6.1 Architectural Design Decisions The solution to the architecture choose; Reuse: template of generic application architecture How distribute across hardware core/processors? (optional); What patterns should be used? how to structure? how components be decomposed? how to control components? Best for delivering the non-functional? How should the architecture of the system be documented? Architecture on Non-Functional Requirements Performance: Localize critical operations, minimize communications: In local, not remote; Using large, NOT small components/fine-grain; Security: layered architecture with critical assets in the inner layers Safety: Will not cause harm to the user and others; Localize safety-critical features in a small number of sub-systems; Perform several checking for each small sub-system rather than one big system; Availability: Include redundant components and mechanisms for fault tolerance. e.g. Multiple servers for a web application; one down, other can still provide service; Maintainability: Use fine-grain, self-contained components that may easily be changed. Easy to replace problem components; Easy to extend; ","date":"2023-09-04","objectID":"/posts/se/l/:6:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"6.2 Architectural Views Different view on a architecture design Each architectural model only shows one views Informal models and notations UML: remain the most way of documenting architectures ","date":"2023-09-04","objectID":"/posts/se/l/:6:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"6.3 Architectural Patterns stylized description of good design practice include information when they are/not to use mixture of narrative description and diagrams Architectural patterns: The Model-View-Controller (MVC) pattern The Client-Server pattern The Pipe and Filter pattern The Layered pattern The Repository pattern 6.3.1 The Model-View-Controller (MVC) Pattern Model manages system data and associated operations on that data View defines and manages how the data is presented to the user Controller manages interaction(key presses, mouse clicks, etc.) passes these interactions to View and Model 6.3.2 Layered Architectures Organized into separate layers, and each layer ONLY relies on the facilities and services offered by the layer immediately beneath it. Benefit: Supports the incremental development; Layer interface changes, ONLY the adjacent layer is affected; Allows replacement of entire layers; Disadvantage: Clean separation between layers is often difficult High-level layer may have to interact directly with lower-level layers rather than through the layer immediately below it. e.g., from 1 to 3 directly, not access 2; 2 provide a special gate; the performance will be low; 6.3.3 Repository Architectures Exchange of data among subsystems: Centralized storage Shared data is held in a central database. High efficiency; Distributed storage Sub-system maintains its own database(copy of) and passes data explicitly to other sub-systems. Low efficiency; Benefit: Components can be independent; Disadvantage: Repository is a single point of failure Distributing may be difficult; Repository model: A repository is passive, the components to control with the data in repository; Blackboard model: A blackboard notifies(actively) components when particular data become available; Updates in the blackboard will notifies other components; 6.3.4 Client-Server Architectures Distributed system model. Stand-alone servers: provide specific services such as printing, data management, etc. Clients: call on these services they want to; Can be implemented on single computer Advantages: Servers can be distributed across a network; Servers can also be client to access other servers; Disadvantage: Performance may be unpredictable because it depends on the network; 6.3.5 Pipe and Filter Architectures The runtime organization of a system where functional transformations process inputs and produce outputs pipes: link processes using “pipes” filter: transformation “filters out” the data it can process from its input data stream. Advantage: easy to understand and supports transformation reuse matches structure of many business processes Disadvantage: format for data transfer has to be agreed Each transformation must parse its input and unparse its output to the agreed form; ","date":"2023-09-04","objectID":"/posts/se/l/:6:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"6.4 Application Architectures An architecture that encapsulates the principal characteristics of a class of systems; Be configured and adapted to create a system that meets specific requirements. Usage As a starting point for architectural design. As a design checklist. As a way of organizing the work of the development team. As a means of assessing components for reuse. As a vocabulary for talking about application types 6.4.1 Applications Types Examples Transaction processing systems: Database-centred applications; User requests for information and update; Like E-commerce systems and information systems a customer request to withdraw money from a bank account using an ATM May be organized as a “pipe and filter” architecture Information Systems can be organized as a layered architecture Language processing systems: ","date":"2023-09-04","objectID":"/posts/se/l/:6:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7 Brief Introduction to OOP in Java Variables Primitive data types: boolean, char, byte, short, int, long, float, double Reference data type: Sting, Date, etc. Expressions and expression statements Assignment operators: =, +=, -=, *=, /=, … Arithmetic operators: +, -, *, /, % Unary operators: +, -, ++, –, ! Equality and relational operators: ==, !=, \u003e, \u003e=, \u003c, \u003c= Conditional operators: \u0026\u0026, ||, ?: Type comparison operators: instanceof Bitwise and bit shift operators: ~, «, », »\u003e, \u0026, ^, | Control Structures Selection: if, switch Loop: for, while, do-while, break, continue Exception handling: try, catch, finally ","date":"2023-09-04","objectID":"/posts/se/l/:7:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.1 Class and Object Filed (instance variable/state): the values can be stored; Method: the operations can be performed; // Hero.java class Hero{ String name; // field int health; // field void initHero(){…} // method void increaseHealth(int amount){…} // method } Both fields and methods are instance members Object contains all the fields in the class, and takes space; Methods do NOT take any space in objects; Multiple references can point to the same object (aliasing); Reference: only contain NULL or the address of the object; Hero heroA,heroB,heroC // only the Hero reference, NO Hero object Call method: Sending a message to an object Constructors: special kind of methods that are invoked to initialize objects MUST have the same name as the class itself MUST: No return type, not even void; May have parameters, NOT this; // a regular method called Hero void Hero(){...} // NOT a constructor // constructors Hero(){...} // default constructor Hero(String name){...} // constructor with parameter Method overload: Method signature = Method name + List of parameter types; Using signature to distinguish different methods, even with the same name; ","date":"2023-09-04","objectID":"/posts/se/l/:7:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.2 Encapsulation Information Hiding Principle of Least Privilege Every module must be able to access only the information and resources that are necessary for its legitimate purpose. Access control: public(all) \u003e protected(package+subclass) \u003e default(package) \u003e private(same class only) ","date":"2023-09-04","objectID":"/posts/se/l/:7:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.3 Inheritance IS-A relationship, reuse. To be part of: Instance variables of the superclass are PART of the objects of the subclass (Whatever public, private, protected, default); To inherit: Public variables of the superclass are inherited into the subclass, which means the subclass can access them directly by using the variable name in the superclass; ","date":"2023-09-04","objectID":"/posts/se/l/:7:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.4 Polymorphism poly: many; morph: shape, form extends public class Hero{ private String name; private int health; public Hero(){…} public void travel(){…} } // keyword: extends public class Monster extends Hero{ private boolean isAngry; public Monster(){…} public void travel(){…} } Hero h; h = new Hero(); h.travel(); // calling travel() defined in Hero h = new Monster(); h.travel(); // calling travel() defined in Monster Generic Programming: need to know the precise type of an object. ","date":"2023-09-04","objectID":"/posts/se/l/:7:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.5 Abstract Class and Methods A abstract method with NO any implementation within the current class A class with at least one abstract method must be abstract can be inherited meant to be overridden The compiler does not allow to create any instance of an abstract class, as the class is not complete yet ","date":"2023-09-04","objectID":"/posts/se/l/:7:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"7.6 Interface Groups of abstract methods provides a way to define common behavior(s) that multiple classes can adhere to, WITHOUT specifying the actual implementation details. NO instance field All instance methods MUST be public and abstract. Keywords public and abstract can be omitted; // Parent interface interface Animal { void eat(); void sleep(); } // Child interface extending the Animal interface interface Pet extends Animal { void play(); } // Implementing the interfaces in classes class Dog implements Pet { public void eat() { // Implementation for eating behavior } public void sleep() { // Implementation for sleeping behavior } public void play() { // Implementation for playing behavior } } ","date":"2023-09-04","objectID":"/posts/se/l/:7:6","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"8 Object-Oriented Analysis and Design ","date":"2023-09-04","objectID":"/posts/se/l/:8:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"8.1 Object-Oriented Analysis (OOA) Goal: understand the problem and to begin to develop a model of what you are trying to build (problem domain) Independent of implementation and technology concerns. Translating the functional requirements into software concepts. get a rough cut at the object Two types: Function-oriented analysis – concentrating on the decomposition of complex functions to simple ones. Object-oriented analysis – identifying objects and the relationship between objects. 8.1.1 Domain Model representation of conceptual classes in a domain of interest Using UML notation, a set of class diagrams It may show: conceptual classes associations between the conceptual classes attributes of the conceptual classes NOT in domain model Software artifacts, like window or a database Responsibilities, or methods. 1. Conceptual classes Real-world concept or thing, NOT an implementation class It is better to over-specify a domain model with many fine- grained conceptual classes than to under-specify it. Identify conceptual classes Conceptual class category Noun phrase identification find noun phrases in the specification Discard some class: Outside the current requirements, Price Rule Redundant, System Looks like an attribute more than a class, Price NOT being considered in this iteration, Receipt NO correct set of conceptual classes Draw them in a domain model, i.e., a set of UML class diagram Add associations and attributes 2. Associations between conceptual classes relationship between types (or instances of those types) Not a statement about data flows, instance variables, or object connections in a software solution How to find relationship: It is more important to identify conceptual classes than to identify associations. Too many associations confuse a domain model Avoid showing redundant or derivable associations. 3. Attributes logical data value of an object Mistake 1：may treat a class as an attribute; Treat a destination(Airport) as a class than as a attribute of a flight Mistake 2: Add a kind of foreign key attribute, as is typically done in relational database designs, ","date":"2023-09-04","objectID":"/posts/se/l/:8:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"8.2 Object-Oriented Design (OOD) Goal: A process that uses the analysis results to produce a specification for implementing a system. Emphases on defining software objects and how they collaborate to fulfill the requirements. look at class design in detail design activities like database design and interface design Result: the specification of a logical software solution in terms of software objects, such as classes, attributes, methods, and collaborations. Two kinds of design models: dynamic and static. Static definition of packages, class names, attributes, and method signatures (but not method bodies). UML class diagram Fundamental activity: Assigning responsibilities to classes/objects! Dynamic the logic and the behavior of the code or the method bodies. UML interaction diagram(e.g., sequence diagrams) 8.2.1 Doing and Knowing Responsibilities Doing responsibilities Methods: creating an object or doing a calculation Initiating actions in other objects Controlling and coordinating activities in other objects Knowing responsibilities knowing about private encapsulated data related objects Things it can derive or calculate 8.2.2 Responsibility-Driven Design (RDD) A general metaphor for thinking about OOD Software objects are like people with responsibilities who collaborate to get work done Responsibilities are implemented by means of methods Either act alone or collaborate with other methods and objects How to do RDD Using Class-Responsibility-Collaborator (CRC) Cards One card per class, shows its responsibilities and with which other class(es) it must collaborate to fulfill each responsibility A brief description of the class on the back of the card. In the example, class Foo must collaborate with (send messages to) ClassX and ClassY in order to fulfill its responsibility to be able to “do something.” ","date":"2023-09-04","objectID":"/posts/se/l/:8:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"8.3 SOLID DESIGN PRINCIPLES Single responsibility principle Open/closed principle Liskov substitution principle Interface segregation principle Dependency inversion principle 8.3.1 Single Responsibility Principle Each responsibility is a reason for change. A class should have ONLY ONE reason to change. 8.3.2 Open/Closed Principle Software entities should be open for extension (good for inheritance) but closed for modification.(modification should not be open to clients) 8.3.3 Liskov Substitution Principle Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program 8.3.4 Interface Segregation Principle Many client-specific interfaces(small) are better than one general-purpose(big) interface. One interface for each responsibility. 8.3.5 Dependency Inversion Principle Limited reusability of the higher-level components High-level modules should not depend on low-level modules. Both should depend on abstractions(interface); Abstractions should NOT depend on details. Details should depend on abstractions. ","date":"2023-09-04","objectID":"/posts/se/l/:8:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"9 Software Testing ","date":"2023-09-04","objectID":"/posts/se/l/:9:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"9.1 Program Testing Testing is intended to show that a program does what it is intended to do and discover program defects before it is used. using input data and checking the results of the test run for errors, anomalies, or information about the program’s non-functional attributes. Goals: To demonstrate to the developer and the customer that the software meets its requirements. To discover situations in which the behavior of the software is incorrect, undesirable or does not conform to its specification 9.1.2 Validation and Defect Testing first goal leads to validation testing perform correctly using a given set of test cases A successful test shows that the system operates as intended. second goal leads to defect testing The test cases are designed to expose defects. The test cases in defect testing can be deliberately obscure and need not reflect how the system is normally used. A successful test makes the system perform incorrectly and expose a defect in the system. Can reveal the presence of errors but NOT their absence. Extreme case like, Integer.MAX_VALUE; 9.1.3 Verification and Validation Testing is part of a more general V\u0026V process Verification: The software should conform to its specification. “Are we building the product right”. Validation: The software should do what the user really requires. “Are we building the right product.” Aim to establish confidence that the system is “fit for purpose” Software purpose:The level of confidence depends on how critical the software is to an organization. User expectations: Users may have low expectations of certain software. Marketing environment: Getting a product to market early may be more important than finding defects in the program. 9.1.4 Software Inspections examining the source representation with the aim of discovering anomalies and defects. Applicable to any representation of the system(Requirements, design,configuration data, test data, etc) During testing, errors can mask(hide) other errors. a static process, do not have to be concerned with interactions between errors; broader quality attributes of a program, like compliance with standards, portability, maintainability, etc. 9.1.5 Stages of Testing Development testing: test during development to discover bugs and defects. Release testing: tests a complete version of the system before it is released to users.(separate testing teal) User testing: Users or potential users of a system are involved in testing ","date":"2023-09-04","objectID":"/posts/se/l/:9:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"9.2 DEVELOPMENT TESTING 9.2.1 Development Testing Including all testing activities carried out by the development team Unit testing: Individual program units or object classes are tested. Focus on testing the functionality of objects or methods. Component testing: Individual units are integrated to create composite components. Focus on testing component interfaces. System testing: Some or all of the components in a system are integrated, and the system is tested as a whole. Focus on testing component interactions. White box testing vs. black box testing With vs. without knowledge about the internal structure, design, or implementation of the software 9.2.2 Unit Testing The process of testing individual code units in isolation Individual functions or methods within an object Object classes with several attributes and methods Object class testing: Coverage of all the features of an object Getting and setting ALL object attributes Testing ALL operations associated with an object Exercising the object in ALL possible states. Simulating ALL events that cause a state change. Inheritance makes it more difficult to design object class tests as the information to be tested is not localized. Automated Testing unit test execution should be automated Automated Test Components A setup part, namely the inputs and expected results whe initiating the test A call part, call the object or method to be tested An automated mechanism to compare the result of the call with the expected result Test Automation Framework like JUnit use framework to write and run tests provided generic test classes Testing Strategies Partition testing Identify groups have common characteristics should be processed in the same way Choose tests from within each of these groups. Guideline-based testing Software with sequences only a single value. different sizes in different tests Derive tests so that the sequence’s first, middle, and last elements are accessed. sequences of zero length. General software Choose inputs that force the system to generate all error messages cause input buffers to overflow; Repeat the same input or series of inputs numerous times; Force computation results to be too large or too small. 9.2.3 Component Testing Software components are often composite units comprising several interacting objects. functionality is accessed through defined interface: component interface behaves according to its specification. assume unit tests on individual objects within component is completed Interface Testing Goals: detect faults due to interface errors or invalid interface assumptions. Interface types Parameter interfaces. Shared memory interfaces. Procedural interfaces. Message passing interfaces. Interface Errors Interface misuse Interface misunderstanding Timing errors Interface Testing Guidelines Design tests so that parameters to a called procedure are at the extreme ends of their ranges. Always test pointer parameters with null pointers. Design tests that cause the component to fail. Use stress testing in message-passing systems. In shared memory systems, vary the order in which components are activated. 9.2.4 System Testing Involves integrating components to create a system and then testing the integrated system. Tests can be derived from the use cases checks that components are compatible, interact correctly, and transfer the right data at the right time System testing overlaps with component testing, but there are two important differences: The complete system is tested. A collective rather than an individual process. component testing may be individual Testing Policies Exhaustive system testing is impossible; required system test coverage may be developed. When to stop the testing; Policies: Functions accessed through menus should be tested; Combinations of functions (e.g., text formatting) that are accessed through the same menu must be tested; On user input is provided, all functions must be tested with both correct and incorrect input. Regression t","date":"2023-09-04","objectID":"/posts/se/l/:9:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"9.3 Release Testing 9.3.1 Release Testing testing a particular release of a system that is intended for use outside of the development team. Validation testing; to convince the supplier of the system that it is good enough for use(primary goal) has to show system delivers specified functionality, performance, and dependability no expected behaviors or results black-box testing process 9.3.2 Release Testing and System Testing A form of system test Requirements-based testing examines each requirement and developing or tests for it. Scenario testing uses typical scenarios to develop test cases for the system. Differences separate team in release testing, NOT in system testing; Discovering bug is in System testing, NOT in release testing; Release testing: meets its requirements and is good enough for external use (validation testing). performance testing performance and reliability. Tests should reflect the profile of use of the system. Performance tests: planning a series of tests where the load is steadily increased until the system performance becomes unacceptable. Stress testing: a form of performance testing - system is deliberately overloaded to test its failure behavior. ","date":"2023-09-04","objectID":"/posts/se/l/:9:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"9.4 User Testing users or customers provide input and advice on system testing. Essential than system and release testing have been carried out. influences from the user’s working environment have a major effect on the reliability, performance, usability, and robustness of a system. Types of User Testing Alpha testing: Users are involved, but still inside the develop team; from their site; Beta testing: open to users to allow them to experiment with a special release of software above are on how test performed. Acceptance testing whether or not it is ready to be accepted from the system developers and deployed in the customer environment. An inherent part of custom systems development. The Acceptance Testing Process Agile Methods and Acceptance Testing user/customer is part of the development team and is responsible for making decisions on the acceptability of the system. NO separate acceptance testing process. ","date":"2023-09-04","objectID":"/posts/se/l/:9:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10 Software Evolution Software change is inevitable Errors must be repaired; Performance or reliability of the system may have to be improved. Business environment changes; New computers and equipment is added to the system; New requirements emerge when the software is used; Evolution The software system is in operational use Significant changes to the architecture and functionality are made Servicing The software remains useful Only small tactical changes are made Retirement Only essential changes are made, and users must work around problems The software is taken out of use after its data is transferred ","date":"2023-09-04","objectID":"/posts/se/l/:10:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10.1 Evolution Processes Depend on type of software being maintained; development processes used; skills and experience of the people involved. Proposals for change are the driver for system evolution bug reports from system stakeholders requests for adaptation to the new environment new ideas for software improvement from the system development team requests for new requirements 10.1.1 General Model Change Implementation Iteration of the development process where the revisions to the system are designed, implemented, and tested. Different between development and evolution the first stage of change implementation may involve program understanding 10.1.2 Change Management Process The process of analyzing the costs and benefits of proposed changes approving those changes that are cost-effective, and tracking which components in the system have been changed. 10.1.3 Agile Methods and Evolution Agile methods are based on incremental development so the transition from development to evolution is a seamless one. Evolution is simply a continuation of the development process based on frequent system releases. Automated regression testing is particularly valuable when changes are made to a system. Changes may be expressed as additional user stories. Problems Development team $\\to$ agile approach, however evolution team $\\to$ plan-based approach A plan-based approach has been used for development, but the evolution team prefer to use agile methods. ","date":"2023-09-04","objectID":"/posts/se/l/:10:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10.2 Software Maintenance Modifying a custom software after it has been put into use Generic software products evolve to create new versions. Does not normally involve major changes to the system’s architecture. Changes are implemented by modifying existing components and adding new components to the system. Types of maintenance Fault repairs(24%) Environmental adaptation(19%) Functionality addition and modification(58%) 10.2.1 Maintenance Cost greater than development costs (2* to 100* depending on the application). Cost increases as software is maintained. Expensive to add new features to a system during maintenance than it is to add the same features during development Reasonss: Program maintenance work is unpopular Separating maintenance and development means no incentive for the development team to write maintainable software New team has to understand the programs being maintained As programs age, their structure degrades, and they become harder to change 10.2.2 Software Re-engineering Restructuring or rewriting part or all of a legacy system without changing its functionality make them easier to maintain. Advantages of reengineering over replacement Reduce risk Reduce cost Reengineering cost factors Quality of the software to be reengineered. Tool support available for reengineering. Extent of the data conversion which is required. Availability of expert staff for reengineering. Limitation Converting the programming paradigm is impossible Major architectural or data management changes are expensive The resulting system probably is not as maintainable as a new system ","date":"2023-09-04","objectID":"/posts/se/l/:10:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10.2.3 Refactoring vs. Re-engineering Refactoring A continuous process of improvement throughout the development and evolution process When refactoring a program, you should NOT add functionality but rather concentrate on program improvement. Like preventative maintenance It is intended to avoid the structure and code degradation that increases the costs and difficulties of maintaining a system. Re-engineering Happens after a system has been maintained for some time and maintenance costs are increasing Uses automated tools to process and re-engineer a legacy system to create a new, more maintainable system. ","date":"2023-09-04","objectID":"/posts/se/l/:10:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10.3 Version Management The process of keeping track of different versions of software components or configuration items and the systems in which these components are used. Ensures that changes made by different developers to these versions do not interfere with each other. 10.3.1 Codelines and Baselines Codeline A sequence of versions of source code with later versions in the sequence derived from earlier versions. Baseline specifies the component versions included in a specific system and the libraries and configuration files, etc., used. 10.3.2 Version Control Systems Identify, store and control access to the different versions of components. Two types Centralized systems: a single master repository that maintains all versions of the software components that are being developed. Example: Subversion Distributed systems: Multiple versions of the component repository exist simultaneously. Example: Git Five Features Version and release identification Change history recording Support for independent development Project support Storage management Version control systems vs. cloud storage systems VCS Contains multiple changes; Help to merge the changes CSS Totally overwrite the old version, like Google Drive; 10.3.3 Project Repository and Private Workspace Project Repository Maintains the ‘master’ version of all components, which is used to create baselines for system building. When modifying components, developers copy (check-out) these from the repository into their workspace and work on these copies. When they have finished their changes, the changed components are returned (checked-in) to the repository. Centralized vs. distributed In centralized version control, a private workspace contains only components from the project repository. In distributed version control, a clone of the project repository. Benefits of Centralized vs Distributed VC Centralized It is easier to learn and set up It takes less time and space to download part of a project Distributed Provides a backup mechanism for the repository Allows for offline working faster Project support is the default way of working Working on branches is easier Fewer merge conflicts with other developer’s code 10.3.4 Organization of Open-Source Development 10.3.5 Branching and Merging Rather than a linear sequence of versions that reflect changes to the component over time, there may be several independent sequences. Branch: Avoid to interfere with each other; Merge: Merge codeline branches to create a new version of a component that includes all changes that have been made. Improve the flexibility of the VCS; when new idea coming in; 10.3.6 Storage Management Instead of keeping a complete copy of each version, the system stores a list of differences (deltas) between one version and another, because disk space was expensive. (Centralized VCS) Drawback: Difficult to get the least version of the code; find from the first version from beginning; chain of operations. Git (Distributed VCS) Git does NOT use deltas but applies a standard compression algorithm to stored files and their associated meta-information. does not store duplicate copies of files. simply involves decompressing it, with no need to apply a chain of operations. ","date":"2023-09-04","objectID":"/posts/se/l/:10:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"10.4 Legacy System Older systems that rely on languages and technology that are no longer used for new systems development. Problems Legacy system replacement is risky and expensive Lack of complete system specification Tight integration of system and business processes Undocumented business rules embedded in the legacy system New software development may be late and/or over budget Legacy systems are expensive to change No consistent programming style Use of obsolete programming languages with few people available with these language skills Inadequate system documentation System structure degradation Program optimizations may make them hard to understand Data errors, duplication, and inconsistency ","date":"2023-09-04","objectID":"/posts/se/l/:10:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11 Software Reuse Reuse-based software engineering System reuse Application reuse Component reuse Object and function reuse Benefits Accelerated development Effective use of specialists Increased dependability Lower development costs Reduced process risk Standards compliance Problems Creating, maintaining, and using a component library Finding, understanding, and adapting reusable components Increased maintenance costs Lack of tool support Not-invented-here syndrome ","date":"2023-09-04","objectID":"/posts/se/l/:11:0","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11.1 Reuse Landscape Reuse is possible at a range of levels from simple functions to complete application systems. The reuse landscape covers the range of possible reuse techniques. Approach Approach Description Architectural patterns Standard software architectures that support common types of application patterns system are used as the basis of applications Program libraries Class and function libraries that implement commonly used abstractions are available for reuse. Application frameworks Collections of abstract and concrete classes are adapted and extended to create application systems. Software product lines An application type is generalized around a common architecture so that it can be adapted for different customers. Component-based software engineering Systems are developed by integrating components (collections of objects) that conform to component-model standards. Service-oriented systems Systems are developed by linking shared services, which may be externally provided. Design patterns Generic abstractions that occur across applications are represented as design patterns showing abstract and concrete objects and interactions. Model-driven engineering Software is represented as domain models and implementation independent engineering models and code is generated from these models. Application system integration Two or more application systems are integrated to provide extended functionality Reuse Planning Factors The development schedule for the software. The expected software lifetime. The background, skills and experience of the development team. The criticality of the software and its non-functional requirements. The application domain. The execution platform for the software. Reasons not to reuse Unwillingness to compromise the requirements Preference to known risks of development over unknown risks of reuse, even if the latter may be larger ","date":"2023-09-04","objectID":"/posts/se/l/:11:1","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11.2 APPLICATION FRAMEWORKS “an integrated set of software artifacts(such as classes, objects, and components) that collaborate to provide a reusable architecture for a family of related applications.” Classes are reused directly and may be extended using features such as inheritance and polymorphism. Frameworks support design reuse providing a skeleton architecture for the application specific classes in the system. Frameworks provide support for generic features all applications of a similar type The problem with frameworks is complexity, meaning a long time yo use effectively. 11.2.1 Web Application Frameworks(WAFs) Commonly used to develop web applications Spring for Java, Django for Python, and Angular for JavaScript. Support the construction of dynamic websites as a front-end for web applications. Security, dynamic web pages, database support, session management, user interaction Architecture of WAFs is based on MVC composite pattern. 11.2.2 Extending Frameworks Frameworks are generic and are extended to create a more specific application or sub-system. Involves: Adding concrete classes that inherit operations from abstract classes in the framework; Adding (callback) methods that are called in response to events that are recognized by the framework. ","date":"2023-09-04","objectID":"/posts/se/l/:11:2","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11.3 SOFTWARE PRODUCT LINES A set of applications with a common architecture and shared components, with each application specialized to reflect different requirements. Printer drivers, MS Office Specialization Selecting from a library of existing components; Component and system configuration; Modifying components to meet new requirements. Adding new components to the system; 11.3.1 Base System Software product lines usually emerge from existing applications. Designing a generic product line involves identifying common functionality in product instances; developing a base application to simplify reuse and reconfiguration. A base application includes Core components that provide infrastructure support; Configurable components that may be modified and configured to specialize them to a new application. Specialized, domain-specific components some or all of which may be replaced when a new instance of a product line is created. 11.3.2 Application Frameworks and Product Lines Both support a common architecture and components require new development to create a specific version of a system. Differences Application framework Software product line Application frameworks rely on object-oriented features Product lines need not be object-oriented. Application frameworks provide general rather than domain- specific support Product lines embed domain and platform information. Application frameworks are usually software-oriented. Product lines are often control applications for equipment. Application frameworks are Not Product lines are made up of a family of applications, usually owned by the same organization. The architecture of a software product line often reflects a general, application-specific architectural style or pattern. ","date":"2023-09-04","objectID":"/posts/se/l/:11:3","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11.4 COMPONENT-BASED SOFTWARE ENGINEERING (CBSE) An approach to software development that relies on the reuse of entities called “software components” The failure of object-oriented development to support effective reuse: Single object classes are too detailed and specific. Components are more abstract than object classes and can be stand-alone service providers. CBSE essential Independent components specified by their interfaces. Component standards to facilitate component integration. Middleware that provides support for component inter-operability A development process that is geared to reuse. Component Characteristics 11.4.1 Components As Providers of Services A component is a provider of one or more services an independent executable entity defined by its interfaces. In principle, all components have two related interfaces The “provides” interface: defines the services provided by the component. The “requires” interface: specifies the services that other components in the system must provide if a component is to operate correctly. 11.4.2 Component Models A component model defines standards for component implementation, documentation, and deployment. EJB model (Enterprise Java Beans) COM+ model (.NET model) CORBA Component Model (CCM) Basic elements Interfaces Usage information Deployment Component Model Implementation A component model implementation provides platform services and support services Components can be considered as being deployed in containers A container is an implementation of these services plus a definition of the interfaces a component MUST provide to integrate it with the container. 11.4.3 CBSE Processes Software processes that support component-based software engineering. Development for reuse: Process concerned with developing components or services that will be reused in other applications. Development with reuse: Process of developing new applications using existing components and services. Supporting Processes Component acquisition is the process of acquiring components for reuse or development into a reusable component. involve accessing locally-developed components or services or finding these components from an external source. Component management is concerned with managing a company’s reusable components, ensuring that they are properly catalogued, stored and made available for reuse. Component certification is the process of checking a component and certifying that it meets its specification. ","date":"2023-09-04","objectID":"/posts/se/l/:11:4","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"11.5 SERVICE-ORIENTED ARCHITECTURES A way of building distributed applications using web services. A web service is a loosely coupled, reusable software entity that encapsulates discrete functionality, which may be distribute and programmatically accessed. Service-oriented SE vs. Component-based SE When building a service-oriented system, reference the external service; Each system that reused a component had to incorporate its own copy of that component. Components are deployed in containers and rely on the containers’ support to communicate with each other. Services communicate based on established protocols (e.g., HTTP, HTTPS) and data format (e.g., XML, Schemata) Benefits Services can be offered by any service provider inside or outside of an organization. The service provider makes information about the service public so that any authorized user can use the service. Applications can delay the binding of services until they are deployed or until execution. loosely coupled can choose which service at run time; flexible Opportunistic construction of new services is possible. Service users can pay for services according to their use rather than their provision. Applications can be made smaller, which is particularly important for mobile devices with limited processing and memory capabilities. Service-Oriented Architecture (SOA) An architectural style that focuses on the use of services to support business requirements. Service providers design and implement services and specify the interface to these services; publish information about these services in an accessible registry. Service requestors(service clients) make use of a service discover the specification of that service and locate the service provider. bind their application to that specific service and communicate with it, using standard service protocols. Service Engineering The process of developing services for reuse in service-oriented applications Service candidate identification identify possible services that might be implemented and define the service requirements. Service design design the logical service interface and its implementation interfaces. Service implementation and deployment implement and test the service and make it available for use. 学习笔记，仅供参考 ","date":"2023-09-04","objectID":"/posts/se/l/:11:5","tags":["Software Engineering","笔记"],"title":"Software Engineering","uri":"/posts/se/l/"},{"categories":["学习笔记"],"content":"这篇文章展示了系统编程的学习记录","date":"2023-09-04","objectID":"/posts/sp/l/","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"这篇文章展示了系统编程的学习记录 System Programming ","date":"2023-09-04","objectID":"/posts/sp/l/:0:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0 Background ","date":"2023-09-04","objectID":"/posts/sp/l/:1:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.0 What is Operating System? An operating system is an intermediary between a computer user and the hardware Make the hardware convenient to use Manages system resources Use the hardware in an efficient manner ","date":"2023-09-04","objectID":"/posts/sp/l/:1:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.1 Types of Operating Systems Batch Single CPU User submits large number of tasks at one time OS decides what to run and when Back-to-back single tasking Time Sharing Multiple users connected to a single CPU Many user terminals Multiple tasks run simultaneously using time-sharing, giving users the feeling of having multiple dedicated CPUs running in parallel Parallel Multiple CPUs closely coupled to form one computer Higher throughput and better fault tolerance Each CPU can be running batch tasking or time-sharing multitasking Distributed Multiple CPUs loosed coupled via networking Real-time Very strict response time requirements Periodical tasks, every job of a task has a strict deadline ","date":"2023-09-04","objectID":"/posts/sp/l/:1:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.2 Single Tasking System vs. Multi-tasking System Single Tasking System Each task, once started, executes to its very end without any interruption from other task(s). Simple to implement: sequential boundaries between tasks, and resource accesses. Few security risks Poor utilization of the CPU and other resources Example: MS-DOS Multi-tasking System Very complex Serious security issues How to protect one task from another, which shares the same block of memory Much higher utilization of system resources Support interactive user/physical-world interface Example: Unix, Windows NT ","date":"2023-09-04","objectID":"/posts/sp/l/:1:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.3 Hardware Basics OS and hardware closely tied together Basic hardware resources:CPU, Memory, Disk, I/O 0.3.1 CPU CPU controls everything in the system It is involved in any work needs to be done Most precious resource This is what you are paying for Users would usually prefer high utilization (from useful work) Only one process running on a CPU at a time Millions or even billions of machine instructions per second Getting faster all the time 0.3.2 Memory Limited capacity Never enough, and expanding over the years Temporary (volatile) storage Electronic storage Fast, random access Any process to run on the CPU must first be loaded into memory 0.3.3 I/O Many I/O devices Keyboard, mouse, monitor, printer etc. Most I/O devices are painfully slow Need to find ways to deal with high I/O latency Like multiprogramming ","date":"2023-09-04","objectID":"/posts/sp/l/:1:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.4 Protection and Security OS must protect itself from users Reserved memory only accessible by OS OS may protect users from one another ","date":"2023-09-04","objectID":"/posts/sp/l/:1:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.5 Interrupts Modern OSs are event driven Event is signaled by special hardware signal sent to the CPU Two types of events Hardware Interrupts: caused by external hardware, can occur at anytime Software Interrupts (aka Exceptions, Traps): caused by software, synchronous to CPU clock 0.5.1 Interrupt Philosophy Use an interrupt table and special hardware to redirect CPU execution By the end of interrupt handling, the CPU can resume the interrupted process 0.5.2 Interrupt Table Large array of addresses indicating what code to run (interrupt routine) for a given interrupt Each interrupt has a corresponding number associated with it On Intel processors this is from 0 to 255 This gives fixed size interrupt table Use the interrupt number to index into the array to find out what code to run (interrupt routine) 0.5.3 Hardware to Support Hardware Interrupts Programmable Interrupt Controller (PIC) Connected to I/O devices via Interrupt Request Lines (IRQ) or Bus (e.g. PCI Express) PIC connected to the CPU by a special line or bus CPU\u003c==\u003ePIC\u003c==\u003eI/O devices \u003c==\u003e can be special signals via dedicated wire lines (IRQ), or special sequences of back-and-forth messages via bus(es) (virtual IRQ) 0.5.4 IRQ Architecture 0.5.5 Hardware Handling of Interrupts (Conventional IRQ as an Example) After each instruction executes, CPU checks if the IRQ pin voltage has been raised If so 1. Sets the system into kernel mode (if not already there) 2. Determine interrupt number (from PIC or instruction) 3. Read appropriate interrupt table entry Special register contains base address of interrupt table Each entry in table is fixed size so easy to calculate where to look in memory (e.g. memloc = iptr + 8 * intNum) 4. Saves the process state to the stack (particularly, the program counter) 5. Saves error code to stack (if it exists) 6. Loads the program counter with the value stored in the interrupt table This starts the CPU executing in the interrupt routine ","date":"2023-09-04","objectID":"/posts/sp/l/:1:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.6 Peripheral Devices Input Devices Output Devices Storage (memory is usually not considered as a peripheral) 0.6.1 Peripheral Devices for Embedded Systems Embedded Systems: computer systems that do not look like conventional computer systems, e.g. mobile devices, devices tightly coupled with the physical world (i.e. cyber-physical systems). Input Devices: Sensors Output Devices: Actuators ","date":"2023-09-04","objectID":"/posts/sp/l/:1:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.7 Historical Perspective Application built on top of hardware Problems: Complexity: have to know the tedious low-level programming details of the hardware Inflexibility: when the hardware changes, the application has to change with it. Application built on top of OS Ideal: OS application programming interface (API) hides the complexity and heterogeneity of hardware programming. As long as the OS API remain the same, the hardware can change. Design goal conflict: Full exploitation of hardware features Versus Full platform independence and simple API Application built on top of OS Ideal: OS application programming interface (API) hides the complexity and heterogeneity of hardware programming. As long as the OS API remain the same, the hardware can change. Design goal conflict: Full exploitation of hardware features Versus Full platform independence and simple API Want to exploit more features of the hardware: Application + OS Want to be more platform independent and simpler API: Application + Virtual Machine (VM) Virtual Machine (VM) can hide the heterogeneity of OS APIs As long as the VM API remain the same, the OS (and hardware) can change, and the application can remain the same. ","date":"2023-09-04","objectID":"/posts/sp/l/:1:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"What is System Programming? Application programs (+ application layer libraries) Programs for direct interaction with users Compiler programs, assembler programs, linker programs Tools that convert application programs to executables Operating systems kernel programs Programs that interface other software with the hardware Layers of Programs (Development Time) Layers of Programs (Run Time) ","date":"2023-09-04","objectID":"/posts/sp/l/:2:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1 Unix ","date":"2023-09-04","objectID":"/posts/sp/l/:3:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.1 The Unix Philosophy Modular design A collection of simple tools, with limited well-defined functions File system Inter-process communication The tools can be easily composed (via \u003e, \u003e\u003e, \u003c, |,``) by a shell to accomplish complex tasks ","date":"2023-09-04","objectID":"/posts/sp/l/:3:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.2 Unix Kernel and System Calls Main duties process scheduling and management inter-process communication memory management file management network stack management date and time management system accounting security device management interrupt and exception handling Other parts of the Unix system, as well as user programs, request the kernel for various services through system calls A system call is an entry point into the kernel, typically packaged as a function call, as part of the OS API. a software interrupt (trap) switches the CPU hardware to the kernel mode execute kernel routines return kernel mode first, to the scheduler, check schedule of other tasks switches back(via scheduling*) to the user mode to resume the user application ","date":"2023-09-04","objectID":"/posts/sp/l/:3:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.3 Unix Commands and Utilities A large set of tools for various basic user level functions A vocabulary and a grammar, to combine basic user level functions to nearly arbitrary sophisticated functions Not part of the kernel, but a part of the OS Typically accessed via the Shell ","date":"2023-09-04","objectID":"/posts/sp/l/:3:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.4 Unix Shell A powerful command interpreter (a user level application) for Unix – accepts user text commands and carries them out Can combine various user level applications to serve more sophisticated functionalities ","date":"2023-09-04","objectID":"/posts/sp/l/:3:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.5 Unix Libraries \u0026 Device Drivers ","date":"2023-09-04","objectID":"/posts/sp/l/:3:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Features of Unix Portability Multi-user Operation Multitask Processing Hierarchical File System Powerful Shell Pipes Networking Robustness ","date":"2023-09-04","objectID":"/posts/sp/l/:3:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.6 Unix is Portable Unix is a relatively hardware independent OS. Various mechanisms (device driver, various C program interfaces inside of the kernel and to the user level) are designed to encapsulate the hardware specifics, facilitating porting between hardware platforms. One key to the portability is the device drivers, specific modules that encapsulate the hardware details from the other parts of the kernel and the user level. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.7 Unix supports multi-users and multi-tasking For a single user, time sharing can still support multi-tasking. Multiple users may run multiple tasks concurrently. Unix supports background processing, which allows a user to initiate a task “in the background” and then proceed to other activities. Unix time shares between the front-end commands and background jobs. Unix allows the creation of new tasks from an existing task. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.8 Unix has a hierarchical file system Unix files are organized into separate directories. Directories are themselves organized into a tree-like structure. There is one master directory, the so-called root directory, from which various sub-directories branch off. The hierarchical structure offers a maximum flexibility for grouping information in a way that reflects its natural structure. A single user’s data may be grouped by activity Data from many different users can be grouped according to corporate organization As a result, stored data is easier to locate and manage ","date":"2023-09-04","objectID":"/posts/sp/l/:3:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.9 Unix shell is powerful T he Unix shell supports a number of convenient features, such as: Redirection of application input and output, e.g. ls \u003e myfiles The ability to manipulate groups of files with a single command. Executing a sequence of commands stored in a text file, called a “shell script,” allowing us to build our own commands, which may be parameterized. Being used as a programming language that provides string-valued variables and control flow primitives including branching and iteration ","date":"2023-09-04","objectID":"/posts/sp/l/:3:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.10 Unix’s pipe is novel A pipe passes the standard output of one command directly to another command, to be used as its standard input, e.g. who | sort Allows any number of commands to be connected in a sequence, and automatically handles the data flow from one program to the next who | sort | lp Produces the same effect as if one large program, rather than several small ones, had been executed. Allowing the combination of several simple programs to perform more complex functions Eliminating the need for new software development. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:11","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.11 Unix supports networking Supports TCP/IP protocols, and provides a new OS abstraction, the socket, that allows application-level programs to access the Internet. The socket abstraction acts as an interface between application level programs and the underlying TCP/IP protocols. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:12","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.12 Unix is robust When encountered an error, a Unix program does not abort. Instead, the program receives a returned value indicating an error condition, and it is up to the program to check for the error and handle it. Typically, a returned error value is negative if the return type is int, or a NULL if the return type is a pointer. You can call the C library function perror() to output a message string to the standard error file, to further explain the error. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:13","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Unix Demo Task 2: ls: list the files in the current directory ls -l: list the files in the current directory in long format ls -a: list the files in the current directory, including the hidden files ls -t: list the files in the current directory, sorted by time ls -lat: list the files in the current directory, including the hidden files, in long format, sorted by time cd: change the current directory .: the current directory ..: the parent directory cp: copy a file cp file1 file2: copy file1 to file2 cp file1 file2 file3 dir: copy file1, file2, file3 to dir cp -r dir1 dir2: copy dir1(all the content) to dir2 recursively mv: move a file mv file1 file2: move file1 to file2 mv file1 file2 file3 dir: move file1, file2, file3 to dir mv dir1 dir2: rename dir1 to dir2 rm: remove a file rm -rf dir: remove dir recursively and forcefully mkdir: make a directory mkdir dir: make a directory named dir who: show the users who are currently logged in whami: show the current user who -q: show the number of users who are currently logged in who -u: show the idle time of the users who are currently logged in cat: concatenate files and print on the standard output cat file: print the content of file on the standard output cat file1 file2: print the content of file1 and file2 on the standard output cat file1 file2 \u003e file3: concatenate file1 and file2, and write the result to file3 cat file1 file2 \u003e\u003e file3: concatenate file1 and file2, and append the result to file3 man: an interface to the on-line reference manuals man command: show the manual of command man -k keyword: search the manual for keyword man -f command: show the manual of command man -a command: show all the manual of command gcc: GNU project C and C++ compiler gcc file: compile file gcc file -o file: compile file and output the executable file to file gcc file1 file2 -o file: compile file1 and file2 and output the executable file to file Task 3: vi: a text editor vi file: open file in vi i: enter insert mode esc: exit insert mode, enter command mode Under command mode: :w: save the file :q: quit vi :wq: save and quit vi :q!: quit vi without saving h: move leftward; l: move rightward; j: move downward; k: move upward w: move rightward word by word; b: move leftward word by word dw: delete the word after the cursor u: undo the last command dd: delete the current line $: move to the end of the line; ^: move to the beginning of the line gedit: a text editor gedit file: open file in gedit Task 4: Shell output redirection who \u003e users: redirect the output of who to file users, overwriting(replace) the original content of users who \u003e\u003e users: append the output of who to file users Task 5: Shell input redirection wc \u003c users: redirect the content of users to wc, and count the number of lines, words, and characters in users wc -l: count the number of lines wc -l \u003c output.txt \u003e output1.txt: count the number of lines in output.txt, and write the result to output1.txt Task 6: write, compile, and run a C program vim hello.c: write a C program in vi gcc hello.c -o hello: compile the C program and output the executable file to hello ./hello: run the executable file External Task: pipeline - make a pipe among processes ls -l | wc -l: count the number of files in the current directory ls -l | grep \"hello\": list the files in the current directory whose name contains “hello” ls -l | grep \"hello\" | wc -l: count the number of files in the current directory whose name contains “hello” ","date":"2023-09-04","objectID":"/posts/sp/l/:4:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2 Unix Processes What is a process? What does a process look like in the system? When is a process created? By whom? How is a process created? In how many ways? When does a process stop? Can we wait for a process to die? What is a process called if it never die? ","date":"2023-09-04","objectID":"/posts/sp/l/:5:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.1 Common definition A process is an instance of a program in execution (the execution of the program has started but has not yet terminated). Process is dynamic while program is static. A process is the basic unit for competing the resources. In particular, it is the basic active entity to CPU scheduler. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.2 How to understand it? State of a computer at clock tick (i.e. discrete time) $i$: $S(i)$ = (register 1’s value, register 2’s value, …, 1st memory byte’s value, 2nd memory byte’s value, …, 1st hard disk byte’s value, 2nd hard disk byte’s value, …, peripheral 1’s register 1’s value, peripheral 1’s register 2’s value, …). State of an execution $e$ at clock tick $i$: $s(e, i)$ = (resources used by $e$ at $i$, state of the resources used by $e$ at $i$). A process is the time sequence of ${s(e, i)}$, where every two consecutive states $s(e, j)$ and $s(e, j+1)$ have causal relationship determined by the program logic and the OS. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.3 how to turn a program into a process? The program is read into memory. A unique process ID is assigned. OS kernel creates a process structure instance to record information related to this process. Necessary resources to run the program are allocated. The initial state $s(e,0)$ is set, which will trigger its next state $s(e, 1)$, which will trigger its next state $s(e,2)$, … determined by the program logic and the OS. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.4 Notion of threads (lightweight processes) A process is the time sequence of ${s(e, i)}$, where every two consecutive states $s(e, j)$ and $s(e, j+1)$ have causal relationship determined by the program logic and the OS. In older OSs, each process has its exclusive set of resources, even for processes that are related (e.g. sharing data). This is wasteful. Modern OSs propose the notion of “threads”. Threads are processes that have shared resources, typically created by a same ancestor process. Because the resource allocation is more thrifty, threads are also called “lightweight processes”. left: multi-processes - fork() right: multi-threads ","date":"2023-09-04","objectID":"/posts/sp/l/:5:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.5 What resources to share and what not to share? store and restore the register values partition the registers into different sets temporarily for threads ","date":"2023-09-04","objectID":"/posts/sp/l/:5:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.6 Thread realization and programming interface And at the user level, there is a de facto standard C thread programming interface: PThread (POSIX Thread). But different OSs (even OSs belonging to the Unix family) have different ways to realize the concepts and the PThread programming interface. For example, modern Linux no longer differentiate threads and processes, all are realized as copy-on-write (COW) processes (aka “task”). For example, every time the parent thread creates a new thread, in the Linux implementation, there is a parent COW process creating a child COW process. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.8 Process Image ","date":"2023-09-04","objectID":"/posts/sp/l/:5:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.9 Process management Besides its image, a process has its corresponding meta data (in kernel) for the OS to manage it, e.g. process ID. A Unix OS typically maintains a hierarchy of processes related by parent-child links: the process that requests to create another process is called the parent process, the created process is called the child process. A child process inherits all the properties of its parent when it is created, but can change after creation (even changing its code image). Process ID – integer PID Parent process ID – an integer PPID User process ID – an integer UID In Unix, each user has a unique user ID. Each process is associated with a particular user called the owner of the process, which executes the program. The owner has certain privileges with respect to the process. Use getpid, getppid, and getuid to determine the ID of the current, parent, and the owner. ps is the short for “process status”. ps lists your current processes ps –a lists more processes, including ones being run by other users and at other terminals (but not include the shells) ps –l prints longer, more information lines, including UID, PID, PPID, process status, etc. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.10 Related Portable OS Interface (POSIX) APIs The Portable Operating System Interface (POSIX) is a family of standards specified by the IEEE Computer Society for maintaining compatibility between OSs. Demo Task 2 getpid: get the process ID of the current process getppid: get the process ID of the parent process getuid: get the user ID of the current process #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e // Unix Standard void main (void){ printf(\"Process ID: %ld\\n\", (long)getpid()); printf(\"Parent ID: %ld\\n\", (long)getppid()); printf(\"Onwer user ID: %ld\\n\", (long)getuid()); } Result Demo Task3 fork(): create a new process Allocates a new chunk of memory and kernel data structure. Copies the parent process’s image and kernel data structure into the new process’s, with needed modifications (e.g.PID, PPID). Adds the new process to the set of “Ready” processes. Returns control back to both processes (by setting the program counter in the respective image, and leaving the processes to the scheduler). Return twice: once in the parent, once in the child. // demo 3 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork, mypid; mypid = getpid(); printf(\"Before: my pid is %d\\n\", mypid); ret_from_fork = fork(); sleep(1); printf(\"After: my pid is %d, fork() said %d\\n\", getpid(), ret_from_fork); } Result use man -S3 sleep to see the manual of sleep system call user man sleep to check sleep user command orphan process may happen since the parent process may terminate before the child process of the above code Demo Task 4 // demo 4 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork; printf(\"Before: my pid is %d\\n\", getpid()); if ((ret_from_fork = fork()) == 0) { fprintf(stderr, \"I am the child, ID = %ld\\n\", (long)getpid()); } else if (ret_from_fork \u003e 0) { fprintf(stderr, \"I am the parent, ID = %ld\\n\", (long)getpid()); } else { fprintf(stderr, \"Fork failed!\\n\"); } } Result Demo Task 5 In-class exercise: forking a chain of processes the child process will fork a child process, then previous child process will die; the new child process will fork a child process, then previous child process will die; … // demo 5 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if (childpid = fork()) break; //parent breaks out; child continues fprintf(stdout, \"This is process %ld with parent %ld, i = %d\\n\",(long)getpid(), (long)getppid(), i); } Result parallels@ubuntu-linux-20-04-desktop:~/Desktop/text$ the result above shows the parent process PID=164147 has terminated before the child process PID=164149 are created, so these two child processes become orphan processes, with parent process PID=1193 (the init process - user) For thr first fork(), the parent process will break out of the loop, and call fprintf(), then terminate. This parent process has the “full image” of whole c program. So when this process terminates, the whole c program terminates, and terminal will return parallels@ubuntu-linux-20-04-desktop:~/Desktop/text$ Demo Task 6 In -class exercise: forking a fan of processes #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if ((childpid = fork()) \u003c= 0) break; //child and error break out; parent continues fprintf(stdout, \"This is process %ld with parent %ld\\n, i = %d\",(long)getpid(), (long)getppid(), i); } Result the order can be different since the parent and child processes are running concurrently which is scheduled by scheduler the parent process of PID=187708 is PID=12244 (the bash process) the result above shows the parent process PID=187709 has terminated before the child process PID=187710 are created, so this child processes become orphan process, with parent process PID=1193 (the init process - user) The fork system call creates a copy of the calling process. However, many ap","date":"2023-09-04","objectID":"/posts/sp/l/:5:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.11 Process termination Upon termination of a process, the OS de-allocates the resources held by the process, updates the appropriate statistics, and notifies other processes, specifically these include: cancel pending timers and signals; release virtual memory spaces; release locks, closing open files; notifying the parent in response to a wait system call. What happens if the parent is not currently executing a wait()? The child process’s kernel management meta info (e.g. task struct) will remain there, though the child process image is gone. The child process hence becomes a zombie. A normal termination occurs if there was A return from main, An implicit return from main, A call to the C function exit, or A call to the _exit system call exit calls user-defined exit handlers and may provide additional cleanup before it invokes the _exit system call. exit takes a single, integer argument, called exit status, which will be made available to the parent process (which may be waiting). By convention, a zero means success, some non-zero value means something has gone wrong. 2.11.1 Abnormal process termination A process can terminate abnormally by calling abort, causing the SIGABRT signal to be sent to the calling process, or processing a signal that causes termination. A code dump may be produced. User-installed exit handlers will not be called upon abnormal termination. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.12 Background processes Recall that the shell is a command interpreter which Prompts for commands. Reads the commands from standard input, forks children to execute the commands, and waits for the children to finish. A user can terminate execution of a command by ctrl-c. Most shells interpret a command line ending with \u0026 as one that should be executed by a background process When a shell creates a background process, it does not wait for the process to complete before issuing a prompt and accepting additional commands. Cannot send ctrl-c to a background process via the command input. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:11","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.13 Daemons A daemon is a background process that normally runs indefinitely (have an infinite loop). Unix relies on many daemon processes to perform routine tasks pageout daemon handling paging, in.rlogind handling remote login requests, The web server daemon receiving http connection requests ftp daemon, mail daemon, … etc. Demo Task 11 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003csyslog.h\u003e #include \u003cstring.h\u003e #define MAX_I 100 void main (void){ pid_t pid, sid; FILE* p_output; int i = 0; pid = fork(); if (pid \u003c 0) exit(EXIT_FAILURE); if (pid \u003e 0) exit(EXIT_SUCCESS); umask(0); sid = setsid(); // create the daemon process if (sid \u003c 0) exit(EXIT_FAILURE); if ((chdir(\".\")) \u003c 0) // change the directory to the current directory exit(EXIT_FAILURE); printf(\"Daemon: Hello!\\n\"); // the child session will inherit the stdout from the parent, so it will still print out on the current terminal(\"parent\" session) close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); printf(\"Daemon: Goodbye!\\n\"); // `STDIN/OUT` are closed, the child session cannot access parent I/O, so it will not print out in current terminal while(1){ if ((p_output = fopen( “daemon_output.txt”, “a”)) != NULL){ fprintf(p_output, “%d\\n”, i++); i %= MAX_I; fclose(p_output); } sleep(3); } exit(EXIT_SUCCESS); } umask umask(0): set the file mode creation mask(umask) to 0, so that the file mode of the daemon output file is not restricted. umask() sets the calling process’s file mode creation mask to mask \u0026 0777, 7 means 111 in binary open() and mkdir() mkdir(): the mode of the created directory is (mode \u0026 ~umask \u0026 0777) mode is default mode e.g. umask(0) -\u003e mkdir() -\u003e 0777 \u0026 ~0 \u0026 0777 -\u003e 0777: the deafult mode will be remained setsid although setsid will move to another session, but the opened file is still be accessed the child process calls setsid() to create a new session and obtain a new session ID (SID). If setsid() fails (returns -1), the program exits with a failure status. The child process then changes the current working directory to the root directory using chdir(\".\"). If the chdir() call fails, the program exits with a failure status. child process closes the standard input, standard output, and standard error file descriptors. This is done to disconnect the daemon process from the terminal, as it no longer needs them. above code is a daemon process, which is terminal-realted not login-related. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:12","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3 Unix File System What is a file in Unix? How many types of files? How are the files in a file system structured? How is a file represented in memory and disk? How to find the file using its name? How to access files from a Unix program? ","date":"2023-09-04","objectID":"/posts/sp/l/:6:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.1 Unix File System File system provides abstractions of naming, storage, and access of files. A file is a container of some information: data, program. In Unix, devices (disks, tapes, CD ROMs, screens, keyboards, printers, mice, etc.) are also treated as files, so as to provide a unified and device independent interface to applications. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.2 How to handel devices? system calls to the programmer for performing control and I/O to devices. handled by device drivers, which hide the details of device operation and protect the devices from unauthorized use. In Unix, disk files and other devices are named and accessed in the same way as data files. Unix provides a uniform device interface (called file descriptors). Allow uniform access to most devices through file system calls – open,close, read, write, etc. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.3 Types of files in Unix Regular file: an ordinary data file on disk – contains bytes of data organized into a linear array; Special file: a file representing a device – located in the /dev directory Block special file: devices transferring info in blocks or chunks, just like disks, CD ROM Character special file: devices transferring info in stream of bytes that must be accessed sequentially, just like keyboards, mice, printers, etc. Directories: provided to allow names (not physical locations) of files to be used. User gives a file name and Unix makes a translation to the location of the physical file-done via directories ","date":"2023-09-04","objectID":"/posts/sp/l/:6:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.4 Difference between regular and directory file Contents: data vs file info Operations: what can be done and who can do them, the access right ","date":"2023-09-04","objectID":"/posts/sp/l/:6:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.5 ls -l command For each file there are ten characters before the user and group owner. The first character shows the types of file access right Demo Task 1 What are the differences between a regular file and a device file? \u003ecp /etc/passwd /tmp/garbage \u003ecp /etc/passwd /dev/tty // \u003e cp normal.txt /dev/tty Hello world! content will be displayed on the terminal for tty device file ","date":"2023-09-04","objectID":"/posts/sp/l/:6:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.6 Hierarchical file organization A Unix file system has a hierarchical tree structure where internal nodes are directories and leaf nodes are files fully-quallified path name uniquely specifies a file: /dirA/dirB/My1.dat. relative pathname, begining from the current directory rather the root ditrectory: ../My2.dat ","date":"2023-09-04","objectID":"/posts/sp/l/:6:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.7 Current working directory At anytime, every process has an associated directory called the current working directory (cwd) Denoted by a dot ., e.g., mv ../file1 . The cwd associated with a user’s login shell is called the user’s home directory. pwd prints the name of cwd A relative pathname always starts with the path to the cwd. The C library function getcwd returns the pathname of the current working directory char *getcwd(char *buf, size_t size) size specifies maximum length pathname. If longer than the maximum, returns NULL and sets errono to ERANGE. #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cerrno.h\u003e int main(){ char cwd[1024]; if (getcwd(cwd, sizeof(cwd)) != NULL) printf(\"Current working dir: %s\\n\", cwd); else perror(\"getcwd() error\"); return 0; } ","date":"2023-09-04","objectID":"/posts/sp/l/:6:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.8 File representation 3.8.1 i-node Information about a filesystem structure is stored both on disk and main memory. Unix uses a logical structure called i-node to store the information about a file on disk – each file in a file system is represented by an i-node: i-nodes are stored at the front of each region of disk that contains a Unix file system. both conceptual and physical A regular file has a number called the i-number, which is an index into an array of the i-nodes on disk, one-to-one mapping. Each i-node corresponds to a unique i-number (index). data blocks may be placed in neighboring disk blocks, but it can not be guaranteed. more layers(tree structures) to access the data blocks store pointers in data blocks find the i-number of a file, by given the file name A directory contains a list of entries mapping file names to i-numbers (hence the i-node). A \u003cname, i-node\u003e pair is called a link. You can create many links for a file (multiple names). i-nodes are the hidden part, while directories are the visible structure of the Unix file system. Hence, the correspondence between a file name and its i-node is stored in the directory file. [Example of directory file] 3.8.2 Hard link \u0026 Symbolic link [Example of directory file: hard link] Hard link creation command: ln My1.dat My2.dat Hard link create a new entry for the same i-node, when modifying any of entry, the result will change [Example of directory file: symbolic link] create a new i-ndoe index Symbolic link normal symbolic link: when the “root” is moved, the link will be broken absolute symbolic link: when the “root” is moved, the link will not be broken i-node reference a new data block which stores a URL, of which the reference of source file absulute path or relative path Hard links must be on the same file system, while symbolic links can cross file systems. Hard linked files stay linked even if either one is moved; Symbolic linked files break if the original is moved. Remove links deep remove and shallow remove deep - remove the entire file from disk shallow - remove the reference not the file itself reference counter(part of i-node in filr info.) from the memory perspective to check using deep remove or shallow remove The key of links is checking whether the reference/path is valid or not. 3.8.4 File storage 12 direct pointer can point to $12 * 8KB = 96KB$ of file content. A single indirect pointer points to a block of direct pointers. A block can contain 8KB/4bytes = 2K pointers = 2048 pointers. 2048 direct pointers can point to $2048 x 8KB = 16MB$ of file content. A double indirect pointer points to 2048 single indirect pointers, that is $2048 * 16MB = 32GB$ of file content. Similarly, a triple indirect pointer points to $64TB$ of file content. So one I-node can at the most point to $64TB + 32GB + 16MB + 96KB$ of file content. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.9 File Access In C programs, a file is represented by a file pointer or file descriptors. provide logical names (handles) for performing device-independent I/O. Unix file system calls use file descriptors (via open, read, write, close, and ioctl). ANSI C I/O library uses file pointers (via fopen, fscanf, fprintf, fread, fwrite, fclose, etc.). File descriptors - (in unistd.h) standard input: STDIN_FILENO standard output: STDOUT_FILENO standard error files: STDERR_FILENO Corresponding to constants 0, 1, 2 in \u003cunistd.h\u003e file pointers - (in stdio.h) standard input: stdin standard onput: stdout standard error files: stderr 3.9.1 File Descriptor low-level identifiers provided by the operating system to access files and I/O resources Process specialized System File Table(SFT) entry contains information about whether a file(within a process) is opened for read/write; permission; lock; read/write offset etc. Several entries in SFT may point to the same physical file. When new files are opened, it is assigned the lowest available FD. Accessing files for I/O is a three-step process, whether it is a regular file or a device: Open the file for I/O Read and write to the file Close the file when finished with I/O open a file int open(const char* pathname, int flags) int open(const char* pathname, int flags, mode_t mode) pathname: absolute or relative path name of the file to be opened flags: access mode - O_RDONLY, O_WRONLY, O_RDWR and bitwise-or’d(using |) with sero or more of the following flags: O_APPEND: the file is opened in append mode. O_CREAT: if the pathname does not exist, create the file as a regular file; must add the access permission mode parameter (e.g. 0644). … Return of open Returns the opened file’s file descriptor or –1 if an error occurred (the errno is set accordingly) read a file bytes = read(fd, buffer, count) Read from file associated with fd; place count bytes into buffer fd: file descriptor to reasd from buffer: pointer to any array count: number of bytes to read Returns number of bytes read or -1 if an error occured Demo Task 3 int fd = open(\"someFile\", O_RDONLY); char buffer[4]; // store in stack, no need to de-allocate char * buff2 = malloc(4*sizeof(char)); // store in heap, need to de-allocate int bytes = read(fd, buffer, 4*sizeof(char)); free(buff2); // de-allocate the memory or there will be memory leak write a file - overwrite bytes = write(fd, buffer, count) Write contents of buffer to the file associated with fd, write count bytes into the file O_TRUNC: if the file already exists and is a regular file and the access mode allows writing, truncate it to length 0. fd: file descriptor to write to buffer: pointer to any array count: number of bytes to write Returns number of bytes written or -1 if an error occured Demo Task 4 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void main(){ char buff4[4] = {'a','b','c',0} int i = 0; int bytes_written = 0; int fd; fd = open(\"someFile\", O_WRONLY|O_CREAT, 0644); printf(\"sizeof(buffer) is %d\\n\", sizeof(buffer)); // char buffer[4]; bytes_written = write(fd, buffer, 4*sizeof(char)); for (i = 0; i \u003c 4; i++) { printf(\"The %dth byte is %c\\n\", i, buffer[i]); } fsync(fd); // flashes the content into disk before close (for written) close(fd); // when open, close it } close a file return_val = close(fd) Close an open file descriptor Returns 0 if successful, -1 if an error occured 3.9.2 File Pointer higher-level abstractions used by programming languages or libraries to manage the current position and perform high-level file operations. A file pointer points to a data structure FILE, called a file structure in the user area of the process. A file structure contains a buffer and a file descriptor (so a file pointer is a handle to a handle) Demo Task 5 #include \u003cstdio.h\u003e FILE *myfp; if ((myfp = fopen(\"/home/ann/my.dat\", \"w\")) == NULL) fprintf(stderr, \"Could not fopen file\\n\"); else fprintf(myfp, \"This is a test\"); overwrite #include \u003cstdio.h\u003e void mai","date":"2023-09-04","objectID":"/posts/sp/l/:6:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.10 I/O Redirection process modifies its file descriptor table entry so that it points to a different entry in the system file table. Recall: to access a file, a process uses a file descriptor, which is an index into the process file descriptor table, which in turn points to an entry in the system file table. cat: reads a file and outputs to stdout. cat test \u003e my.file 3.10.1 I/O redirection realization using Table dup() int dup(int oldfd) duplicates the given file descriptor to the lowest numbered unused file descriptor in the file descriptor table. Demo Task 8 #include\u003cstdio.h\u003e #include\u003cfcntl.h\u003e #include\u003cunistd.h\u003e char* cmd[] = {\"/bin/ls\", \"-l\", 0}; int main(int argc, char* argv[]){ int fd = open(argv[1], O_WRONLY | O_CREAT, 0600); //fd will be 3; a file will be opened in write mode int fd2 = dup(fd); //duplicate the fd-th pointer to entry 4, the lowest available entry close(STDOUT_FILENO); // the entry 1 is now available(free) dup(fd); //duplicate the fd-th pointer into entry 1, \"my.dat\" become the standard output file execvp(cmd[0], cmd); // the old process image is replaced by the new process image for ls // the File Descriptor Table is \"inherited\" by the new process image, // still the same process(PID), but the image is replaced close(fd); //close file descriptor 3 in the parent process. return; } 3.10.2 Communication between parent/child via pipe System call pipe() returns two file descriptors by whilch we can access the input/outpur of a pipe(and I/O mechanism) int fd[2]; int pipe(int fd[2]); Return: 0 success; -1 error Demo Task 9 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstring.h\u003e int main(){ int fd[2]; pipe(fd); //fd[0] is for read and fd[1] is for write pid_t child = fork(); char* data = \"hello world\"; if (child == 0){ //child process close(fd[1]); char buf[100]; //a large enough buffer to share data int bytes_to_read = strlen(data)+1; while (bytes_to_read \u003e 0) { int count = read(fd[0], buf, sizeof(data)); bytes_to_read -= count; } printf(\"child process read: \\\"%s\\\" .\\n\", buf); } else { //parent process close(fd[0]); int bytes_to_write = strlen(data)+1; while (bytes_to_write \u003e 0) { int count = write(fd[1], data, strlen(data)+1) // \"+1\" for null byte, terminateing 0 bytes_to_write -= count; } fsync(fd[1]); //flush the data into pipe before close printf(\"parent process written: \\\"%s\\\" .\\n\", data); close(fd[1]); } return 0; } ","date":"2023-09-04","objectID":"/posts/sp/l/:6:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4 Device Driver What is a device driver? Related OS infrastructure Devices and files Major design issues Types of device drivers ","date":"2023-09-04","objectID":"/posts/sp/l/:7:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.1 What is a device driver? Device driver is a special kind of library, which can be loaded into the OS kernel, and links application program with the I/O devices ","date":"2023-09-04","objectID":"/posts/sp/l/:7:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.2 Related OS infrastructure Unix system architecture File subsystem and its relations with char/block device driver tables Char/block device driver tables Most of device derivers are character device drivers, like printer; block device driver operats on massive file system, like disk, CD-ROM, etc. Advantages to separate device drivers from the OS For OS designer Devices may not be available when an OS is designed. no need to worry about how to operate devices (set up registers, check statuses, …). Focus on OS itself by providing a generic interface for device driver development. For Device driver designers Do not need to worry about how I/O is managed in OS (how to design kernel data structures to efficiently operate devices, …) Focus on implementing functions of devices with device-related commands following the generic I/O interface ","date":"2023-09-04","objectID":"/posts/sp/l/:7:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.3 Device and Files devices are treated as special files. A file is associated with an inode. We can use mknod \u003cfile_name\u003e \u003cc or b\u003e \u003cmajor_number\u003e \u003cminor_number\u003e to create a special filr for a device file When we create a special file (an inode) for a device file, we associate major/minor numbers with the file (the inode). Major number associated with a special file is used to identify its corresponding device drivers in the kernel. 4.3.1 Character/Block Device Files Two types of device files: character and block [Example] ls -l /dev/null crw-rw-rw-r 1 root root 1 3 June 1, 1970 null character device file major number 1, minor number 3 ls -l /dev/bon br--r--r-- 1 root root 97 0 June 1, 1970 0 bolck device file major number 97, minor number 0 ","date":"2023-09-04","objectID":"/posts/sp/l/:7:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.4 Major Design Issues OS/Device Driver Communication Device Driver/Hardware Communication Device Driver Operations Interpret commands received from OS Schedule multiple requests for services Manage data transfer across both interfaces Accept \u0026 process hardware interrupts Maintain the integrity of the device’s and kernel’s data structures ","date":"2023-09-04","objectID":"/posts/sp/l/:7:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.5 Types of Device Drivers Differences in the way that device drivers communicate with Linux Block Character Network 4.5.1 Block Device Driver Communicate with the OS through a collection of fixed size buffers OS manages a buffer cache; satisfy user requests for data by accessing buffers in the cache. Driver is invoked when requested data is NOT in the cache; when buffers in the cache have been changed and must be written out (write back to the devices). By using buffer cache, block drivers are insuxlated from the many details of user requests; only need to handle requests from the OS to fill or empty fixed size buffers. Many support devices contain file system 4.5.2 Character Device Driver handle I/O requests of arbitrary size; support almost any type of devices. Handel data a byte at a time(keyboard); or work best with data in chunks smaller or larger than the standard fixed size buffer used by device driver (e.g. ADC) [Communication structure] Difference between block \u0026 character deivers Block driver – only interacts with buffer cache Character driver – directly interacts with user requests from user processes I/O requests are directly passed (essentially unchanged) to the drivers from the user processes Character driver is responsible for transferring data directly to/from the kernel memory space and the user memory space. 4.5.3 General Programming Considerations Device drivers are parts of the kernel and not normal user processes, which means we can only use the kernel routines in device driver programs, particularly C library functions or system calls for user level cannot be used. Some kernel routines may have the same names as C library functions, but they are of totally different implementations. Make frugal use of stack (local arrays \u0026 recursive function calls), as the stack space in the kernel is limited and not expandable. Be aware of floating-point arithmetic: may cause incorrect results Be aware of busy wait: may lock up the whole system ","date":"2023-09-04","objectID":"/posts/sp/l/:7:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Summary A device driver is a computer program that glues OS and its I/O devices together. A device is treated as a special file in Unix. There are three types of device drivers in Linux based on the different communication manner between device drivers and OS: block, character, and network. ","date":"2023-09-04","objectID":"/posts/sp/l/:7:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5 Character Device Driver Development two generic interfaces are related to character device driver development User programs: devices are treated as special files and users can only access devices through file operation system call (such as open, close, read, write, etc.), just like accessing regular files. Kernel: provides a generic interface and kernel routines for all device drivers to implement functionalities and register functions into the kernel data structures (such as char/block device driver tables). ","date":"2023-09-04","objectID":"/posts/sp/l/:8:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.1 The Interface for User Programs Device are treated as files: user programs access devices through file operation system calls. Each file has an inode, and each device driver has a major number. When using a device driver in user programs, we need to create a special file by associate its major number (driver) with an inode, e.g. mknod /dev/lab1 c 251 0 ","date":"2023-09-04","objectID":"/posts/sp/l/:8:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.2 Device Driver Development Two Tasks: Implement functionalities based on the generic interface Register the device driver into the kernel data structure (the char/block device driver table) The major number is the ID of a device driver ","date":"2023-09-04","objectID":"/posts/sp/l/:8:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.3 The Generic Interface for Char Device Driver in Linux Data structure called file_operations is defined in \u003clinux/fs.h\u003e . It is basically an array of function pointers. struct file_operations{ struct module * owner; … int (*open)(struct inode *, struct file *); ssize_t (*read)(struct file *, char *, size_t, loff_t *); ssize_t (*write)(struct file *, const char *, size_t, loff_t *); int (*release)(struct inode *, struct file *); … } To develop a char driver, we need to implement the corresponding functions for a device based on the above generic interface. ","date":"2023-09-04","objectID":"/posts/sp/l/:8:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Demo task 1 // Header files include the prototypes of kernel routines and data structures needed in the program #include \u003clinux/config.h\u003e #include \u003clinux/module.h\u003e #include \u003clinux/kernel.h\u003e #include \u003clinux/init.h\u003e #include \u003clinux/fs.h\u003e #include \u003clinux/string.h\u003e #include \u003casm/uaccess.h\u003e #define DEVICE_NAME \"comp309_char_lab1\" static char msg[] = \"Hello World!!!\\n\" static int major; // Use \"static\", the effective range of a variable is limited in the file containing it, so we can avoid name pollution. static int zili_demo_char1_open(struct inode *inode, struct file *fp){ MOD_INC_USE_COUNT; printk(\"Device \" DEVICE_NAME \" open.\\n\"); return 0; } static ssize_t zili_demo_char1_read(struct file *fp, char *buf, size_t count, loff_t *position){ int num; if (count \u003c strlen(msg)) num = count; else num = strlen(msg); copy_to_user(buf, msg, num); return num; } static int zili_demo_char1_release(struct inode *inode, struct file*fp){ MOD_DEC_USE_COUNT; printk(\"Device \" DEVICE_NAME \" release.\\n\"); return 0; } #include \u003clinux/module.h\u003e // no need to write \"include/linux/module.h\" #define N_D 10 // at most 10 devices #define S_N 1 // minor# from 1 static dev_t devno // call when module is load into the kernel int __init helloworld_init(void) { } // call when module is unload from the kernel void __exit helloworld_exit(void) { } module_init(helloworld_init); module_exit(helloworld_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"YE Haowen\"); MODULE_DESCRIPTION(\"Char Device Driver for helloworld!\"); ","date":"2023-09-04","objectID":"/posts/sp/l/:8:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.4 Kernel Memory Space and User Memory Space The kernel virtual memory address space and user virtual memory address space are separate in Unix. The resources that only kernel can access are also called the “kernel land”, while the resources that the user can access are also called the “user land”. declaration: not only declare, but memory allocation definition: not only define, but implementation ","date":"2023-09-04","objectID":"/posts/sp/l/:8:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6 Complier Design Overview of Compiler Construction Syntax and semantics of programming languages; language translation approaches; tasks of a compiler; the compiler process. Lexical Analysis: Tasks of lexical analysis; specifying tokens by regular grammars and regular expressions; recognizing tokens by Finite Automata (FA); construction of FA from regular expressions; converting NFA to DFA; simulating DFA. Syntax Analysis: Tasks of syntax analysis; specifying language constructs by context-free grammars; BNF; derivation; parse and syntax trees; recognizing language constructs by Pushdown Automata; top-down and bottom-up parsing methods. Code Generation: Intermediate compilation phases; symbol table; intermediate code generation; code optimisation; code generation. ","date":"2023-09-04","objectID":"/posts/sp/l/:9:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.1 Complier Overview Complier: A well-established discipline Programming languages: high-level vs. low-level Complier Phases of a complier Programming Languages: Machine Language Everything is a binary number: operation, data, address In MIPS 2000: 0010 0100 1010 0110 0000 0000 0000 0100 means $t5 + 4 -\u003e $6 Programming Languages: Assembly Language Symbolic representation/mnemonics of machine language add $t6, $t5, 4 Benefit of High-level Language human readable Hide unnecessary details, so have a higher level of abstraction, increased productivity Make programs more robust: information is specified before its use, enabling subsequent error checking at compile time Make programs portable: the same program can be compiled on different machines ","date":"2023-09-04","objectID":"/posts/sp/l/:9:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.2 Translation Mechanism Development time translation: Compilation Translate source programs in one language into executable programs C, C++ Runtime translation: Inerpretation Read source programs, understand and produce execution results in the meantime line by line Perl, Shell commands Hybrid: Compilation + Interpretation Java, complied into byte code, and then interpreted by JVM during runtime ","date":"2023-09-04","objectID":"/posts/sp/l/:9:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.3 Complier and Phases of a Compliation Definition A compiler is a software that takes a program written in one language (called the source language) and translates it into another (usually equivalent) program in another language (called the target language). Also reports errors (bugs) in the source program. [Phases of a Compliation] 6.3.1 Lexical Analysis Scan the source program and group sequences of characters into tokens. A token is the smallest element of a language A group of characters (e.g., a series of alphabetic characters form a keyword; a series of digits form a number). The sub-module of the compiler that performs lexical analysis is called a lexical analyzer. Example: position := initial + rate * 60 Read one by one 6.3.2 Syntax Analysis Once the tokens are identified, syntax analysis groups sequences of tokens into language constructs. e.g., identifiers, numbers, and operators can be grouped into expressions. e.g., keywords, identifiers, expressions, and operators can be combined to form statements. The sub-module of the compiler that performs syntax analysis is called the parser/syntax analyzer. 6.3.3 Syntax(Parse) Tree Result of syntax analysis is recorded in a hierarchical structure called a syntax tree. Each node represents an operation and its children represent the arguments of the operation. Evaluation begins from bottom and moves up. E.g., parse tree for position := initial + rate * 60 6.3.4 Semantic Analysis Put semantic meaning into the syntax tree: syntax analysis recognizes grammatical events; semantic analysis processes such events, e.g., type checking, or triggering corresponding intermediate code generation 6.3.5 Intermediate Code Generation Generate IR (Intermediate Representation) code: Easier to generate machine code from IR code. 6.3.6 Code Optimization Modify program representation so that program can run faster, use less memory, power, etc. 6.3.7 Code Generation Generate the target program 6.3.8 Distinction between Phases and Passes Passes: the times going through a program representation. 1-pass, 2-pass, multiple-pass compliation Language become more complex – more passes Phases: conceptual stages, or modules of the compiler Not completely separate: Semantic phase may do things that syntax should do ","date":"2023-09-04","objectID":"/posts/sp/l/:9:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.4 Lexical Analysis(I) Why we need lexical analysis? Its input and output. How to specify tokens: Regular Expression How to recognize tokens – two methods Regular Expression $\\to$ Lex (software tool) Regular Expression $\\to$ Finite Automata Why need Lexical Analysis? Group the character into meaningful words 6.4.1 Input and Output of Lexical Analysis In lexical analysis, a source program is read from left-to-right and grouped into tokens. A token is a sequence of characters with a collective meaning. Token A syntactic category In English: a noun, a verb, an adjective, … In a programming language: an identifier, an integer value, a keyword, a white space, … Tokens correspond to sets of strings with a collective meaning Identifier: strings of letters and digits, starting with a letter Integer value: a non-empty string of digits Keyword: else, if, where, … [Expression] [Mini Program] Reason for tokens Classify program substrings according to their syntactic role. As the output of lexical analysis, tokens are the input to the parser (syntax analysis) Parser relies on token distinctions Different tokens are treated differently by the parser(keyword vs. identifier) Recognize tokens First, specify tokens using regular expressions (patterns) Second, based on regular expression, two ways to implement a lexical analyzer: Method 1: use Lex, a software tool Method 2: use finite automata (write your own program) ","date":"2023-09-04","objectID":"/posts/sp/l/:9:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.5 Lexical Analysis(II) Part II: Regular Expression 6.5.1 Regular Expression Specify tokens A token is specified by a pattern: a set of rules that describe the formation of the token The lexical analyzer uses the pattern to identify the lexeme: a sequence of characters in the input that matches the pattern. Once matched, the corresponding token is recognized. For example: The rule (pattern) for identifier: letter followed by letters and digits abc1 and A1By match the rule (pattern), hence they are identifier tokens; 1A does not match the rule (pattern), hence it is not an identifier token. The rules for specifying token patterns are called regular expression. A regular set (regular language) is the set of strings generated by a regular expression over an alphabet. 6.5.2 Alphabet and Strings An alphabet (usually denoted as $\\sum$) is a finite set of symbols. E.g. ${0,1}$ is the binary digits alphabet; ${a,b,c}$ is the English letter alphabet. A string $s$ over an alphabet $\\sum$ is a finite sequence of symbols drawn from that alphabet. E.g. 01001 is the string over $\\sum_{\\text{bin_digits}}$ $= {0,1}$ wxyasd is the string over $\\sum_{\\text{lower_case_letters}}$ $= {a,b,…,z}$ $ε$ is the empty string (without any symbol) The length of a string $s$ is denoted as $|s|$. E.g. $|ε|$ = 0; $|101| = 3$; $|abcdef| = 6$. 6.5.3 Kleene Closure and Language The Kleene closure of alphabet Σ, denoted as Σ∗, is the set of all strings, including the empty string , over the alphabet Σ. E.g. given alphabet Σ = {0,1}, then Σ∗ = {ε,0,1,00,01,10,11,000,001,….} Any set of strings over an alphabet Σ, i.e. any subset of Σ∗, is called a language. E.g. the empty set ∅, { }, Σ, and Σ∗ are all languages; abc, Def, D, z is a language over Σ letters = a, b, … , z, A, B, … , Z . 6.5.4 Operations on languages Particularly union, concatenation, Kleene closure, and positive closure. Precedence Kleene closure $\\succ$ concatenation $\\succ$ union {1}|{2}{3}* Exponentiation (concatenating the same language) ≻ multiplication (concatenating different/same languages) ≻ addition (union) {1} + {2} $\\cdot$ {3}^2. Let $L={a,b,…,z,A,B,…,Z}$ and $D={0,1,2,…,9}$ 6.5.6 Reaular Expressions Let $\\sum = {a,b}$ 6.5.7 Identifiers in Pascal Pascal identifier: a string of letters and digits beginning with a letter. Regular definition [Unsigned Numbers in Pascal] [Notation Shorthands] 6.5.8 Implementation of Lexical Analyzer After regular expressions are obtained, we have two methods to implement a lexical analyzer: Use tools: lex (for C), flex (for C/C++), jlex (for Java) Specify tokens using regular expressions Tool generates source code for the lexical analysis Use regular expressions and finite automata Write code to express the recognition of tokens Table drivern Lex: a lexical analyzer generator Lex is a Unix software tool, automatically constructs a lexical analyzer. Input: a specification containing regular expressions written in the Lex language. Assumes that each token matches a regular expression. Need an action specification for each expression. Output: Produces a C program that can recognize the matching tokens and trigger the specified actions. Especially useful when coupled with a parser generator ","date":"2023-09-04","objectID":"/posts/sp/l/:9:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7 Lexical Analysis(III) - Finite Automata ","date":"2023-09-04","objectID":"/posts/sp/l/:10:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.1 NFA, DFA, and NFA $\\to$ DFA Conversion Recognizing Tokens Regular Expression à Specify tokens Finite Automaton à Recognize tokens A language recognizer: Input: string x $\\to_{\\test{Recognizer for L}}$ $\\to$ Ouputs “yes” if x $\\in$ L, “no” otherwise A recognizer for a language is a program that takes a string and answers “yes” if is a string of , and “no” otherwise. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.2 Nondeterministic Finite Automata (NFA) A Nondeterministic Finite Automaton (NFA) consists of 5 components (Σ,S,S_0,F,move). Σ is the input alphabet S is the set of states S_0 is the start state F $\\subset$ S is the set of accepting states move is the transition function that maps state-symbol pairs to sets of states. Transition Graphs ","date":"2023-09-04","objectID":"/posts/sp/l/:10:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.3 State Transition Table The transition function of an NFA can also be implemented by a transition table, where the entries of rows are states and columns, respectively. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.4 ε - Transition A nother kind of transition, where the automaton transits from one state to another state without reading any input. NFA based recognitions (decisions) are hard to implement Can have multiple transitions from one input in a given state Can have ε-transitions Easy to form from regular expressions Hard to implement the recognition (decision) algorithm ","date":"2023-09-04","objectID":"/posts/sp/l/:10:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.5 Deterministic Finite Automata A DFA is a special case of NFA: One transition per input per state No ε-transitions Examples of NFA and DFA Given alphabet NFA: Easy to generate strings. May go to anyone of several states given an input symbol. May go to another state when there is no input, due to -transition(s). DFA: Easy to both generate and recognize strings. Goes to only one deterministic state given an input symbol. Does not go anywhere when there is no input; does not have any ε-transition. Table Implementation of DFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.6 Algorithm: Simulating a DFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.7 Regular Expression to NFA [Break Regular Expression to NFA] NFA to DFA A DFA is a special case of NFA. The conversion of an NFA to a DFA needs to meet the two requirements on DFA: -closure(s): the set of all states reachable from on -transition (to meet the no ε-transition requirement of DFA). Regard all reachable states from one state on one input symbol as one state (to meet the one transition per input per state requirement of DFA). Conversion Algorithm States of DFA obtained from NFA An NFA may be in many states at any time. If there are states, the NFA must be in some subset of those states. Given a set of elements, it has $2^N$ subsets. The DFA can have at the most $2^N$ states, where is the number of states of the NFA. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.8 Regular Expression to NFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8 Syntax Analysis ","date":"2023-09-04","objectID":"/posts/sp/l/:11:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.1 Introduction Input: sequence of tokens from lexical analysiss Output: a parse tree (syntax tree) based on the gsrammar of a programming language. [Comparison between Lexical and Syntax] [Example] Syntax and Grammar In Pascal, program à blocks; block à statements; … var a,b,c; begin a = b+c; end The syntax of programming language constructs can be described by context-free grammar (CFG). ","date":"2023-09-04","objectID":"/posts/sp/l/:11:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.2 Context-Free Grammar $ G= (N,T,S,P)$ $N$ is a finite set of nonterminal symbols (simplified as “nonterminals”); $T$ is a finite set of terminal symbols (simplified as “terminals”); $S$ is the unique start nonterminal($S\\in N$); $P$ is a finite set of productions. Every production in $P$ is of the form $A \\to \\beta$, where $A \\in N$ and $\\beta \\in (N \\cup T)^*$. e.g., $N = {S}$, $T = {a,b}$, $S,P = {S \\to aSb|ab}$, where $S \\to aSb|ab$ denotes the language $L = {a^nb^n|n \\geq 0}$. Not Regular Expression Regular Expression, CFG, and Automata Language Classfication Regular Expression vs. CFG Every language that can be described by a regular expression can also be described by a CFG e.g., $(a|b)^*abb$ Derivations, Language of a CFG Based on a grammar for a language, we can generate sentences (strings consisting only of terminals) of the language. This is done by derivations. For CFG, derivation means start from the start nonterminal, repeatedly use productions to replace nonterminals, until a sentence is produced (i.e. all nonterminals are replaced). Grammar: $S \\to aSb|ab$ Derivation: $S \\Rightarrow aSb \\Rightarrow aaSbb \\Rightarrow aabbb$ where $\\Rightarrow$ means “derives in one step” A CFG language is the set of all the sentences that can be derived from the start symbol of the CFG grammar. The reverse is syntax analysis (parsing): given an input string of terminals, is there a derivation for the string based on the grammar (is the string a sentence of the grammar)? Parse Tree, Leftmost/Rightmost Derivation For CFG, a parse tree is a tree with the following properties The root is labeled by the start nonterminal; Each leaf node is labeled by a terminal or by ; An interior node is labeled by a nonterminal; If A is the nonterminal labeling some interior node, and $X_1X_2…X_n$ are the labels of the children of that node from left to right, then $A \\to X_1X_2…X_n$ is a production. A string of terminals is a sentence of a CFG grammar iff there is a (can have more) parse tree for this string. The derivation of the sentence can be shown pictorially by this parse tree. Suppose the parse tree of the sentence is found. Leftmost derivation: only the leftmost nonterminal is replaced at each derivation step. E.g., grammar: $E \\to E+E|E*E|(E)|id$ Leftmost derivation: $E \\Rightarrow -E \\Rightarrow -(E+E) \\Rightarrow -(id+E) \\Rightarrow -(id+id)$ Similarly, for rightmost derivation, the rightmost nonterminal is replaced at each step. ","date":"2023-09-04","objectID":"/posts/sp/l/:11:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.3 Parsing Methods 8.3.1 Bottom-Up Parsing Start at the leaves and build the parse tree from bottom up. Basic method: shift-reduce Shift symbols onto the stack; Reduce when handle is identified by left side. Used to implement automatic parser generator such as Yacc. Shift-reduce Parser Two data structures: A Stack to hold the grammar symbols; An Input buffer to hold the string to be parsed; Stack contains only $ symbol; Input buffer contains input string followed by $ symbol. Possible actions: Shift: move the next input symbol to the top of the stack; Reduce: replace the top of the stack with the appropriate non-terminal symbol ; Accept: parser reports the successsful completion of parsing; Error: parser is confused and is not able to make any decision. It can neither perform shift action nor reduce action nor accept action. Important rules: If the priority of incoming operator is more than the priority of in stack operator, then shift action is performed. If the priority of in stack operator is same or less than the priority of in stack operator, then reduce action is performed. 8.3.2 Top-Down Parsing Start at the root of the parse tree and try to get to leaves. Can be efficiently written by hand. Only work for certain class of grammars: Unambiguous No left recursion No left factoring Left recursion: A grammar is left-recursive if and only if there exists a nonterminal symbol that can derive to a sentential form with itself as the leftmost symbol. That is, $A \\Rightarrow^+ A\\alpha$, where $\\Rightarrow^+$ means the operation of making one or more substitutions, and is any sequence of terminal and nonterminal symbols. Left factoring: A grammar is left factoring if and only if there exists a nonterminal symbol $A$ that $A$ has $\\alpha \\beta_1 |\\alpha \\beta_2 $, where $\\alpha, \\beta$ are any sequence of terminal and nonterminal symbols, with $\\alpha \\neq e$ . Recursive Production Recursive Production: if the same non-terminal at both left and right hand side of production $$ S \\to aSb, S \\to aS, S \\to Sa $$ Recursive Grammar:if at least one recursive production is present $$ S \\to aS | a, S \\to Sa|as, S \\to aSb|ab $$ 8.3.3 Convert Left recursion into Right recursion If a CFG contains left recursion then the compiler may go to infinity loop, hence, to avoid the looping of the compiler, we need to convert the left recursive grammar into its equivalent right recursive production [Examples] Ambiguous Grammars Each parse tree has a unique leftmost/rightmost derivation. Sometimes a grammar may have (produce, imply) more than one parse tree for some of its sentences. Such a grammar is said to be ambiguous. For such a sentence (i.e., having more than one parse tree), its leftmost and rightmost derivations may be different. e.g., grammar: $E\\to E+E|E*E|id$, sntence id+id*id Grammar which is both left and right recursive is always ambiguous but ambiguous grammar need not be both left and right recursive [Example] 8.3.4 Non-deteministic Grammar The grammar with common prefix is known as non-deterministic grammar. $A\\to \\alpha\\beta_1, \\alpha\\beta_2$ Grammar with common prefixes requires a lot of Back-tracking, which is time consuming and inefficient. To avoid the back-tracking, we need to remove the common prefix from the grammar, like convert non-deterministic grammar into deterministic grammar. Normalization of CFG Chomsky Normal Form (CNF), if every production is in form: $A\\to BC|a$ ","date":"2023-09-04","objectID":"/posts/sp/l/:11:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.4 First and Follow Sets First First(S) is the set of all terminals that may begin the strings in the language generated by S. [Examples] Follow Follow(A) is the set of all terminals that may follow to the right of (A) in any form of sentential Grammar. Rules: if A is the start symbol then Follow(A) = {$} if $A \\to \\alpha A B, B \\to \\varepsilon$, Follow(A) = First(B) if $S \\to \\alpha A$ Follow(A) = Follow(S) $S \\to \\alpha A \\beta$, where $\\beta \\to \\varepsilon$, Follow(A) = First(B) U Follow(S) - {$\\varepsilon$} [Examples] 学习笔记，仅供参考 ","date":"2023-09-04","objectID":"/posts/sp/l/:11:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["个人博客相关"],"content":"这篇文章展示了基础的博客搭建","date":"2023-05-09","objectID":"/posts/serverfile/server-build/","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"Hugo个人博客搭建 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:0:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"1 快速开始 基于Mac系统 主要流程 安装相关环境 安装git 安装Homebrew 安装hugo 博客相关操作 新建自己的博客站点 设置主题 本地启动博客 构建网站 服务器部署(github) 将博客部署到github远端 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:1:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2 相关环境安装 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.1 安装git Git是一个版本控制工具，可以用来帮忙管理我们的博客，直接前往官网下载安装包即可 下载地址。 然后打开终端,即terminal, 输入以下命令，回车执行 # 检查是否安装成功 git --version 如果已经安装，则会显示安装的版本信息；若没有安装，则会提示安装，按照提示安装即可。 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.2 安装Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 同样可以通过，brew -v来检查是否已经安装或者是否安装成功 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.3 安装hugo brew install hugo # 检查是否安装成功 hugo version ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3 博客相关操作 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.1 新建自己的博客站点 首先新建一个网站，名字随便起，这里以 myblog 为例，[PATH] 为自己想要存放的路径，myblog 为网站名。 hugo new site [PATH]/myblog ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.2 设置主题 这里以LoveIt为例, 该主题仓库是：https://github.com/dillonzq/LoveIt 通常来说，我们将这个主题直接克隆clone到theme目录即可 # 先进入myblog目录下 cd [PATH]/myblog # 克隆操作 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.3 创建第一篇文章 hugo new posts/first_post.md ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.4 本地启动博客 hugo serve 去查看 http://localhost:1313. ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:4","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.4 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:5","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.5 将博客部署到github远端 首先在自己的GitHub赏创建一个新的仓库，名称必须为Github用户名.github.io，例如我的就是shanyu0205.github.io,用户名必须全小写. 创建成功后，将自己的博客文件夹下的public文件夹下的所有文件复制到Github用户名.github.io仓库下，然后提交到远端即可。 所有git命令都应在public文件夹下执行，应为public文件夹下才是真正的博客文件，其他的都是配置文件 cd public # 进入public文件夹 git init git add . # 注意后面有个点 git commit -m \"我的第一个hugo博客\" # 注意为英文双引号 git remote add origin \"https://github.com/\"你的库的地址\"\" # 与远端的git仓库进行关联 git push # 如果是第一次提交，需要加上-u参数: git push -u origin master 注意：由于Github修改了关于公钥的条例，所以在push的时候,可能会出现Permission denied的错误 所以需要在push之前,先在Github的Settings的Developer settings里,找到Personal access token,并选择token(classic)，然后点击Generate new token，然后在弹出的页面中，勾选repo，然后点击Generate token，然后将生成的token复制下来输入终端. 详情请见：https://blog.csdn.net/qq_43382853/article/details/119221234 接下来就可以通过[].github.io直接访问自己的博客了。[]中填写自己的github用户名 此时，如果你的博客还没有显示出来，那么就需要等待一段时间，因为github需要一段时间来构建你的博客，一般来说，等待时间不会超过10分钟。 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:6","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"参考链接： Hugo官网 雨临Lewis的博客 b站CodeSheep: BV1q4411i7gL 感谢你的支持 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:4:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Disk Storage Devices Data stored as magnetized areas on magnetic disk surfaces. A disk pack contains several magnetic disks connected to a rotating spindle. Disks are divided into concentric circular tracks on each disk surface. Track capacities vary typically from 4 to 50 Kbytes. A track is divided into blocks (In some systems, there is an intermediate unit called sectors). The block size B is fixed for each system. Typical block sizes range from B=512 bytes to B=4096 bytes. Whole blocks are transferred between disk and main memory for processing. A read-write head moves to the track that contains the block to be transferred. Disk rotation moves the block under the read-write head for reading or writing A physical disk block address consists of a surface number, track number (within surface), and block number (within track) Reading or writing a disk block is time consuming because of the seek time $s$ and rotational delay (latency) $rd$ Double buffering can be used to speed up the transfer of contiguous disk blocks 2.1 File of Records A file is sequence of records, where each record is a collection of data values or items. A file descriptotr or header includes information that describes the file, such as the field names and their data tpyes, and the addressseds of the file blocks on the disk. Records are stored on disk blocks. The blocking factor bfr for a file is the (average) number of file records stored in a disk block. A file can have fixed-length records or variable-length records. File records can be unspanned: no record can span two blocks spanned: a record can be stored in more than one block In a file of fixed-length records, all records have the same format. Usually, unspanned blocking is used with such files. Files of variable-length records require additional information to be stored in each record. Usually spanned blocking is used with such files. The records of a file can be contiguous, linked, or indexed. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:0:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.2 Operation on Files ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:1:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.3 Unordered Files \u0026 ordered Files Unordered Files: also called pile file New records are insterted at the end of the file Linear search through the file is necessary, which requires reading and searching half the file blocks on the average. QUITE EXPENSIVE. Insertion is quite efficient Reading the records in order of a particular field requires sorting the file records. 9 16 50 2 10 4 8 12 60 100 Ordered Files: also called sequential file File records are kept sorted by the values of an ordering field. Insertion is expensive: records must be inserted in the correct position. It is common to keep a separate unordered overflow file for new records to improve insertion efficiency; this is periodically merged with the main ordered file A binary search can be used to search for a record on its ordering field value. This requires reading and searching ${log_2}^{n}$ of the file blocks on the average. Reading the records according to the order of the ordering field is quite efficient. 2 4 6 14 18 50 100 5000 9000 100000 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:2:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.4 Hashed Files Hashing for disk files is called External Hashing Collisions occur when a new record hashes to a bucket that is already full an overflow file is kept for storing such records; overflow records that hash to each bucket can be linked together. [Resolution] Open addressing: Proceeding from the occupied position specified by the hash address, the program checks the subsequent positions in order until an unused (empty) position is found. Linear Prob: If collide, try Bucket_id+1, Bucket_id+2, … Quadratic Prob: If collide, try Bucket_id+1, Bucket_id+4,…(try to not affect the close neighbors like linear probing) Main disadvantagesof static external hashing: Fixed number of buckets M is a problem when the number of records in the file grows or shrinks. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:3:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.5 Dynamic and Extendible Hashing Techniques Both dynamic and extendible hashing use the binary representation of the hash value h(K) in order to access a directory. In dynamic hashing the directory is a binary tree. In extendible hashing the directory is an array of size $2^d$ where d is called the global depth. The directories can be stored on disk, and they expand or shrink dynamically. An insertion in a bucket that is full causes the bucket to split into two buckets and the records are redistributed among the two buckets. Dynamic and extendible hashing do not require an overflow area. 3 Types of Single-level Indexes One form of an index: a file of entries \u003cfield value, ptr to record\u003e, which is ordered by field value The index is called an access path on the field ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:4:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.1 Primary Indexes Defined on an ordered data file The data file is ordered on a key field Includes one index entry for each block in the data file; the index entry has the key field value for the first record in the block, which is called the block anchor A similar scheme can use the last record in a block ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:5:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.2 Clustering Indexes Defined on an ordered data file The data file is ordered on a non-key field Includes one index entry for each distinct value of the field; the index entry points to the first data block that contains records with that field value ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:6:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.3 Secondary Indexes A secondary index provides a secondary means of accessing a file for which some primary access already exists The secondary index may be on a candidate key field or a non-key field There can be many secondary indexes for the same data file. The index is an ordered file with two fields. The first field is of the same data type as some non-ordering field (ie.,the indexing field) of the data file. The second field is either a block pointer or a record pointer If we include one entry for each record in the data file, then it is called a dense index ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:7:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.4 Multi-level Indexes Because a single-level index is an ordered file, we can create a primary index to the index itself ; in this case, the original index file is called the first-level index and the index to the index is called the second-level index 4 B-Trees and B+-Trees as Dynamic Multi-level Indexes In B Tree and B+ Tree data structures, each node corresponds to a disk block Each node is kept between half-full and completely full [An insertion into a node that is not full is quite efficient; if a node is full the insertion causes a split into two nodes] [If a deletion causes a node to become less than half full, it must be merged with neighboring nodes] In a B tree, pointers to data records exist at all levels of the tree In a B+ tree, all pointers to data records exists at the leaf-level nodes Internal pointer must point to a block A search tree of order $p$ is a tree such that each node contains at most $p−1$ search values and $p$ pointers Each internal node has at most $p$ tree pointers, $p-1$ value(s). Each internal node, except the root, has at least $⎡(p/2)⎤$ tree pointers, $⎡(p/2)⎤-1$ value(s). The root node has at least two tree pointers if it is an internal node. During the insertion, the node has to be splited when it is full. During the deletion, the node has to be merge when it is too small (number of value \u003c $⎡(p/2)⎤-1$). Normally, we choose the left leaf node of the same subtree to merge. (When there exists right or left leaf node within a same subtree, it should be different results.) 5 Physical Database Design Decisions 5.1 Physical Database Design Decisions Denormalization as a design decision for speeding up queries The goal of normalization is to separate the logically related attributes into tables to minimize redundancy and thereby avoid the update anomalies that cause an extra processing overheard to maintain consistency of the database. The goal of denormalizationis to improve the performance of frequently occurring queries and transactions. (Typically the designer adds to a table attributes that are needed for answering queries or producing reports so that a join with another table is avoided.) ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:8:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"5.2 Tuning Goal: To make application run faster To lower the response time of queries/transactions To improve the overall throughput of transactions Tuning Index Tuning Queries 学习笔记，仅供参考 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:9:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Integrity Constraints \u0026 Normal Forms 1 Key constraints Superkey of R: A set of attributes SK of R such that no two tuples in any valid relation instance r(R) will have the same value for SK. That is, for any distinct tuples t1 and t2 in r(R), t1[SK] \u003c\u003e t2[SK]. Candidate key of R: A “minimal” superkey; that is, a superkey K such that removal of any attribute from K results in a set of attributes that is not a superkey. Primary key of R: choice by the DB designer when there are more than one candidate key 2 Domain/Entity integrity constraints No “NULL” value for particular attributes Must be “UNIQUENESS” 3 Referential integrity constraints(Foreign key constraints) Two relation constraints (single relation above) To ensure that a value appears in one relation also appears in another relation. Implies “subset dependency” relationship between 2 sets of attributes in 2 tables Supplier relation is a foreign table of Shipment When to check integrity constraints? INSERT, DELETE, MODIFY the tuple 4 Functional Dependency FD is a particular kind of constraints Definition R is a relation schema, and $\\alpha \\subseteq R$, $\\beta \\subseteq R$, then $$\\alpha \\to \\beta$$ for all pairs of tuples tq and t2 in any legal relation instance r(R), we have $$t1[\\alpha]=t2[\\alpha]\\to t1[\\beta]=t2[\\beta]$$ As a result, FD can be used to identify and find primary key. ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:0:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"4.1 Inference Rules for FDs Given a set of FDs $F$, we can infer additional FDs that hold whenever the FDs in $F$: IR1 - Reflexive: If $Y$ is a subset of $X$, then $X\\to Y$ IR2 - Augmentation: If $X\\to Y$, then $XZ\\to YZ$, ($XZ$ stands for $X \\cup Z$) IR3 - Transitive: If $X\\to Y$ and $Y\\to X$, then $X\\to Z$ Closure of a set $F$ of FDs is the set $F^+$ of all FDs that can be inferred from $F$ Equivalence of two sets $F$ and $G$ of FDs Every FD in $F$ can be inferred from $G$ Every FD in $F$ can be inferred from $G$ Hence, $F$ and $G$ are equivalent if $F^+$ = $G^+$ 5 Relational Database Design ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:1:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.1 First Normal Form (1NF - 第一范式) A relation R is in 1NF if and only if all underlying domians cantain atomic(indivisible) value only atomic: an attribute can not be decomposed, like, address can be decomposed to province, city, road number, door number, etc. Problem Insert Anomalies Inability to represent certain information Eg, cannot enter “Supplier and City” info until Supplier supplies at least one part(P#) Delete Anomalies Deleting the “only tuple” for a supplier will destroy all the information about that supplier Update Anomalies “S# and City” could be redundantly represented for each P#, which may cause potential inconsistency when updating a tuple Solution(2NF) Replace original table by two sub-tables(Normalization) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:2:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.2 Second Normal Form (2NF - 第二范式) A relation R is in 2NF if amd only if it is in 1NF and every non-key attributes is fully dependent on any candidate/primary key(include that nonprime attribute is transitively dependent on the primary key) R(I,C,D,N) FD:{I-\u003eC, I-\u003eD, CD-\u003eN, IO-\u003eG} R is 2NF I is a candidate key C, D, N are fully (transitively) dependent on I, which can be treated as CD-\u003eN \u003c==\u003e I-\u003eN There is only one type of data stored a particular table, rather a combined-type data. Both relations are in 2NF in the above case. Solution(3NF) Replcae second table by two sub-tables SC(S#,City) CS(City,Status) Keep SP(S#,P#,Qty) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:3:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 Third Normal Form (3NF - 第三范式) A relation R is in 3NF if and only if it is in 2NF and every non-key attribute is non-transitively dependent on any candidate key. Some redundancy still exists Solution Replace original SSP by two sub-tables SS(S#,Sname) SP(S#,P#,Qty) [or,SP(Sname,P#,Qty)] ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:4:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 BCNF - BC范式 A relation R is in BCNF if and only if every determinant (left-hand side of an FD) is a candidate key. 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 参考 学习笔记，仅供参考 ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:5:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Relational Algebra ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:0:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1 SELECT σ and PROJECT π ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.1 SELECT SELECT operation (denoted by σ): Form of the operation: $σ_{c}(R)$ Selects the tuples (rows) from a relation R that satisfy a certain selection condition c. The condition c is an arbitrary Boolean expression on the attributes of R Resulting relation has the same attributes as R. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.2 PROJECT PROJECT operation (denoted by π): Form of the operation: $π_{L}(R)$ Keeps only certain attributes (columns) from a relation R specified in an attribute list L. Resulting relation has only those attributes of R specified in L(subtable of R). ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2 Select \u0026 Project Not allow any duplicated for a combined attribute value (e.g. $\\pi_{Sex,Salary}$ not allow the same combined attribute(Sex,salary), so the (F,25000) appears only once) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.1 Combined Select and Project Operation Several operations can be combined to form a relational algebra expression (query) EX: Retrieve the names and salaries of employees whon work in department 4 $π_{FNAME,LNAME,SALARY}(σ_{DNO=4}(EMPLOYEE))$ We also can specify explicitly: DEPT4_EMPS$\\leftarrow$$σ_{DNO=4}(EMPOYEE)$ R$\\leftarrow$ $π_{FNAME,LNAME,SALARY}$(DEPT4_EMPS) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.2 Rename ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1 Set Operation For $\\cap, \\cup, - $ The operand must have the same number of attributes The domain of corresponding attributes must be compatible(union compatibility) The resulting relation for $\\cap, \\cup, -$ has the same attribute names as the first relation R1 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1.1 CARTESIAN PRODUCT R(A1,A2,A3,…,B1,B2,B3,…)$\\leftarrow$R1(A1,A2,A3,…,Am) X R2(B1,B2,B3,…,Bm) If R1 has n1 tuples and R2 has n2 tuples, then R will have $n1*n2$ tuples. CARTESIAN PRODUCT is a meaningless operation on its own. It can combine related tuples from two relations if followed by the appropriate SELECT operation. The table EMP_DEPENDENTS has (3 x 7)21 tuples. To find the tuple which ESSN=SSN ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1 JOIN OPERATION ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.1 Equal Join and Theta Join Theta Join: Similar to a Cartesian Product followed by a Select. The condition c (often use θ) is called a join condition. Equal Join: The join condition c includes one or more equality conparisons involving arrtibutes from R1 and R2. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.2 Natural Join There shoule be some column have same attribute(s) Based on the same value of attributes, adding two table tigether directly Delet the column which has same attribute value 学习笔记，仅供参考 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Rational Data Model (record-based logical model) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:0:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.1 Basic structure Relations: Data stored as tables (called relations); each has a unique name A relation consists of rows (called tuples) and columns (called attributes) Attributes: An attribute has a “domain” Record: Each row/tuple in a relation is a record (an entity) Each attribute in a relation corresponds to a particular filed of a record DB Schema: relatively static, the whole structure DB instance: dynamic, data \u0026 structure ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:1:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.2 Key Candidate and primary keys are also defined by relational data model Super keys are similar to candidate/primary keys, but are not required to be minimal. (可以有其他属性) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:2:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.3 Characteristic of Relations Ordering of tuples in a relation r(R): The tuples are not considered to be ordered, even though they appear in order in the table form. Ordering of attributes in a relation schema R (and of values within each tuple): We will consider the attributes in R(A1, A2, …, An) and the values in t=\u003cv1, v2, …, vn\u003e to be ordered . Values in a tuple: All values are considered atomic (indivisible). A special null value is used to represent values that are unknown or inapplicable to certain tuples. Can a key attribute contain NULL values? Why? No, since a key attribute is a unique data to identify an entity in an entity set, if the key is null, which is meaningless. 2 ER vs. Rational Data Model ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:3:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1 Mapping ER Diagrams into Tables ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.1 Repersentation of Entity(Strong) sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:1","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.2 Repersentation of Weak Entity sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:2","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.3 Repersentation of M:N Relationship Sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:3","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.4 ER to relational schema Relation Table \u0026 Entity Table Relation table Strong relation primary keys of connecting entities relation attributes(if any) Weak relation primary keys of connecting strong entities all attributes of all weak entities — — Entity table Strong entity all attributes (sign the key attribute(s)) Weak entity all primary keys of corresponding strong entity — ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:4","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.2 (min,max) notation (min,max) notation replaces the cardinality ratio(1:1,1:N,M:N) and single/double-line notation for participation constraints; Definition: For EACH entity e in E, e MUST participate in at least $min$ and at most $max$ relationship instances in R at any point in time. Conver it into English: for a particular entity(e.g. Stundet A in Student Entity), MUST appear(participate) in at most $max$ \u0026 at least $min$ tuples in the table(relation R). As a result For $min$ $min = 0\\to$ partial participation - single line, not all entities participate $min\u003e0\\to$ total paricipation - double line, all entities MUST appear in rows For $max$ For a entity, it MUST appear in at most $max$ rows in a table [Example] Translation between Cardinality ratio and (min,max) notation: Cardinality ratio 1:1 $\\to$ (min,max): $(x,1)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example: ID === HAS === Student Cardinality ratio 1:1: double lines mean total participation For every ID, it MUST be hold by one and only one student For each student, he/she MUST has one and only one ID ID =(1,1)= HAS =(1,1)= Student (min,max) notation: in HAS tabke Each student MUSt appear in the table one and only one row Each ID MUSt appear in the table one and only one row Cardinality ratio 1:N $\\to$ (min,max): $(x,N)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Cardinality ratio N:1 $\\to$ (min,max): $(x,1)$;$(N,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example Employee === WORKS_FOR === Department Cardinality ratio 1:N: double lines mean total participation One employee must work for one and only one department One department must has at least one employee working for it (min,max) notation: =(1,1)= WORKS_FOR =(1,N)= Department Each employee MUST appear in the table one and only one row Each department MUST appear in the table at least one row, at most N rows Cardinality ratio M:N $\\to$ (min,max): $(x,N)$;$(x,M)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation 3 SQL ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:5:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.1 Basic syntax (structure) of SQL SELECT [DISTINCT] attribute1,... FROM table1 [name1], tabel2 [name2],... [WHERE requirement] [GROUP BY (attribute) HAVING requirement]; [Example] Following relational schema: Customer (cname, street, city) Branch (bname, assets, b-city) Borrow (bname, loan#, cname, amount) Deposit (bname, acct#, cname, balance) E1: Find all customers of the Sai Kong branch (SELECT cname FROM Deposit WHERE bname = 'Sai Kong') -- 注意是单引号 UNION -- not only Deposit customres, but borrow customers (SELECT cname FROM Borrow WHERE bname = 'Sai Kong'); E2: Find the name and city of all customers having a loan at the Sai Kong branch SELECT DISTINCT Customer.cname,city FROM Borrow,Customer WHERE Borrow.cname = Customer.cname AND Borrow.bname = 'Sai Kong'; E3: Find the names of all customers whose street has the substring ‘Main’ included SELECT cname FROM Customer WHERE Customer.street LIKE '%Main%'; E4: Find all customers who have an account at some branch in which Jones has an account SELECT DISTINCT S1.cname FROM Deposit S1 WHERE S1.bname IN (SELECT bname FROM Deposit S2 WHERE S2.cname = 'Jones') AND S1.cname != 'Jnoes'; SELECT DISTINCT S2.cname FROM Deposit S1,Deposit S2 WHERE S1.cname = 'Jnoes' AND S1.bname = S2.bname AND S1.cname != S2.cname; E5: Find branches having greater assets than all branches in N.T. SELECT B1.bname FROM Branch B1 WHERE B1.assets \u003e ALL (SELECT B2.assets FROM Branch B2 WHERE B2.b-city = 'N.T.' ); SELECT B1.bname FROM Branch B1 WHERE NOT EXISTS (SELECT * FROM Branch B2 WHERE B2.assets \u003e= B1.assets AND B2.b-city = 'N.T.' ); E6: Find names of all branches that have greater assets than some branch located in Kowloon SELECT bname FROM Branch WHERE assets \u003e SOME (SELECT assets FROM Branch WHERE b-city = 'Kwoloon'); SELECT bname FROM Branch B1,Branch B2 WHERE B1.assets \u003e B2.assets AND B2.b-city = 'Kwoloon'; E7: Find all customers who have a deposit account at allbranches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE (SELECT T.bname FROM Deposit T account WHERE S.cname = T.cname) -- the set of branches he/she has a deposit account CONTAINS (SELECT bname FROM Branch WHERE b-city = 'Kowloon'); -- the set of branches on Kwoloon E8: Find all customers of Central branch who have an account there but no loan there SELECT C.cname FROM Customer C WHERE EXISTS (SELECT * FROM Deposit D WHERE D.cname = C.cname AND D.bname = 'Central') AND NOT EXISTS (SELECT * FROM Borrow B WHERE B.cname = C.cname AND B.bname = 'Central'); E9: Find all customers who have a deposit account at ALL branches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE NOT EXISTS( (SELECT bname FROM Branch WHERE b-city = 'Kowloon') MINUS (SELECT T.bname customer S FROM Deposit T WHERE S.cname = T.cname)); E10: List in alphabetic order all customers having a loan at branches in Kowloon SELECT DISTINCT cname FROM Borrow WHERE b-city = 'Kowloon' ORDER BY cname; --By default, in ascending order. E11: List the entire borrow table in descending order of amount, and if several loans have the same amount, order them in ascending order by loan# SELECT * FROM Borrow ORDER BY amount DESC, loan# ASC; -- when the \u003camount\u003e is the same, order aomunt by \u003cloan#\u003e in ascending, and so on. ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:6:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.2 NULL Value All comparisons involving Null become FALSE!!! A modification is permitted through a view ONLY IF the view is defined in terms of ONE base/physical relation(whether all the values of tuple are full). In most SQL-based DBMSs, the special keyword NULL may be used to test for a null value. [like] SELECT c-name FROM Deposit WHERE balance IS NOT NULL; ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:7:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.3 Aggregate Function Compute functions on groups of tuples using the group by clause Tuples with the same value on all attributes in the group by clause are placed in one group Aggregate function includeds: avg, sum, min, count, max E1: Find the average account balance at each branch: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name; E2: If only interested in branches where average balance is \u003e $12000: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name HAVING AVG(balance) \u003e 12000; E3: Find those branches with the highest average balance: SELECT b-name FROM Deposit GROUP BY b-name HAVING AVG(balance) = SELECT MAX(AVG(balance)) FROM Deposit GROUP BY b-name); E4: Find the average balance of all depositers who live in Laguna city and have at least 3 accounts: SELECT AVG(balance) FROM Deposit, Customer WHERE Deposit.c-name = Customer.c-name AND city = 'Laguna' GROUP BY Deposit.c-name HAVING COUNT(DISTINCT acct#) \u003e= 3; 学习笔记，仅供参考 ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:8:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:0:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.1 What is Database(DB)? A non-redundant, persistent(like store in hard disk) collection of logically related records/files that are structured to support various processing and retrieval needs. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:1:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.2 Database Management System A set of software programs for creating, storing, updating, and accessing the data of a DB. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:2:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.3 Basic concept and terminologies instance (compared to the instance in oop) the collection of data (information) stored in the DB at a particular moment (ie, a snapshot) The data in the database at a particular moment in time is called a database state or snapshot. It is also called the current set of occurrences or instances in the database. scheme/schema the overall structure (design) of the DB – relatively static ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:3:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.4 Data Abstraction: 3-level architecture Internal/Physical Level: the complete details of data storage and access paths for the database. (i.e., SSD,Cloud,disk)(how data are actually stored) Internal level has an internal schema, which describes the physical storage structure of the database. Conceptual Level: which describes the structure of the whole database. For a 2D array, it will be stored as a “table” in database. It hides the detail of internal level.(what data are actually stored) The conceptual schema hides the details of physical storage structures and concentrates on describing entities, data types, relationships, user operations, and constraints.(data model) External Level: It only privides the data which the user wants and hide the rest of the datbase. Consider a two-dimensional integer array of size n*m The physical level would simply be n × m (probably consecutive) storage locations The conceptual level is a grid of boxes, each possibly containing an integer, which is n boxes high by m boxes wide. There are $2^{n×m}$ possible views (external level). For example, a view might be the entire array, or may be a part of array. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:4:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.5 Data Independence The ability to modify a schema definition in one level without affecting a schema in the next higher level Physical data independence: capacity to change the internal schema without having to change the conceptual schema Logical data independence: the capacity to change the conceptual schema without having to change external schemas or application programs. DB System Architecture 2 The Entity-Relationship Model(实体关系模型) ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:5:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1 Basic Definition ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.1 ER模型的作用 数据库设计的第一步是需求分析阶段，也是最重要的一步 概念建模也就是ER建模,将需求以ER图的方式进行可视化 ER图可以描述一个数据库的逻辑结构 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.2 ER模型的组成 2.1.2.1 entity entity(实体): a distinguishable object with an independent existence 一个entity可以是具体的(如：人，书，CityU), 也可以是抽象的(如：假期) entity set: a set of entities of the same type Like: Student Bank…… 2.1.2.2 attribute attribute(属性): 一个entity用一组attributes来表示，每一个attribute有一个对应的值，比如一个人可以有name，SSN，gender，phone number等attributes Different type of Attributes: Simple: Each entity has a single atomic value for the attribute. For example SSN or Sex Composite: The attribute may consist of several components. For example, Name(FirstName, MiddleName, LastName). Multi-valiue: An entity may have multiple values for that attribute. For example, Color of a CAR, denoted as {Color}. In general, composite and multi-valued attributes may be nested. Domain: 一个attribute的domain是这个attribute值的有效范围 Formally, an attribute A is a function which maps from an entity set E into a domain D: $$A: E\\to D$$ 2.1.2.3 relationship Relationship: the relationship(association) among several entities An attribite $A:E\\to D$ is a “simplified form of a relationshihp” if we allow D to be an Entity Set, then A becomes a relationship A realtionship can carry attribute Example: Patrick takes cs2450 with a grade of B+. “takes” is relationship bteween “Patrick” and “CS2450”, “B+” is the attribute of this relationship, since “B+” is neither the attribute of “Patrick” nor “CS2450”, which is “Patrick takes cs2450” The degree of a relationship set/type is the number of participating entity sets/types. Both MANAGES and WORKS_ON are binary relationships. In general, an n-ray relationship is not equialent to n binary relationships. The relationship has participation constraint partial participation: single line (not all entity participate) total participation: double line (every entity participate) (min,max) notation for relationship Specified on each participationof an entity set E in a relationship set R Specifies that each entity e in E participates in at least min and at most max relationship instances in R Default (no constraint): min=0, max=n ! Must have: $min\u003c=max,min\u003e=0,max\u003e=1$ (a) is not equivalent to (b) but to (c). ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:2","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3 ER diagram ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3.1 ER图的基本构成 Rectangles(正方形): Entity Sets Ellipses(椭圆形): Attributes Diamonds(菱形): Relationship Sets Lines: Attributes to Entity/ Relationship Sets or, Entity Sets to Realtionship Sets 不同的键(Key): to distinguish individual entities or relationships Superkey (超键): a set of one or more attributes which, taken together, identify uniquely an entity in an entity set 在关系中能唯一标识元组的属性集称为关系模式的超键 Example: 一般来说，学号是标识学生实体的唯一标识，所以该元组的超键就为学号。我们可以将学号和其他属性结合起来，(学号，性别)，(学号，年龄)等也为超键。 Candiaite key(候选键): minimal set of attributes which can identify uniquely an entity in an entity set 最小的超键，仅包括独一标识实体所必需得最小属性的数量，即不含多余属性的超键为候选键 Example: stident ID identify a student, but Name is not a candidate key 候选键是超键的子集 Primary key(主键): a candidate key chosen by the DB designer to identify an entity in an entity set 是从候选码(candidate key)中人为挑选的一个 Foreign key: FK is a set of attributes of R1, which refers to the PK(primary key(s)) of R2 Domain of FK should be the same as PK t1[FK] in R1 either occurs as a value of t2[PK] in R2 or is NULL. 实体间的联系 Integrity Constraints One-to-one(一对一): 例如班级和班长之间就是一对一联系，一个班级只有一个班长 One-to-many(一对多/多对一): 例如一个班级有一个辅导员，但担任辅导员的老师可以同时担任其他班级的辅导员，所以辅导员和班级之间就是一对多联系 Many-to-many(多对多): 例如一个学生可以学习多门课程，每门课程也可以有多个学生，那么学生和课程之间的关系就是多对多联系 Weak Entity Set An entity set that does NOT have enough attributes to form a primary/candidate key 学习笔记，仅供参考 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["我的博客"],"content":"Java学习记录（一） JAVA 学习 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:0:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.JAVA语言基础 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1Java中的数值类型 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1.1 数值类型 1.1.2 数据类型转换 顾名思义，即为将一个值从一个类型转换为另一个类型的过程。例如，可以将String类型的数据“457”转换为数值型，也可以将任意类型的数据转换为String类型。 如果从低精度数据类型向高精度数据类型转换，则永远不会溢出，即更加安全，并且总是成功，；而把高精度类型数据转换为低精度类型数据时，被可能存在数据的丢失，又可能失败。 数据转换有两种形式，隐式转换（由低精度转换为高精度）与显式转换（由高精度转换为低精度）。 精度由低到高：（不包含逻辑类型与字符类型） byte \u003c short \u003c int\u003c long \u003c float \u003c double 例： int x =50; float y = x; //由于浮点型精度高于整数型，所以此转换为隐式转换，结果为50.0 当我们需要把高精度的变量赋给低精度的变量时，必须使用显示类型转换运算（又称强制类型转换）。 例: int a = (int)45.23; // 输出为45 long y = (long)456.5F; // 输出为456 int b = (int)'d'; // 输出为100 除布尔型以外，其他基本类型数据都能进行显型类型转换。 1.1.3 运算符 在Java中有着算数运算符，关系运算符，位运算符，逻辑运算符，赋值运算符以及其他运算符。在此，我们主要讨论自增、自减运算符和位运算符。 b = ++a; b = a++; 上述两行代码看似差不多，实际上有很大区别：第一行翻译为先将a的值+1，然后再赋给b；第二行则是先将a的值赋给b，a的值再+1。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.2类中的变量类型 局部变量：在方法，构造方法或者语句块中被定义的变量。方法结束后，变量会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量，可以被类中方法、构造方法等语句块访问，没有static修饰。 类变量：类变量也申明在类中，方法体之外，但必须声明为static类型。 例： public class Variable{ static int allclicks = 0; // 类变量（静态变量） String str = \"hello world\"; // 实例变量（成员变量） public void method(){ int i = 0; // 局部变量 } } 在Java中，所有变量在使用前都必须声明。 例： int a,b,c; // 声明了3个int型整数：a，b，c。 int d = 3,e,f = 5; // 声明三个整数并赋予初值。 byte z =22; // 声明并初始化。 char x = 'x'; // 变量x的值是字符‘x’。 double pi = 3.14159;// 声明了pi。 既然有变量，那就会有常量。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.3Java常量 常量就是一个固定值。他们不需要计算，直接代表相应的值。 常量指不能改变的值，在Java中用final标志： final double PI = 3.1415927; ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:4","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.4构造方法 每个类都有构造方法。 在创建一个对象时，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 例： public class Puppy(){ public Puppy(){ } public Puppy(String name){ } } 上述代码类的构造方法为Puppy(),返回值为字符串类型的‘name’，即调用该构造方法时，Puppy(\"name\"), ’name’ 即为用户想输入的小狗的名字。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:5","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.5创建对象 在Java中使用关键字 new 来创建一个新的对象。 声明：声明一个对象，包括对象名称和类型。 实例化：使用关键字 new 来创建一个对象。 初始化：使用 new 创建对象时，会调用构造方法(constructor)初始化对象。 例： public class Puppy(){ public Puppy(String name){ System.out.println(\"Puppy name is : \"+ name); } public static void main(String []args){ Puppy myPuppy = new Puppy(\"tommy\"); // 上述语句创建了一个Puppy对象 } } 代码块的结果会显示为：Puppy name is tommy ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:6","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.6访问实例变量和方法 /*实例化对象*/ ObjectReference = new Constructor(); /*访问其中的变量*/ ObjecReference.variableName; /*访问类中的变量*/ bjecReference.MethodName(); public class Puppy(){ int puppyAge; //定义了一个名为puppyAge的int型成员变量 public Puppy(String name){ System.out.println(\"Passed Name is: \"+ name); } public void setAge(int age){ puppyAge = age; } public int getAge(){ System.out.println(\"Puppy's age is: \" + puppyAge); return puppyAge; } public static void main(String []args){ /*创建对象*/ Puppy myPuppy = new Puppy(\"tommy\"); /*调用方法来设定age*/ myPuppy.setAge(2); /*调用另一个方法来获取age*/ myPuppy.getAge(); /*访问成员变量*/ System.out,println(\"Variable Value: \" + myPuppy.puppyAge); } } 结果为： Passed name is: tommy Puppy’s age is: 2 Variable Value: 2 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:7","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"2.JAVA修饰符 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类) public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"默认访问修饰符-不使用任何关键字 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 如下例，变量和方法的声明可以不适用任何修饰符： String version = \"1.5.1\" boolean processOder(){ return true } ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"私有访问修饰符-private 私有访问修饰符是最严格的访问级别，所以被声明为private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为私有访问类型的变量只能通过类中公共的getter 方法被外部类访问。 Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 下面的类使用了私有访问修饰符private public class Logger { private String format; public String getFormat() { return this.format; } public void setFormat(String format) { this.format = format; } } Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 public方法：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）。 公有访问修饰符-public 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。最常见的公有访问即为public static void main(String []args){...}。Java 程序的main()方法必须设置成公有的，否则Java 解释器将不能运行该类。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"受保护的访问修饰符-protected 被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能被不同包中的字类访问。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"非访问修饰符 例如static修饰符，用来创建方法和类变量。 final修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承重新定义，修饰的变量是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。 -synchronized和volatie修饰符，主要用于线程的编程。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"final修饰符(关键字) final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。 final修饰符通常和static修饰符一起是用来创建常量。 例： public class Test{ final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = \"Manager\"; public void changeValue(){ value = 12;//将输出一个错误 } } 由于value的值已经被final定义过，所以无法被改变。 类中的final方法可以被字类继承，但是不能被字类修改。fianl类不能被继承，没有类能够继承final类的任何特性。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"static修饰符 静态变量： static关键字用来声明独立于对象的静态变量，静态变量也被称为类变量。局部变量不能被声明为static变量。 例： public class InstanceCounter{ private static int numInstances = 0; protected static int getCount(){ return numInstances; } private static void addInstance(){ numInstances++; } InstanceCounter(){ InstanceCounter.addInstance(); } public static void main(String []args){ System.out.println(\"Starting with \"+:InstanceCounter.getCount()+ \"instances\"); for (int i = 0; i \u003c 500; i++){ new InstanceCounter(); } System.out.println(\"Created \"+ InstanceCounter.getCount()+\" instances\"); } } 结果如下： Started with 0 instances Created 500 instances 引用时请标明出处 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"Java学习记录（二） Java 数据类型 变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。 内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有着两大数据类型，内置数据类型和引用数据类型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:0:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"内置数据类型 其中包括6种数字类型（4个整数型和2个浮点数型），一种字符类型，及一种布尔型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"数字类型 byte： byte的数据类型是8位、有符号的，以二进制补码（2‘s）表示的整数。 最小值是-128（-2^7） 最大值是127（2^7-1） 默认值是0 byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short: short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15） 最大值是 32767（2^15 - 1） Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一 默认值是0 例子：short s = 1000，short r = -20000。 int: int 数据类型是32位、有符号的以二进制补码表示的整数 最小值是-2^31（-2147483638） 最大值是2^31-1（-2147483637） 一般的整型变量默认为int型 默认值是0 例子：int i = 100； long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）最大值是 9,223,372,036,854,775,807（2^63 -1） 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double: double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数； 浮点数的默认类型为 double 类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char: char 类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（十进制等效值为 0）； 最大值是 \\uffff（即为 65535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’; 测试","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:1","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":null,"content":"L3 ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:0","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task1 ps ps -a ps -l Task 2: ls: list the files in the current directory ls -l: list the files in the current directory in long format ls -a: list the files in the current directory, including the hidden files ls -t: list the files in the current directory, sorted by time ls -lat: list the files in the current directory, including the hidden files, in long format, sorted by time cd: change the current directory .: the current directory ..: the parent directory cp: copy a file cp file1 file2: copy file1 to file2 cp file1 file2 file3 dir: copy file1, file2, file3 to dir cp -r dir1 dir2: copy dir1(all the content) to dir2 recursively mv: move a file mv file1 file2: move file1 to file2 mv file1 file2 file3 dir: move file1, file2, file3 to dir mv dir1 dir2: rename dir1 to dir2 rm: remove a file rm -rf dir: remove dir recursively and forcefully mkdir: make a directory mkdir dir: make a directory named dir who: show the users who are currently logged in whami: show the current user who -q: show the number of users who are currently logged in who -u: show the idle time of the users who are currently logged in cat: concatenate files and print on the standard output cat file: print the content of file on the standard output cat file1 file2: print the content of file1 and file2 on the standard output cat file1 file2 \u003e file3: concatenate file1 and file2, and write the result to file3 cat file1 file2 \u003e\u003e file3: concatenate file1 and file2, and append the result to file3 man: an interface to the on-line reference manuals man command: show the manual of command man -k keyword: search the manual for keyword man -f command: show the manual of command man -a command: show all the manual of command gcc: GNU project C and C++ compiler gcc file: compile file gcc file -o file: compile file and output the executable file to file gcc file1 file2 -o file: compile file1 and file2 and output the executable file to file Task 3: vi: a text editor vi file: open file in vi i: enter insert mode esc: exit insert mode, enter command mode Under command mode: :w: save the file :q: quit vi :wq: save and quit vi :q!: quit vi without saving h: move leftward; l: move rightward; j: move downward; k: move upward w: move rightward word by word; b: move leftward word by word dw: delete the word after the cursor u: undo the last command dd: delete the current line $: move to the end of the line; ^: move to the beginning of the line gedit: a text editor gedit file: open file in gedit Task 4: Shell output redirection who \u003e users: redirect the output of who to file users, overwriting(replace) the original content of users who \u003e\u003e users: append the output of who to file users Task 5: Shell input redirection wc \u003c users: redirect the content of users to wc, and count the number of lines, words, and characters in users wc -l: count the number of lines wc -l \u003c output.txt \u003e output1.txt: count the number of lines in output.txt, and write the result to output1.txt Task 6: write, compile, and run a C program vim hello.c: write a C program in vi gcc hello.c -o hello: compile the C program and output the executable file to hello ./hello: run the executable file External Task: pipeline - make a pipe among processes ls -l | wc -l: count the number of files in the current directory ls -l | grep \"hello\": list the files in the current directory whose name contains “hello” ls -l | grep \"hello\" | wc -l: count the number of files in the current directory whose name contains “hello” ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:1","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task2 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main (void){ printf(\"Process ID: %ld\\n\", (long)getpid()); printf(\"Parent ID: %ld\\n\", (long)getppid()); printf(\"Onwer user ID: %ld\\n\", (long)getuid()); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:2","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task3 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork, mypid; mypid = getpid(); printf(\"Before: my pid is %d\\n\", mypid); ret_from_fork = fork(); sleep(1); printf(\"After: my pid is %d, fork() said %d\\n\", getpid(), ret_from_fork); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:3","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task5 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if (childpid = fork()) break; //parent breaks out; child continues fprintf(stdout, \"This is process %ld with parent %ld, i = %d\\n\",(long)getpid(), (long)getppid(), i); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:4","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task6 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if ((childpid = fork()) \u003c= 0) break; //child and error break out; parent continues fprintf(stdout, \"This is process %ld with parent %ld\\n, i = %d\",(long)getpid(), (long)getppid(), i); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:5","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task7 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cerrno.h\u003e void main(void){ int i, n = 4, status; pid_t childpid, waitreturn; for (i = 1; i \u003c n; ++i) { if (childpid = fork()) { break; //parent breaks from for loop } } // parent process waits for all children to terminate // in parent process, childpid is the PID of the child process // if child terminated, the return value is positive and is the PID of that child while (childpid != (waitreturn = wait(\u0026status))){ // child process has not terminated if ((waitreturn == -1) \u0026\u0026 (errno != EINTR)) // child process has terminated break; } fprintf(stdout, \"I am process %ld, my parent is %ld\\n\", (long)getpid(), (long)getppid()); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:6","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 8 In-class demo: exec example on creating a process to run ls -l #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void main(void){ int status; pid_t childpid; if ((childpid = fork()) == -1){ perror(\"Error in the fork\"); exit(1); }else if (childpid == 0){ /* child code */ if (execl(\"/usr/bin/ls\", \"ls\", \"-l\", NULL) \u003c 0){ // user/bin/ls is not the path of ls - use \u0026 user perror(\"Exec of ls failed\"); exit(1); } } else if (childpid != wait(\u0026status)) // /* parent code */ perror(\"A signal occurred before child exited\"); exit(0); } Compare with typing ls -l directly in terminal, the process performs ls -l in ./l3demo8 is the grandson of the terminal process, and the process performs ls -l in ./l3demo8 is the child of the terminal process. ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:7","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 9 In -class demo: exec example on creating a process to run ls -l execvp(): p - search the executable file in the PATH environment variable v - arguments are passed to main as an array of char *const pointers, each pointing to a C string. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void main(void){ int status; pid_t childpid; char *argv[3]; argv[0] = \"ls\"; argv[1] = \"-l\"; argv[2] = 0; //NULL pointer if ((childpid = fork()) == -1){ perror(\"Error in the fork\"); exit(1); } else if (childpid ==0) { /* child code */ if (execv(\"/user/bin/ls\", argv) \u003c 0){ perror(\"Exec of ls failed\"); exit(1); } } else if (childpid != wait(\u0026status)) /* parent code */ perror(\"A signal occurred before child exited\"); exit(0); } Demo Task 10 In-class demo: exec has no return. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(void){ printf(\"Old image: pid=%d\\n\", getpid()); execlp(\"./newimage\", \"newimage\", NULL); printf(\"Old image: hello\\n\"); return 0; } #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main (void) { printf(\"New image: pid=%d\\n\", getpid()); return 0; } exec will not create a new process, still the same process. The memory will be re-written by the new image. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(void){ char * envp[2] envp[0] = \"PATH=test\" envp[1] = NULL; printf(\"Old image: pid=%d\\n\", getpid()); execle(\"./newimage\", \"newimage\", NULL, envp); printf(\"Old image: hello\\n\"); return 0; } #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main (void) { printf(\"New image: pid=%d\\n\", getpid()); printf(\"New image: PATH=%s\\n\", getenv(\"PATH\")); return 0; e: entire Demo Task 11 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003csyslog.h\u003e #include \u003cstring.h\u003e #define MAX_I 100 void main (void){ pid_t pid, sid; FILE* p_output; int i = 0; pid = fork(); if (pid \u003c 0) exit(EXIT_FAILURE); if (pid \u003e 0) exit(EXIT_SUCCESS); umask(0); sid = setsid(); // create the daemon process if (sid \u003c 0) exit(EXIT_FAILURE); if ((chdir(\".\")) \u003c 0) // change the directory to the current directory exit(EXIT_FAILURE); printf(\"Daemon: Hello!\\n\"); // the child session will inherit the stdout from the parent, so it will still print out on the current terminal(\"parent\" session) close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); printf(\"Daemon: Goodbye!\\n\"); // `STDIN/OUT` are closed, the child session cannot access parent I/O, so it will not print out in current terminal while(1){ if ((p_output = fopen( “daemon_output.txt”, “a”)) != NULL){ fprintf(p_output, “%d\\n”, i++); i %= MAX_I; fclose(p_output); } sleep(3); } exit(EXIT_SUCCESS); } umask umask(0): set the file mode creation mask(umask) to 0, so that the file mode of the daemon output file is not restricted. umask() sets the calling process’s file mode creation mask to mask \u0026 0777, 7 means 111 in binary open() and mkdir() mkdir(): the mode of the created directory is (mode \u0026 ~umask \u0026 0777) mode is default mode e.g. umask(0) -\u003e mkdir() -\u003e 0777 \u0026 ~0 \u0026 0777 -\u003e 0777: the deafult mode will be remained setsid although setsid will move to another session, but the opened file is still be accessed the child process calls setsid() to create a new session and obtain a new session ID (SID). If setsid() fails (returns -1), the program exits with a failure status. The child process then changes the current working directory to the root directory using chdir(\".\"). If the chdir() call fails, the program exits with a failure status. child process closes the standard input, standard output, and standard error file descriptors. This is done to disconnect the daemon process from the terminal, as it no longer needs them. abo","date":"0001-01-01","objectID":"/posts/sp/demo/:1:8","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"L4 ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:0","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 1 **What are the differences between a regular file and a device file? ** \u003ecp /etc/passwd /tmp/garbage \u003ecp /etc/passwd /dev/tty // \u003e cp normal.txt /dev/tty Hello world! content will be displayed on the terminal for tty device file ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:1","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 2 The C library function getcwd returns the pathname of the current working directory char *getcwd(char *buf, size_t size) size specifies maximum length pathname. If longer than the maximum, returns NULL and sets errono to ERANGE. #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cerrno.h\u003e int main(){ char cwd[1024]; if (getcwd(cwd, sizeof(cwd)) != NULL) printf(\"Current working dir: %s\\n\", cwd); else perror(\"getcwd() error\"); return 0; } read a file bytes = read(fd, buffer, count) Read from file associated with fd; place count bytes into buffer fd: file descriptor to reasd from buffer: pointer to any array count: number of bytes to read Returns number of bytes read or -1 if an error occured ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:2","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 3 int fd = open(\"someFile\", O_RDONLY); char buffer[4]; // store in stack, no need to de-allocate char * buff2 = malloc(4*sizeof(char)); // store in heap, need to de-allocate int bytes = read(fd, buffer, 4*sizeof(char)); free(buff2); // de-allocate the memory or there will be memory leak write a file - overwrite bytes = write(fd, buffer, count) Write contents of buffer to the file associated with fd, write count bytes into the file O_TRUNC: if the file already exists and is a regular file and the access mode allows writing, truncate it to length 0. fd: file descriptor to write to buffer: pointer to any array count: number of bytes to write Returns number of bytes written or -1 if an error occured ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:3","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 4 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void main(){ char buff4[4] = {'a','b','c',0} int i = 0; int bytes_written = 0; int fd; fd = open(\"someFile\", O_WRONLY|O_CREAT, 0644); printf(\"sizeof(buffer) is %d\\n\", sizeof(buffer)); // char buffer[4]; bytes_written = write(fd, buffer, 4*sizeof(char)); for (i = 0; i \u003c 4; i++) { printf(\"The %dth byte is %c\\n\", i, buffer[i]); } fsync(fd); // flashes the content into disk before close (for written) close(fd); // when open, close it } Demo Task 5 #include \u003cstdio.h\u003e FILE *myfp; if ((myfp = fopen(\"/home/ann/my.dat\", \"w\")) == NULL) fprintf(stderr, \"Could not fopen file\\n\"); else fprintf(myfp, \"This is a test\"); overwrite #include \u003cstdio.h\u003e void main() { FILE *fp; fp = fopen(\"someFile\", \"w\"); if (fp == NULL) { fprintf(stderr, \"Could nor fopen file.\\n\"); } else { fprintf(fp, \"This is a test\"); } fflush(fp); fclose(fp); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:4","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 6 printf(\"The sum of %d, %d, and %d is %d\\n\", 65, 87, 33, 65+87+33); // output: The sum of 65, 87, and 33 is 185 printf(\"Error %s occurred at line %d \\n\", emsg, lno); // output: Error invalid variable occurred at line 27 printf(\"Hexadecimal form of %d is %x \\n\", 59, 59); // output: Hexadecimal form of 59 is 3B #include \u003cstdio.h\u003e void main() { int x = -1; printf(\"%%d = (%d) , %%i = (%i), %%u = (%u), %%o = (%o), %%x = (%x), %%X = %X\\n\", x, x, x, x, x, x); char c = 'a'; char* s = \"hello world.\\n\"; // literal string float f = 1.12345678901234567890e20; double lf = 1.12345678901234567890e20; printf(\"%%c = (%c).\\n\", c); printf(\"%%s = (%s).\\n\", s); printf(\"%%f = (%f), %%lf = (%lf), %%e = (%e), %%E = (%E), %%g = (%g), %%G = (%G).\\n\", f,lf,lf,lf,lf,lf); } %d = (-1) , %i = (-1), %u = (4294967295), %o = (37777777777), %x = (ffffffff), %X = FFFFFFFF ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:5","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 7 fgets(): #include \u003cstdio.h\u003e void main() { int i; char c; char buf[256]; while (1) { fgets(buf, sizeof(buf), stdin); printf(\"%s = \\\"%s\\\".\\n\", buf); } fscanf(): #include \u003cstdio.h\u003e void main() { int i; char c; char buf[256]; FILE* datafile; datafile = fopen(\"mydata.txt\", \"r\"); while (!feof(datafile)) { fscanf(datafile, \"%d %c %s\", \u0026i, \u0026i, \u0026buf); printf(\"i = %d, c = \\'%c\\', s = \\\"%s\\\".\\n, i, c , buf\"); } } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:6","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 8 #include\u003cstdio.h\u003e #include\u003cfcntl.h\u003e #include\u003cunistd.h\u003e char* cmd[] = {\"/bin/ls\", \"-l\", 0}; int main(int argc, char* argv[]){ int fd = open(argv[1], O_WRONLY | O_CREAT, 0600); //fd will be 3; a file will be opened in write mode int fd2 = dup(fd); //duplicate the fd-th pointer to entry 4, the lowest available entry close(STDOUT_FILENO); // the entry 1 is now available(free) dup(fd); //duplicate the fd-th pointer into entry 1, \"my.dat\" become the standard output file execvp(cmd[0], cmd); // the old process image is replaced by the new process image for ls // the File Descriptor Table is \"inherited\" by the new process image, // still the same process(PID), but the image is replaced close(fd); //close file descriptor 3 in the parent process. return; } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:7","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 9 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstring.h\u003e int main(){ int fd[2]; pipe(fd); //fd[0] is for read and fd[1] is for write pid_t child = fork(); char* data = \"hello world\"; if (child == 0){ //child process close(fd[1]); char buf[100]; //a large enough buffer to share data int bytes_to_read = strlen(data)+1; while (bytes_to_read \u003e 0) { int count = read(fd[0], buf, sizeof(data)); bytes_to_read -= count; } printf(\"child process read: \\\"%s\\\" .\\n\", buf); } else { //parent process close(fd[0]); int bytes_to_write = strlen(data)+1; while (bytes_to_write \u003e 0) { int count = write(fd[1], data, strlen(data)+1) // \"+1\" for null byte, terminateing 0 bytes_to_write -= count; } fsync(fd[1]); //flush the data into pipe before close printf(\"parent process written: \\\"%s\\\" .\\n\", data); close(fd[1]); } return 0; } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:8","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":" Lighthouse (image) 网站概述 | Website Abstract eshanwu是我的一个个人博客网站, 我会在网站上不定期的更新一些文章以及学习笔记, 自学过程, 也会有一些人生感悟。 关于我 | About Me 香港理工大学计算机科学本科生 Major in Computer Science, The Hong Kong Polytechnic University Minor in Financial Services and Institutions; Lighthouse (image) ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]