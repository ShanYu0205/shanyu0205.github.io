[{"categories":["个人博客相关"],"content":"这篇文章展示了基础的博客搭建","date":"2023-05-09","objectID":"/posts/server-file/server-build/","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"Hugo个人博客搭建 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:0:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"1 快速开始 基于Mac系统 主要流程 安装相关环境 安装git 安装Homebrew 安装hugo 博客相关操作 新建自己的博客站点 设置主题 本地启动博客 构建网站 服务器部署(github) 将博客部署到github远端 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:1:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"2 相关环境安装 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:2:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"2.1 安装git 打开终端,即terminal, 输入以下命令，回车执行 git --version 如果已经安装，则会显示安装的版本信息；若没有安装，则会提示安装，按照提示安装即可。 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:2:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"2.2 安装Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 同样可以通过，brew -v来检查是否已经安装或者是否安装成功 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:2:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"2.3 安装hugo brew install hugo # 检查安装成功 hugo version ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:2:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3 博客相关操作 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.1 新建自己的博客站点 首先新建一个网站，名字随便起，这里以 myblog 为例，[PATH] 为自己想要存放的路径，myblog 为网站名。 hugo new site [PATH]/myblog ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.2 设置主题 这里以LoveIt为例, 该主题仓库是：https://github.com/dillonzq/LoveIt 通常来说，我们将这个主题直接克隆clone到theme目录即可 # 先进入myblog目录下 cd [PATH]/myblog # 克隆操作 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.3 创建第一篇文章 hugo new posts/first_post.md ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.4 本地启动博客 hugo serve 去查看 http://localhost:1313. ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:4","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.4 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:5","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["个人博客相关"],"content":"3.5 将博客部署到github远端 首先在自己的GitHub赏创建一个新的仓库，名称必须为Github用户名.github.io，例如我的就是shanyu0205.github.io,用户名必须全小写. 创建成功后，将自己的博客文件夹下的public文件夹下的所有文件复制到Github用户名.github.io仓库下，然后提交到远端即可。 所有git命令都应在public文件夹下执行，应为public文件夹下才是真正的博客文件，其他的都是配置文件 cd public # 进入public文件夹 git init git add . # 注意后面有个点 git commit -m \"我的第一个hugo博客\" git remote add origin \"https://github.com/\"你的库的地址\"\" # 与远端的git仓库进行关联 git push # 如果是第一次提交，需要加上-u参数: git push -u origin master 注意：由于Github修改了关于公钥的条例，所以在push的时候,可能会出现Permission denied的错误 所以需要在push之前,先在Github的Settings的Developer settings里,找到Personal access token,并选择token(classic)，然后点击Generate new token，然后在弹出的页面中，勾选repo，然后点击Generate token，然后将生成的token复制下来输入终端. 详情请见：https://blog.csdn.net/qq_43382853/article/details/119221234 接下来就可以通过[].github.io直接访问自己的博客了。[]中填写自己的github用户名 此时，如果你的博客还没有显示出来，那么就需要等待一段时间，因为github需要一段时间来构建你的博客，一般来说，等待时间不会超过10分钟。 ","date":"2023-05-09","objectID":"/posts/server-file/server-build/:3:6","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/server-file/server-build/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Disk Storage Devices Data stored as magnetized areas on magnetic disk surfaces. A disk pack contains several magnetic disks connected to a rotating spindle. Disks are divided into concentric circular tracks on each disk surface. Track capacities vary typically from 4 to 50 Kbytes. A track is divided into blocks (In some systems, there is an intermediate unit called sectors). The block size B is fixed for each system. Typical block sizes range from B=512 bytes to B=4096 bytes. Whole blocks are transferred between disk and main memory for processing. A read-write head moves to the track that contains the block to be transferred. Disk rotation moves the block under the read-write head for reading or writing A physical disk block address consists of a surface number, track number (within surface), and block number (within track) Reading or writing a disk block is time consuming because of the seek time $s$ and rotational delay (latency) $rd$ Double buffering can be used to speed up the transfer of contiguous disk blocks 2.1 File of Records A file is sequence of records, where each record is a collection of data values or items. A file descriptotr or header includes information that describes the file, such as the field names and their data tpyes, and the addressseds of the file blocks on the disk. Records are stored on disk blocks. The blocking factor bfr for a file is the (average) number of file records stored in a disk block. A file can have fixed-length records or variable-length records. File records can be unspanned: no record can span two blocks spanned: a record can be stored in more than one block In a file of fixed-length records, all records have the same format. Usually, unspanned blocking is used with such files. Files of variable-length records require additional information to be stored in each record. Usually spanned blocking is used with such files. The records of a file can be contiguous, linked, or indexed. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:0:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.2 Operation on Files ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:1:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.3 Unordered Files \u0026 ordered Files Unordered Files: also called pile file New records are insterted at the end of the file Linear search through the file is necessary, which requires reading and searching half the file blocks on the average. QUITE EXPENSIVE. Insertion is quite efficient Reading the records in order of a particular field requires sorting the file records. 9 16 50 2 10 4 8 12 60 100 Ordered Files: also called sequential file File records are kept sorted by the values of an ordering field. Insertion is expensive: records must be inserted in the correct position. It is common to keep a separate unordered overflow file for new records to improve insertion efficiency; this is periodically merged with the main ordered file A binary search can be used to search for a record on its ordering field value. This requires reading and searching ${log_2}^{n}$ of the file blocks on the average. Reading the records according to the order of the ordering field is quite efficient. 2 4 6 14 18 50 100 5000 9000 100000 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:2:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.4 Hashed Files Hashing for disk files is called External Hashing Collisions occur when a new record hashes to a bucket that is already full an overflow file is kept for storing such records; overflow records that hash to each bucket can be linked together. [Resolution] Open addressing: Proceeding from the occupied position specified by the hash address, the program checks the subsequent positions in order until an unused (empty) position is found. Linear Prob: If collide, try Bucket_id+1, Bucket_id+2, … Quadratic Prob: If collide, try Bucket_id+1, Bucket_id+4,…(try to not affect the close neighbors like linear probing) Main disadvantagesof static external hashing: Fixed number of buckets M is a problem when the number of records in the file grows or shrinks. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:3:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.5 Dynamic and Extendible Hashing Techniques Both dynamic and extendible hashing use the binary representation of the hash value h(K) in order to access a directory. In dynamic hashing the directory is a binary tree. In extendible hashing the directory is an array of size $2^d$ where d is called the global depth. The directories can be stored on disk, and they expand or shrink dynamically. An insertion in a bucket that is full causes the bucket to split into two buckets and the records are redistributed among the two buckets. Dynamic and extendible hashing do not require an overflow area. 3 Types of Single-level Indexes One form of an index: a file of entries \u003cfield value, ptr to record\u003e, which is ordered by field value The index is called an access path on the field ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:4:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.1 Primary Indexes Defined on an ordered data file The data file is ordered on a key field Includes one index entry for each block in the data file; the index entry has the key field value for the first record in the block, which is called the block anchor A similar scheme can use the last record in a block ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:5:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.2 Clustering Indexes Defined on an ordered data file The data file is ordered on a non-key field Includes one index entry for each distinct value of the field; the index entry points to the first data block that contains records with that field value ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:6:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.3 Secondary Indexes A secondary index provides a secondary means of accessing a file for which some primary access already exists The secondary index may be on a candidate key field or a non-key field There can be many secondary indexes for the same data file. The index is an ordered file with two fields. The first field is of the same data type as some non-ordering field (ie.,the indexing field) of the data file. The second field is either a block pointer or a record pointer If we include one entry for each record in the data file, then it is called a dense index ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:7:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.4 Multi-level Indexes Because a single-level index is an ordered file, we can create a primary index to the index itself ; in this case, the original index file is called the first-level index and the index to the index is called the second-level index 4 B-Trees and B+-Trees as Dynamic Multi-level Indexes In B Tree and B+ Tree data structures, each node corresponds to a disk block Each node is kept between half-full and completely full [An insertion into a node that is not full is quite efficient; if a node is full the insertion causes a split into two nodes] [If a deletion causes a node to become less than half full, it must be merged with neighboring nodes] In a B tree, pointers to data records exist at all levels of the tree In a B+ tree, all pointers to data records exists at the leaf-level nodes Internal pointer must point to a block A search tree of order $p$ is a tree such that each node contains at most $p−1$ search values and $p$ pointers Each internal node has at most $p$ tree pointers, $p-1$ value(s). Each internal node, except the root, has at least $⎡(p/2)⎤$ tree pointers, $⎡(p/2)⎤-1$ value(s). The root node has at least two tree pointers if it is an internal node. During the insertion, the node has to be splited when it is full. During the deletion, the node has to be merge when it is too small (number of value \u003c $⎡(p/2)⎤-1$). Normally, we choose the left leaf node of the same subtree to merge. (When there exists right or left leaf node within a same subtree, it should be different results.) 5 Physical Database Design Decisions 5.1 Physical Database Design Decisions Denormalization as a design decision for speeding up queries The goal of normalization is to separate the logically related attributes into tables to minimize redundancy and thereby avoid the update anomalies that cause an extra processing overheard to maintain consistency of the database. The goal of denormalizationis to improve the performance of frequently occurring queries and transactions. (Typically the designer adds to a table attributes that are needed for answering queries or producing reports so that a join with another table is avoided.) ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:8:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"5.2 Tuning Goal: To make application run faster To lower the response time of queries/transactions To improve the overall throughput of transactions Tuning Index Tuning Queries 学习笔记，仅供参考 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:9:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Integrity Constraints \u0026 Normal Forms 1 Key constraints Superkey of R: A set of attributes SK of R such that no two tuples in any valid relation instance r(R) will have the same value for SK. That is, for any distinct tuples t1 and t2 in r(R), t1[SK] \u003c\u003e t2[SK]. Candidate key of R: A “minimal” superkey; that is, a superkey K such that removal of any attribute from K results in a set of attributes that is not a superkey. Primary key of R: choice by the DB designer when there are more than one candidate key 2 Domain/Entity integrity constraints No “NULL” value for particular attributes Must be “UNIQUENESS” 3 Referential integrity constraints(Foreign key constraints) Two relation constraints (single relation above) To ensure that a value appears in one relation also appears in another relation. Implies “subset dependency” relationship between 2 sets of attributes in 2 tables Supplier relation is a foreign table of Shipment When to check integrity constraints? INSERT, DELETE, MODIFY the tuple 4 Functional Dependency FD is a particular kind of constraints Definition R is a relation schema, and $\\alpha \\subseteq R$, $\\beta \\subseteq R$, then $$\\alpha \\to \\beta$$ for all pairs of tuples tq and t2 in any legal relation instance r(R), we have $$t1[\\alpha]=t2[\\alpha]\\to t1[\\beta]=t2[\\beta]$$ As a result, FD can be used to identify and find primary key. ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:0:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"4.1 Inference Rules for FDs Given a set of FDs $F$, we can infer additional FDs that hold whenever the FDs in $F$: IR1 - Reflexive: If $Y$ is a subset of $X$, then $X\\to Y$ IR2 - Augmentation: If $X\\to Y$, then $XZ\\to YZ$, ($XZ$ stands for $X \\cup Z$) IR3 - Transitive: If $X\\to Y$ and $Y\\to X$, then $X\\to Z$ Closure of a set $F$ of FDs is the set $F^+$ of all FDs that can be inferred from $F$ Equivalence of two sets $F$ and $G$ of FDs Every FD in $F$ can be inferred from $G$ Every FD in $F$ can be inferred from $G$ Hence, $F$ and $G$ are equivalent if $F^+$ = $G^+$ 5 Relational Database Design ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:1:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.1 First Normal Form (1NF - 第一范式) A relation R is in 1NF if and only if all underlying domians cantain atomic(indivisible) value only atomic: an attribute can not be decomposed, like, address can be decomposed to province, city, road number, door number, etc. Problem Insert Anomalies Inability to represent certain information Eg, cannot enter “Supplier and City” info until Supplier supplies at least one part(P#) Delete Anomalies Deleting the “only tuple” for a supplier will destroy all the information about that supplier Update Anomalies “S# and City” could be redundantly represented for each P#, which may cause potential inconsistency when updating a tuple Solution(2NF) Replace original table by two sub-tables(Normalization) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:2:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.2 Second Normal Form (2NF - 第二范式) A relation R is in 2NF if amd only if it is in 1NF and every non-key attributes is fully dependent on any candidate/primary key(include that nonprime attribute is transitively dependent on the primary key) R(I,C,D,N) FD:{I-\u003eC, I-\u003eD, CD-\u003eN, IO-\u003eG} R is 2NF I is a candidate key C, D, N are fully (transitively) dependent on I, which can be treated as CD-\u003eN \u003c==\u003e I-\u003eN There is only one type of data stored a particular table, rather a combined-type data. Both relations are in 2NF in the above case. Solution(3NF) Replcae second table by two sub-tables SC(S#,City) CS(City,Status) Keep SP(S#,P#,Qty) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:3:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 Third Normal Form (3NF - 第三范式) A relation R is in 3NF if and only if it is in 2NF and every non-key attribute is non-transitively dependent on any candidate key. Some redundancy still exists Solution Replace original SSP by two sub-tables SS(S#,Sname) SP(S#,P#,Qty) [or,SP(Sname,P#,Qty)] ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:4:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 BCNF - BC范式 A relation R is in BCNF if and only if every determinant (left-hand side of an FD) is a candidate key. 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 参考 学习笔记，仅供参考 ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:5:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Relational Algebra ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:0:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1 SELECT σ and PROJECT π ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.1 SELECT SELECT operation (denoted by σ): Form of the operation: $σ_{c}(R)$ Selects the tuples (rows) from a relation R that satisfy a certain selection condition c. The condition c is an arbitrary Boolean expression on the attributes of R Resulting relation has the same attributes as R. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.2 PROJECT PROJECT operation (denoted by π): Form of the operation: $π_{L}(R)$ Keeps only certain attributes (columns) from a relation R specified in an attribute list L. Resulting relation has only those attributes of R specified in L(subtable of R). ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2 Select \u0026 Project Not allow any duplicated for a combined attribute value (e.g. $\\pi_{Sex,Salary}$ not allow the same combined attribute(Sex,salary), so the (F,25000) appears only once) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.1 Combined Select and Project Operation Several operations can be combined to form a relational algebra expression (query) EX: Retrieve the names and salaries of employees whon work in department 4 $π_{FNAME,LNAME,SALARY}(σ_{DNO=4}(EMPLOYEE))$ We also can specify explicitly: DEPT4_EMPS$\\leftarrow$$σ_{DNO=4}(EMPOYEE)$ R$\\leftarrow$ $π_{FNAME,LNAME,SALARY}$(DEPT4_EMPS) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.2 Rename ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1 Set Operation For $\\cap, \\cup, - $ The operand must have the same number of attributes The domain of corresponding attributes must be compatible(union compatibility) The resulting relation for $\\cap, \\cup, -$ has the same attribute names as the first relation R1 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1.1 CARTESIAN PRODUCT R(A1,A2,A3,…,B1,B2,B3,…)$\\leftarrow$R1(A1,A2,A3,…,Am) X R2(B1,B2,B3,…,Bm) If R1 has n1 tuples and R2 has n2 tuples, then R will have $n1*n2$ tuples. CARTESIAN PRODUCT is a meaningless operation on its own. It can combine related tuples from two relations if followed by the appropriate SELECT operation. The table EMP_DEPENDENTS has (3 x 7)21 tuples. To find the tuple which ESSN=SSN ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1 JOIN OPERATION ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.1 Equal Join and Theta Join Theta Join: Similar to a Cartesian Product followed by a Select. The condition c (often use θ) is called a join condition. Equal Join: The join condition c includes one or more equality conparisons involving arrtibutes from R1 and R2. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.2 Natural Join There shoule be some column have same attribute(s) Based on the same value of attributes, adding two table tigether directly Delet the column which has same attribute value 学习笔记，仅供参考 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Rational Data Model (record-based logical model) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:0:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.1 Basic structure Relations: Data stored as tables (called relations); each has a unique name A relation consists of rows (called tuples) and columns (called attributes) Attributes: An attribute has a “domain” Record: Each row/tuple in a relation is a record (an entity) Each attribute in a relation corresponds to a particular filed of a record DB Schema: relatively static, the whole structure DB instance: dynamic, data \u0026 structure ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:1:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.2 Key Candidate and primary keys are also defined by relational data model Super keys are similar to candidate/primary keys, but are not required to be minimal. (可以有其他属性) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:2:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.3 Characteristic of Relations Ordering of tuples in a relation r(R): The tuples are not considered to be ordered, even though they appear in order in the table form. Ordering of attributes in a relation schema R (and of values within each tuple): We will consider the attributes in R(A1, A2, …, An) and the values in t=\u003cv1, v2, …, vn\u003e to be ordered . Values in a tuple: All values are considered atomic (indivisible). A special null value is used to represent values that are unknown or inapplicable to certain tuples. Can a key attribute contain NULL values? Why? No, since a key attribute is a unique data to identify an entity in an entity set, if the key is null, which is meaningless. 2 ER vs. Rational Data Model ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:3:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1 Mapping ER Diagrams into Tables ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.1 Repersentation of Entity(Strong) sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:1","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.2 Repersentation of Weak Entity sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:2","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.3 Repersentation of M:N Relationship Sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:3","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.4 ER to relational schema Relation Table \u0026 Entity Table Relation table Strong relation primary keys of connecting entities relation attributes(if any) Weak relation primary keys of connecting strong entities all attributes of all weak entities — — Entity table Strong entity all attributes (sign the key attribute(s)) Weak entity all primary keys of corresponding strong entity — ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:4","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.2 (min,max) notation (min,max) notation replaces the cardinality ratio(1:1,1:N,M:N) and single/double-line notation for participation constraints; Definition: For EACH entity e in E, e MUST participate in at least $min$ and at most $max$ relationship instances in R at any point in time. Conver it into English: for a particular entity(e.g. Stundet A in Student Entity), MUST appear(participate) in at most $max$ \u0026 at least $min$ tuples in the table(relation R). As a result For $min$ $min = 0\\to$ partial participation - single line, not all entities participate $min\u003e0\\to$ total paricipation - double line, all entities MUST appear in rows For $max$ For a entity, it MUST appear in at most $max$ rows in a table [Example] Translation between Cardinality ratio and (min,max) notation: Cardinality ratio 1:1 $\\to$ (min,max): $(x,1)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example: ID === HAS === Student Cardinality ratio 1:1: double lines mean total participation For every ID, it MUST be hold by one and only one student For each student, he/she MUST has one and only one ID ID =(1,1)= HAS =(1,1)= Student (min,max) notation: in HAS tabke Each student MUSt appear in the table one and only one row Each ID MUSt appear in the table one and only one row Cardinality ratio 1:N $\\to$ (min,max): $(x,N)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Cardinality ratio N:1 $\\to$ (min,max): $(x,1)$;$(N,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example Employee === WORKS_FOR === Department Cardinality ratio 1:N: double lines mean total participation One employee must work for one and only one department One department must has at least one employee working for it (min,max) notation: =(1,1)= WORKS_FOR =(1,N)= Department Each employee MUST appear in the table one and only one row Each department MUST appear in the table at least one row, at most N rows Cardinality ratio M:N $\\to$ (min,max): $(x,N)$;$(x,M)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation 3 SQL ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:5:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.1 Basic syntax (structure) of SQL SELECT [DISTINCT] attribute1,... FROM table1 [name1], tabel2 [name2],... [WHERE requirement] [GROUP BY (attribute) HAVING requirement]; [Example] Following relational schema: Customer (cname, street, city) Branch (bname, assets, b-city) Borrow (bname, loan#, cname, amount) Deposit (bname, acct#, cname, balance) E1: Find all customers of the Sai Kong branch (SELECT cname FROM Deposit WHERE bname = 'Sai Kong') -- 注意是单引号 UNION -- not only Deposit customres, but borrow customers (SELECT cname FROM Borrow WHERE bname = 'Sai Kong'); E2: Find the name and city of all customers having a loan at the Sai Kong branch SELECT DISTINCT Customer.cname,city FROM Borrow,Customer WHERE Borrow.cname = Customer.cname AND Borrow.bname = 'Sai Kong'; E3: Find the names of all customers whose street has the substring ‘Main’ included SELECT cname FROM Customer WHERE Customer.street LIKE '%Main%'; E4: Find all customers who have an account at some branch in which Jones has an account SELECT DISTINCT S1.cname FROM Deposit S1 WHERE S1.bname IN (SELECT bname FROM Deposit S2 WHERE S2.cname = 'Jones') AND S1.cname != 'Jnoes'; SELECT DISTINCT S2.cname FROM Deposit S1,Deposit S2 WHERE S1.cname = 'Jnoes' AND S1.bname = S2.bname AND S1.cname != S2.cname; E5: Find branches having greater assets than all branches in N.T. SELECT B1.bname FROM Branch B1 WHERE B1.assets \u003e ALL (SELECT B2.assets FROM Branch B2 WHERE B2.b-city = 'N.T.' ); SELECT B1.bname FROM Branch B1 WHERE NOT EXISTS (SELECT * FROM Branch B2 WHERE B2.assets \u003e= B1.assets AND B2.b-city = 'N.T.' ); E6: Find names of all branches that have greater assets than some branch located in Kowloon SELECT bname FROM Branch WHERE assets \u003e SOME (SELECT assets FROM Branch WHERE b-city = 'Kwoloon'); SELECT bname FROM Branch B1,Branch B2 WHERE B1.assets \u003e B2.assets AND B2.b-city = 'Kwoloon'; E7: Find all customers who have a deposit account at allbranches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE (SELECT T.bname FROM Deposit T account WHERE S.cname = T.cname) -- the set of branches he/she has a deposit account CONTAINS (SELECT bname FROM Branch WHERE b-city = 'Kowloon'); -- the set of branches on Kwoloon E8: Find all customers of Central branch who have an account there but no loan there SELECT C.cname FROM Customer C WHERE EXISTS (SELECT * FROM Deposit D WHERE D.cname = C.cname AND D.bname = 'Central') AND NOT EXISTS (SELECT * FROM Borrow B WHERE B.cname = C.cname AND B.bname = 'Central'); E9: Find all customers who have a deposit account at ALL branches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE NOT EXISTS( (SELECT bname FROM Branch WHERE b-city = 'Kowloon') MINUS (SELECT T.bname customer S FROM Deposit T WHERE S.cname = T.cname)); E10: List in alphabetic order all customers having a loan at branches in Kowloon SELECT DISTINCT cname FROM Borrow WHERE b-city = 'Kowloon' ORDER BY cname; --By default, in ascending order. E11: List the entire borrow table in descending order of amount, and if several loans have the same amount, order them in ascending order by loan# SELECT * FROM Borrow ORDER BY amount DESC, loan# ASC; -- when the \u003camount\u003e is the same, order aomunt by \u003cloan#\u003e in ascending, and so on. ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:6:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.2 NULL Value All comparisons involving Null become FALSE!!! A modification is permitted through a view ONLY IF the view is defined in terms of ONE base/physical relation(whether all the values of tuple are full). In most SQL-based DBMSs, the special keyword NULL may be used to test for a null value. [like] SELECT c-name FROM Deposit WHERE balance IS NOT NULL; ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:7:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.3 Aggregate Function Compute functions on groups of tuples using the group by clause Tuples with the same value on all attributes in the group by clause are placed in one group Aggregate function includeds: avg, sum, min, count, max E1: Find the average account balance at each branch: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name; E2: If only interested in branches where average balance is \u003e $12000: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name HAVING AVG(balance) \u003e 12000; E3: Find those branches with the highest average balance: SELECT b-name FROM Deposit GROUP BY b-name HAVING AVG(balance) = SELECT MAX(AVG(balance)) FROM Deposit GROUP BY b-name); E4: Find the average balance of all depositers who live in Laguna city and have at least 3 accounts: SELECT AVG(balance) FROM Deposit, Customer WHERE Deposit.c-name = Customer.c-name AND city = 'Laguna' GROUP BY Deposit.c-name HAVING COUNT(DISTINCT acct#) \u003e= 3; 学习笔记，仅供参考 ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:8:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:0:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.1 What is Database(DB)? A non-redundant, persistent(like store in hard disk) collection of logically related records/files that are structured to support various processing and retrieval needs. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:1:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.2 Database Management System A set of software programs for creating, storing, updating, and accessing the data of a DB. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:2:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.3 Basic concept and terminologies instance (compared to the instance in oop) the collection of data (information) stored in the DB at a particular moment (ie, a snapshot) The data in the database at a particular moment in time is called a database state or snapshot. It is also called the current set of occurrences or instances in the database. scheme/schema the overall structure (design) of the DB – relatively static ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:3:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.4 Data Abstraction: 3-level architecture Internal/Physical Level: the complete details of data storage and access paths for the database. (i.e., SSD,Cloud,disk)(how data are actually stored) Internal level has an internal schema, which describes the physical storage structure of the database. Conceptual Level: which describes the structure of the whole database. For a 2D array, it will be stored as a “table” in database. It hides the detail of internal level.(what data are actually stored) The conceptual schema hides the details of physical storage structures and concentrates on describing entities, data types, relationships, user operations, and constraints.(data model) External Level: It only privides the data which the user wants and hide the rest of the datbase. Consider a two-dimensional integer array of size n*m The physical level would simply be n × m (probably consecutive) storage locations The conceptual level is a grid of boxes, each possibly containing an integer, which is n boxes high by m boxes wide. There are $2^{n×m}$ possible views (external level). For example, a view might be the entire array, or may be a part of array. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:4:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.5 Data Independence The ability to modify a schema definition in one level without affecting a schema in the next higher level Physical data independence: capacity to change the internal schema without having to change the conceptual schema Logical data independence: the capacity to change the conceptual schema without having to change external schemas or application programs. DB System Architecture 2 The Entity-Relationship Model(实体关系模型) ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:5:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1 Basic Definition ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.1 ER模型的作用 数据库设计的第一步是需求分析阶段，也是最重要的一步 概念建模也就是ER建模,将需求以ER图的方式进行可视化 ER图可以描述一个数据库的逻辑结构 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.2 ER模型的组成 2.1.2.1 entity entity(实体): a distinguishable object with an independent existence 一个entity可以是具体的(如：人，书，CityU), 也可以是抽象的(如：假期) entity set: a set of entities of the same type Like: Student Bank…… 2.1.2.2 attribute attribute(属性): 一个entity用一组attributes来表示，每一个attribute有一个对应的值，比如一个人可以有name，SSN，gender，phone number等attributes Different type of Attributes: Simple: Each entity has a single atomic value for the attribute. For example SSN or Sex Composite: The attribute may consist of several components. For example, Name(FirstName, MiddleName, LastName). Multi-valiue: An entity may have multiple values for that attribute. For example, Color of a CAR, denoted as {Color}. In general, composite and multi-valued attributes may be nested. Domain: 一个attribute的domain是这个attribute值的有效范围 Formally, an attribute A is a function which maps from an entity set E into a domain D: $$A: E\\to D$$ 2.1.2.3 relationship Relationship: the relationship(association) among several entities An attribite $A:E\\to D$ is a “simplified form of a relationshihp” if we allow D to be an Entity Set, then A becomes a relationship A realtionship can carry attribute Example: Patrick takes cs2450 with a grade of B+. “takes” is relationship bteween “Patrick” and “CS2450”, “B+” is the attribute of this relationship, since “B+” is neither the attribute of “Patrick” nor “CS2450”, which is “Patrick takes cs2450” The degree of a relationship set/type is the number of participating entity sets/types. Both MANAGES and WORKS_ON are binary relationships. In general, an n-ray relationship is not equialent to n binary relationships. The relationship has participation constraint partial participation: single line (not all entity participate) total participation: double line (every entity participate) (min,max) notation for relationship Specified on each participationof an entity set E in a relationship set R Specifies that each entity e in E participates in at least min and at most max relationship instances in R Default (no constraint): min=0, max=n ! Must have: $min\u003c=max,min\u003e=0,max\u003e=1$ (a) is not equivalent to (b) but to (c). ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:2","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3 ER diagram ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3.1 ER图的基本构成 Rectangles(正方形): Entity Sets Ellipses(椭圆形): Attributes Diamonds(菱形): Relationship Sets Lines: Attributes to Entity/ Relationship Sets or, Entity Sets to Realtionship Sets 不同的键(Key): to distinguish individual entities or relationships Superkey (超键): a set of one or more attributes which, taken together, identify uniquely an entity in an entity set 在关系中能唯一标识元组的属性集称为关系模式的超键 Example: 一般来说，学号是标识学生实体的唯一标识，所以该元组的超键就为学号。我们可以将学号和其他属性结合起来，(学号，性别)，(学号，年龄)等也为超键。 Candiaite key(候选键): minimal set of attributes which can identify uniquely an entity in an entity set 最小的超键，仅包括独一标识实体所必需得最小属性的数量，即不含多余属性的超键为候选键 Example: stident ID identify a student, but Name is not a candidate key 候选键是超键的子集 Primary key(主键): a candidate key chosen by the DB designer to identify an entity in an entity set 是从候选码(candidate key)中人为挑选的一个 Foreign key: FK is a set of attributes of R1, which refers to the PK(primary key(s)) of R2 Domain of FK should be the same as PK t1[FK] in R1 either occurs as a value of t2[PK] in R2 or is NULL. 实体间的联系 Integrity Constraints One-to-one(一对一): 例如班级和班长之间就是一对一联系，一个班级只有一个班长 One-to-many(一对多/多对一): 例如一个班级有一个辅导员，但担任辅导员的老师可以同时担任其他班级的辅导员，所以辅导员和班级之间就是一对多联系 Many-to-many(多对多): 例如一个学生可以学习多门课程，每门课程也可以有多个学生，那么学生和课程之间的关系就是多对多联系 Weak Entity Set An entity set that does NOT have enough attributes to form a primary/candidate key 学习笔记，仅供参考 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["我的博客"],"content":"Java学习记录（一） JAVA 学习 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:0:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.JAVA语言基础 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1Java中的数值类型 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1.1 数值类型 1.1.2 数据类型转换 顾名思义，即为将一个值从一个类型转换为另一个类型的过程。例如，可以将String类型的数据“457”转换为数值型，也可以将任意类型的数据转换为String类型。 如果从低精度数据类型向高精度数据类型转换，则永远不会溢出，即更加安全，并且总是成功，；而把高精度类型数据转换为低精度类型数据时，被可能存在数据的丢失，又可能失败。 数据转换有两种形式，隐式转换（由低精度转换为高精度）与显式转换（由高精度转换为低精度）。 精度由低到高：（不包含逻辑类型与字符类型） byte \u003c short \u003c int\u003c long \u003c float \u003c double 例： int x =50; float y = x; //由于浮点型精度高于整数型，所以此转换为隐式转换，结果为50.0 当我们需要把高精度的变量赋给低精度的变量时，必须使用显示类型转换运算（又称强制类型转换）。 例: int a = (int)45.23; // 输出为45 long y = (long)456.5F; // 输出为456 int b = (int)'d'; // 输出为100 除布尔型以外，其他基本类型数据都能进行显型类型转换。 1.1.3 运算符 在Java中有着算数运算符，关系运算符，位运算符，逻辑运算符，赋值运算符以及其他运算符。在此，我们主要讨论自增、自减运算符和位运算符。 b = ++a; b = a++; 上述两行代码看似差不多，实际上有很大区别：第一行翻译为先将a的值+1，然后再赋给b；第二行则是先将a的值赋给b，a的值再+1。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.2类中的变量类型 局部变量：在方法，构造方法或者语句块中被定义的变量。方法结束后，变量会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量，可以被类中方法、构造方法等语句块访问，没有static修饰。 类变量：类变量也申明在类中，方法体之外，但必须声明为static类型。 例： public class Variable{ static int allclicks = 0; // 类变量（静态变量） String str = \"hello world\"; // 实例变量（成员变量） public void method(){ int i = 0; // 局部变量 } } 在Java中，所有变量在使用前都必须声明。 例： int a,b,c; // 声明了3个int型整数：a，b，c。 int d = 3,e,f = 5; // 声明三个整数并赋予初值。 byte z =22; // 声明并初始化。 char x = 'x'; // 变量x的值是字符‘x’。 double pi = 3.14159;// 声明了pi。 既然有变量，那就会有常量。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.3Java常量 常量就是一个固定值。他们不需要计算，直接代表相应的值。 常量指不能改变的值，在Java中用final标志： final double PI = 3.1415927; ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:4","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.4构造方法 每个类都有构造方法。 在创建一个对象时，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 例： public class Puppy(){ public Puppy(){ } public Puppy(String name){ } } 上述代码类的构造方法为Puppy(),返回值为字符串类型的‘name’，即调用该构造方法时，Puppy(\"name\"), ’name’ 即为用户想输入的小狗的名字。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:5","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.5创建对象 在Java中使用关键字 new 来创建一个新的对象。 声明：声明一个对象，包括对象名称和类型。 实例化：使用关键字 new 来创建一个对象。 初始化：使用 new 创建对象时，会调用构造方法(constructor)初始化对象。 例： public class Puppy(){ public Puppy(String name){ System.out.println(\"Puppy name is : \"+ name); } public static void main(String []args){ Puppy myPuppy = new Puppy(\"tommy\"); // 上述语句创建了一个Puppy对象 } } 代码块的结果会显示为：Puppy name is tommy ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:6","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.6访问实例变量和方法 /*实例化对象*/ ObjectReference = new Constructor(); /*访问其中的变量*/ ObjecReference.variableName; /*访问类中的变量*/ bjecReference.MethodName(); public class Puppy(){ int puppyAge; //定义了一个名为puppyAge的int型成员变量 public Puppy(String name){ System.out.println(\"Passed Name is: \"+ name); } public void setAge(int age){ puppyAge = age; } public int getAge(){ System.out.println(\"Puppy's age is: \" + puppyAge); return puppyAge; } public static void main(String []args){ /*创建对象*/ Puppy myPuppy = new Puppy(\"tommy\"); /*调用方法来设定age*/ myPuppy.setAge(2); /*调用另一个方法来获取age*/ myPuppy.getAge(); /*访问成员变量*/ System.out,println(\"Variable Value: \" + myPuppy.puppyAge); } } 结果为： Passed name is: tommy Puppy’s age is: 2 Variable Value: 2 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:7","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"2.JAVA修饰符 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类) public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"默认访问修饰符-不使用任何关键字 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 如下例，变量和方法的声明可以不适用任何修饰符： String version = \"1.5.1\" boolean processOder(){ return true } ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"私有访问修饰符-private 私有访问修饰符是最严格的访问级别，所以被声明为private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为私有访问类型的变量只能通过类中公共的getter 方法被外部类访问。 Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 下面的类使用了私有访问修饰符private public class Logger { private String format; public String getFormat() { return this.format; } public void setFormat(String format) { this.format = format; } } Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 public方法：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）。 公有访问修饰符-public 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。最常见的公有访问即为public static void main(String []args){...}。Java 程序的main()方法必须设置成公有的，否则Java 解释器将不能运行该类。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"受保护的访问修饰符-protected 被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能被不同包中的字类访问。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"非访问修饰符 例如static修饰符，用来创建方法和类变量。 final修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承重新定义，修饰的变量是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。 -synchronized和volatie修饰符，主要用于线程的编程。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"final修饰符(关键字) final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。 final修饰符通常和static修饰符一起是用来创建常量。 例： public class Test{ final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = \"Manager\"; public void changeValue(){ value = 12;//将输出一个错误 } } 由于value的值已经被final定义过，所以无法被改变。 类中的final方法可以被字类继承，但是不能被字类修改。fianl类不能被继承，没有类能够继承final类的任何特性。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"static修饰符 静态变量： static关键字用来声明独立于对象的静态变量，静态变量也被称为类变量。局部变量不能被声明为static变量。 例： public class InstanceCounter{ private static int numInstances = 0; protected static int getCount(){ return numInstances; } private static void addInstance(){ numInstances++; } InstanceCounter(){ InstanceCounter.addInstance(); } public static void main(String []args){ System.out.println(\"Starting with \"+:InstanceCounter.getCount()+ \"instances\"); for (int i = 0; i \u003c 500; i++){ new InstanceCounter(); } System.out.println(\"Created \"+ InstanceCounter.getCount()+\" instances\"); } } 结果如下： Started with 0 instances Created 500 instances 引用时请标明出处 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"Java学习记录（二） Java 数据类型 变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。 内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有着两大数据类型，内置数据类型和引用数据类型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:0:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"内置数据类型 其中包括6种数字类型（4个整数型和2个浮点数型），一种字符类型，及一种布尔型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"数字类型 byte： byte的数据类型是8位、有符号的，以二进制补码（2‘s）表示的整数。 最小值是-128（-2^7） 最大值是127（2^7-1） 默认值是0 byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short: short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15） 最大值是 32767（2^15 - 1） Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一 默认值是0 例子：short s = 1000，short r = -20000。 int: int 数据类型是32位、有符号的以二进制补码表示的整数 最小值是-2^31（-2147483638） 最大值是2^31-1（-2147483637） 一般的整型变量默认为int型 默认值是0 例子：int i = 100； long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）最大值是 9,223,372,036,854,775,807（2^63 -1） 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double: double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数； 浮点数的默认类型为 double 类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char: char 类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（十进制等效值为 0）； 最大值是 \\uffff（即为 65535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’; 测试","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:1","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"}]