[{"categories":["学习笔记"],"content":"这篇文章展示了系统编程的学习记录","date":"2023-09-04","objectID":"/posts/sp/l/","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"这篇文章展示了系统编程的学习记录 System Programming ","date":"2023-09-04","objectID":"/posts/sp/l/:0:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0 Background ","date":"2023-09-04","objectID":"/posts/sp/l/:1:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.0 What is Operating System? An operating system is an intermediary between a computer user and the hardware Make the hardware convenient to use Manages system resources Use the hardware in an efficient manner ","date":"2023-09-04","objectID":"/posts/sp/l/:1:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.1 Types of Operating Systems Batch Single CPU User submits large number of tasks at one time OS decides what to run and when Back-to-back single tasking Time Sharing Multiple users connected to a single CPU Many user terminals Multiple tasks run simultaneously using time-sharing, giving users the feeling of having multiple dedicated CPUs running in parallel Parallel Multiple CPUs closely coupled to form one computer Higher throughput and better fault tolerance Each CPU can be running batch tasking or time-sharing multitasking Distributed Multiple CPUs loosed coupled via networking Real-time Very strict response time requirements Periodical tasks, every job of a task has a strict deadline ","date":"2023-09-04","objectID":"/posts/sp/l/:1:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.2 Single Tasking System vs. Multi-tasking System Single Tasking System Each task, once started, executes to its very end without any interruption from other task(s). Simple to implement: sequential boundaries between tasks, and resource accesses. Few security risks Poor utilization of the CPU and other resources Example: MS-DOS Multi-tasking System Very complex Serious security issues How to protect one task from another, which shares the same block of memory Much higher utilization of system resources Support interactive user/physical-world interface Example: Unix, Windows NT ","date":"2023-09-04","objectID":"/posts/sp/l/:1:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.3 Hardware Basics OS and hardware closely tied together Basic hardware resources:CPU, Memory, Disk, I/O 0.3.1 CPU CPU controls everything in the system It is involved in any work needs to be done Most precious resource This is what you are paying for Users would usually prefer high utilization (from useful work) Only one process running on a CPU at a time Millions or even billions of machine instructions per second Getting faster all the time 0.3.2 Memory Limited capacity Never enough, and expanding over the years Temporary (volatile) storage Electronic storage Fast, random access Any process to run on the CPU must first be loaded into memory 0.3.3 I/O Many I/O devices Keyboard, mouse, monitor, printer etc. Most I/O devices are painfully slow Need to find ways to deal with high I/O latency Like multiprogramming ","date":"2023-09-04","objectID":"/posts/sp/l/:1:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.4 Protection and Security OS must protect itself from users Reserved memory only accessible by OS OS may protect users from one another ","date":"2023-09-04","objectID":"/posts/sp/l/:1:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.5 Interrupts Modern OSs are event driven Event is signaled by special hardware signal sent to the CPU Two types of events Hardware Interrupts: caused by external hardware, can occur at anytime Software Interrupts (aka Exceptions, Traps): caused by software, synchronous to CPU clock 0.5.1 Interrupt Philosophy Use an interrupt table and special hardware to redirect CPU execution By the end of interrupt handling, the CPU can resume the interrupted process 0.5.2 Interrupt Table Large array of addresses indicating what code to run (interrupt routine) for a given interrupt Each interrupt has a corresponding number associated with it On Intel processors this is from 0 to 255 This gives fixed size interrupt table Use the interrupt number to index into the array to find out what code to run (interrupt routine) 0.5.3 Hardware to Support Hardware Interrupts Programmable Interrupt Controller (PIC) Connected to I/O devices via Interrupt Request Lines (IRQ) or Bus (e.g. PCI Express) PIC connected to the CPU by a special line or bus CPU\u003c==\u003ePIC\u003c==\u003eI/O devices \u003c==\u003e can be special signals via dedicated wire lines (IRQ), or special sequences of back-and-forth messages via bus(es) (virtual IRQ) 0.5.4 IRQ Architecture 0.5.5 Hardware Handling of Interrupts (Conventional IRQ as an Example) After each instruction executes, CPU checks if the IRQ pin voltage has been raised If so 1. Sets the system into kernel mode (if not already there) 2. Determine interrupt number (from PIC or instruction) 3. Read appropriate interrupt table entry Special register contains base address of interrupt table Each entry in table is fixed size so easy to calculate where to look in memory (e.g. memloc = iptr + 8 * intNum) 4. Saves the process state to the stack (particularly, the program counter) 5. Saves error code to stack (if it exists) 6. Loads the program counter with the value stored in the interrupt table This starts the CPU executing in the interrupt routine ","date":"2023-09-04","objectID":"/posts/sp/l/:1:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.6 Peripheral Devices Input Devices Output Devices Storage (memory is usually not considered as a peripheral) 0.6.1 Peripheral Devices for Embedded Systems Embedded Systems: computer systems that do not look like conventional computer systems, e.g. mobile devices, devices tightly coupled with the physical world (i.e. cyber-physical systems). Input Devices: Sensors Output Devices: Actuators ","date":"2023-09-04","objectID":"/posts/sp/l/:1:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"0.7 Historical Perspective Application built on top of hardware Problems: Complexity: have to know the tedious low-level programming details of the hardware Inflexibility: when the hardware changes, the application has to change with it. Application built on top of OS Ideal: OS application programming interface (API) hides the complexity and heterogeneity of hardware programming. As long as the OS API remain the same, the hardware can change. Design goal conflict: Full exploitation of hardware features Versus Full platform independence and simple API Application built on top of OS Ideal: OS application programming interface (API) hides the complexity and heterogeneity of hardware programming. As long as the OS API remain the same, the hardware can change. Design goal conflict: Full exploitation of hardware features Versus Full platform independence and simple API Want to exploit more features of the hardware: Application + OS Want to be more platform independent and simpler API: Application + Virtual Machine (VM) Virtual Machine (VM) can hide the heterogeneity of OS APIs As long as the VM API remain the same, the OS (and hardware) can change, and the application can remain the same. ","date":"2023-09-04","objectID":"/posts/sp/l/:1:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"What is System Programming? Application programs (+ application layer libraries) Programs for direct interaction with users Compiler programs, assembler programs, linker programs Tools that convert application programs to executables Operating systems kernel programs Programs that interface other software with the hardware Layers of Programs (Development Time) Layers of Programs (Run Time) ","date":"2023-09-04","objectID":"/posts/sp/l/:2:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1 Unix ","date":"2023-09-04","objectID":"/posts/sp/l/:3:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.1 The Unix Philosophy Modular design A collection of simple tools, with limited well-defined functions File system Inter-process communication The tools can be easily composed (via \u003e, \u003e\u003e, \u003c, |,``) by a shell to accomplish complex tasks ","date":"2023-09-04","objectID":"/posts/sp/l/:3:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.2 Unix Kernel and System Calls Main duties process scheduling and management inter-process communication memory management file management network stack management date and time management system accounting security device management interrupt and exception handling Other parts of the Unix system, as well as user programs, request the kernel for various services through system calls A system call is an entry point into the kernel, typically packaged as a function call, as part of the OS API. a software interrupt (trap) switches the CPU hardware to the kernel mode execute kernel routines return kernel mode first, to the scheduler, check schedule of other tasks switches back(via scheduling*) to the user mode to resume the user application ","date":"2023-09-04","objectID":"/posts/sp/l/:3:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.3 Unix Commands and Utilities A large set of tools for various basic user level functions A vocabulary and a grammar, to combine basic user level functions to nearly arbitrary sophisticated functions Not part of the kernel, but a part of the OS Typically accessed via the Shell ","date":"2023-09-04","objectID":"/posts/sp/l/:3:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.4 Unix Shell A powerful command interpreter (a user level application) for Unix – accepts user text commands and carries them out Can combine various user level applications to serve more sophisticated functionalities ","date":"2023-09-04","objectID":"/posts/sp/l/:3:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.5 Unix Libraries \u0026 Device Drivers ","date":"2023-09-04","objectID":"/posts/sp/l/:3:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Features of Unix Portability Multi-user Operation Multitask Processing Hierarchical File System Powerful Shell Pipes Networking Robustness ","date":"2023-09-04","objectID":"/posts/sp/l/:3:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.6 Unix is Portable Unix is a relatively hardware independent OS. Various mechanisms (device driver, various C program interfaces inside of the kernel and to the user level) are designed to encapsulate the hardware specifics, facilitating porting between hardware platforms. One key to the portability is the device drivers, specific modules that encapsulate the hardware details from the other parts of the kernel and the user level. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.7 Unix supports multi-users and multi-tasking For a single user, time sharing can still support multi-tasking. Multiple users may run multiple tasks concurrently. Unix supports background processing, which allows a user to initiate a task “in the background” and then proceed to other activities. Unix time shares between the front-end commands and background jobs. Unix allows the creation of new tasks from an existing task. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.8 Unix has a hierarchical file system Unix files are organized into separate directories. Directories are themselves organized into a tree-like structure. There is one master directory, the so-called root directory, from which various sub-directories branch off. The hierarchical structure offers a maximum flexibility for grouping information in a way that reflects its natural structure. A single user’s data may be grouped by activity Data from many different users can be grouped according to corporate organization As a result, stored data is easier to locate and manage ","date":"2023-09-04","objectID":"/posts/sp/l/:3:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.9 Unix shell is powerful T he Unix shell supports a number of convenient features, such as: Redirection of application input and output, e.g. ls \u003e myfiles The ability to manipulate groups of files with a single command. Executing a sequence of commands stored in a text file, called a “shell script,” allowing us to build our own commands, which may be parameterized. Being used as a programming language that provides string-valued variables and control flow primitives including branching and iteration ","date":"2023-09-04","objectID":"/posts/sp/l/:3:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.10 Unix’s pipe is novel A pipe passes the standard output of one command directly to another command, to be used as its standard input, e.g. who | sort Allows any number of commands to be connected in a sequence, and automatically handles the data flow from one program to the next who | sort | lp Produces the same effect as if one large program, rather than several small ones, had been executed. Allowing the combination of several simple programs to perform more complex functions Eliminating the need for new software development. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:11","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.11 Unix supports networking Supports TCP/IP protocols, and provides a new OS abstraction, the socket, that allows application-level programs to access the Internet. The socket abstraction acts as an interface between application level programs and the underlying TCP/IP protocols. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:12","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"1.12 Unix is robust When encountered an error, a Unix program does not abort. Instead, the program receives a returned value indicating an error condition, and it is up to the program to check for the error and handle it. Typically, a returned error value is negative if the return type is int, or a NULL if the return type is a pointer. You can call the C library function perror() to output a message string to the standard error file, to further explain the error. ","date":"2023-09-04","objectID":"/posts/sp/l/:3:13","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Unix Demo Task 2: ls: list the files in the current directory ls -l: list the files in the current directory in long format ls -a: list the files in the current directory, including the hidden files ls -t: list the files in the current directory, sorted by time ls -lat: list the files in the current directory, including the hidden files, in long format, sorted by time cd: change the current directory .: the current directory ..: the parent directory cp: copy a file cp file1 file2: copy file1 to file2 cp file1 file2 file3 dir: copy file1, file2, file3 to dir cp -r dir1 dir2: copy dir1(all the content) to dir2 recursively mv: move a file mv file1 file2: move file1 to file2 mv file1 file2 file3 dir: move file1, file2, file3 to dir mv dir1 dir2: rename dir1 to dir2 rm: remove a file rm -rf dir: remove dir recursively and forcefully mkdir: make a directory mkdir dir: make a directory named dir who: show the users who are currently logged in whami: show the current user who -q: show the number of users who are currently logged in who -u: show the idle time of the users who are currently logged in cat: concatenate files and print on the standard output cat file: print the content of file on the standard output cat file1 file2: print the content of file1 and file2 on the standard output cat file1 file2 \u003e file3: concatenate file1 and file2, and write the result to file3 cat file1 file2 \u003e\u003e file3: concatenate file1 and file2, and append the result to file3 man: an interface to the on-line reference manuals man command: show the manual of command man -k keyword: search the manual for keyword man -f command: show the manual of command man -a command: show all the manual of command gcc: GNU project C and C++ compiler gcc file: compile file gcc file -o file: compile file and output the executable file to file gcc file1 file2 -o file: compile file1 and file2 and output the executable file to file Task 3: vi: a text editor vi file: open file in vi i: enter insert mode esc: exit insert mode, enter command mode Under command mode: :w: save the file :q: quit vi :wq: save and quit vi :q!: quit vi without saving h: move leftward; l: move rightward; j: move downward; k: move upward w: move rightward word by word; b: move leftward word by word dw: delete the word after the cursor u: undo the last command dd: delete the current line $: move to the end of the line; ^: move to the beginning of the line gedit: a text editor gedit file: open file in gedit Task 4: Shell output redirection who \u003e users: redirect the output of who to file users, overwriting(replace) the original content of users who \u003e\u003e users: append the output of who to file users Task 5: Shell input redirection wc \u003c users: redirect the content of users to wc, and count the number of lines, words, and characters in users wc -l: count the number of lines wc -l \u003c output.txt \u003e output1.txt: count the number of lines in output.txt, and write the result to output1.txt Task 6: write, compile, and run a C program vim hello.c: write a C program in vi gcc hello.c -o hello: compile the C program and output the executable file to hello ./hello: run the executable file External Task: pipeline - make a pipe among processes ls -l | wc -l: count the number of files in the current directory ls -l | grep \"hello\": list the files in the current directory whose name contains “hello” ls -l | grep \"hello\" | wc -l: count the number of files in the current directory whose name contains “hello” ","date":"2023-09-04","objectID":"/posts/sp/l/:4:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2 Unix Processes What is a process? What does a process look like in the system? When is a process created? By whom? How is a process created? In how many ways? When does a process stop? Can we wait for a process to die? What is a process called if it never die? ","date":"2023-09-04","objectID":"/posts/sp/l/:5:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.1 Common definition A process is an instance of a program in execution (the execution of the program has started but has not yet terminated). Process is dynamic while program is static. A process is the basic unit for competing the resources. In particular, it is the basic active entity to CPU scheduler. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.2 How to understand it? State of a computer at clock tick (i.e. discrete time) $i$: $S(i)$ = (register 1’s value, register 2’s value, …, 1st memory byte’s value, 2nd memory byte’s value, …, 1st hard disk byte’s value, 2nd hard disk byte’s value, …, peripheral 1’s register 1’s value, peripheral 1’s register 2’s value, …). State of an execution $e$ at clock tick $i$: $s(e, i)$ = (resources used by $e$ at $i$, state of the resources used by $e$ at $i$). A process is the time sequence of ${s(e, i)}$, where every two consecutive states $s(e, j)$ and $s(e, j+1)$ have causal relationship determined by the program logic and the OS. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.3 how to turn a program into a process? The program is read into memory. A unique process ID is assigned. OS kernel creates a process structure instance to record information related to this process. Necessary resources to run the program are allocated. The initial state $s(e,0)$ is set, which will trigger its next state $s(e, 1)$, which will trigger its next state $s(e,2)$, … determined by the program logic and the OS. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.4 Notion of threads (lightweight processes) A process is the time sequence of ${s(e, i)}$, where every two consecutive states $s(e, j)$ and $s(e, j+1)$ have causal relationship determined by the program logic and the OS. In older OSs, each process has its exclusive set of resources, even for processes that are related (e.g. sharing data). This is wasteful. Modern OSs propose the notion of “threads”. Threads are processes that have shared resources, typically created by a same ancestor process. Because the resource allocation is more thrifty, threads are also called “lightweight processes”. left: multi-processes - fork() right: multi-threads ","date":"2023-09-04","objectID":"/posts/sp/l/:5:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.5 What resources to share and what not to share? store and restore the register values partition the registers into different sets temporarily for threads ","date":"2023-09-04","objectID":"/posts/sp/l/:5:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.6 Thread realization and programming interface And at the user level, there is a de facto standard C thread programming interface: PThread (POSIX Thread). But different OSs (even OSs belonging to the Unix family) have different ways to realize the concepts and the PThread programming interface. For example, modern Linux no longer differentiate threads and processes, all are realized as copy-on-write (COW) processes (aka “task”). For example, every time the parent thread creates a new thread, in the Linux implementation, there is a parent COW process creating a child COW process. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.8 Process Image ","date":"2023-09-04","objectID":"/posts/sp/l/:5:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.9 Process management Besides its image, a process has its corresponding meta data (in kernel) for the OS to manage it, e.g. process ID. A Unix OS typically maintains a hierarchy of processes related by parent-child links: the process that requests to create another process is called the parent process, the created process is called the child process. A child process inherits all the properties of its parent when it is created, but can change after creation (even changing its code image). Process ID – integer PID Parent process ID – an integer PPID User process ID – an integer UID In Unix, each user has a unique user ID. Each process is associated with a particular user called the owner of the process, which executes the program. The owner has certain privileges with respect to the process. Use getpid, getppid, and getuid to determine the ID of the current, parent, and the owner. ps is the short for “process status”. ps lists your current processes ps –a lists more processes, including ones being run by other users and at other terminals (but not include the shells) ps –l prints longer, more information lines, including UID, PID, PPID, process status, etc. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.10 Related Portable OS Interface (POSIX) APIs The Portable Operating System Interface (POSIX) is a family of standards specified by the IEEE Computer Society for maintaining compatibility between OSs. Demo Task 2 getpid: get the process ID of the current process getppid: get the process ID of the parent process getuid: get the user ID of the current process #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e // Unix Standard void main (void){ printf(\"Process ID: %ld\\n\", (long)getpid()); printf(\"Parent ID: %ld\\n\", (long)getppid()); printf(\"Onwer user ID: %ld\\n\", (long)getuid()); } Result Demo Task3 fork(): create a new process Allocates a new chunk of memory and kernel data structure. Copies the parent process’s image and kernel data structure into the new process’s, with needed modifications (e.g.PID, PPID). Adds the new process to the set of “Ready” processes. Returns control back to both processes (by setting the program counter in the respective image, and leaving the processes to the scheduler). Return twice: once in the parent, once in the child. // demo 3 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork, mypid; mypid = getpid(); printf(\"Before: my pid is %d\\n\", mypid); ret_from_fork = fork(); sleep(1); printf(\"After: my pid is %d, fork() said %d\\n\", getpid(), ret_from_fork); } Result use man -S3 sleep to see the manual of sleep system call user man sleep to check sleep user command orphan process may happen since the parent process may terminate before the child process of the above code Demo Task 4 // demo 4 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork; printf(\"Before: my pid is %d\\n\", getpid()); if ((ret_from_fork = fork()) == 0) { fprintf(stderr, \"I am the child, ID = %ld\\n\", (long)getpid()); } else if (ret_from_fork \u003e 0) { fprintf(stderr, \"I am the parent, ID = %ld\\n\", (long)getpid()); } else { fprintf(stderr, \"Fork failed!\\n\"); } } Result Demo Task 5 In-class exercise: forking a chain of processes the child process will fork a child process, then previous child process will die; the new child process will fork a child process, then previous child process will die; … // demo 5 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if (childpid = fork()) break; //parent breaks out; child continues fprintf(stdout, \"This is process %ld with parent %ld, i = %d\\n\",(long)getpid(), (long)getppid(), i); } Result parallels@ubuntu-linux-20-04-desktop:~/Desktop/text$ the result above shows the parent process PID=164147 has terminated before the child process PID=164149 are created, so these two child processes become orphan processes, with parent process PID=1193 (the init process - user) For thr first fork(), the parent process will break out of the loop, and call fprintf(), then terminate. This parent process has the “full image” of whole c program. So when this process terminates, the whole c program terminates, and terminal will return parallels@ubuntu-linux-20-04-desktop:~/Desktop/text$ Demo Task 6 In -class exercise: forking a fan of processes #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if ((childpid = fork()) \u003c= 0) break; //child and error break out; parent continues fprintf(stdout, \"This is process %ld with parent %ld\\n, i = %d\",(long)getpid(), (long)getppid(), i); } Result the order can be different since the parent and child processes are running concurrently which is scheduled by scheduler the parent process of PID=187708 is PID=12244 (the bash process) the result above shows the parent process PID=187709 has terminated before the child process PID=187710 are created, so this child processes become orphan process, with parent process PID=1193 (the init process - user) The fork system call creates a copy of the calling process. However, many ap","date":"2023-09-04","objectID":"/posts/sp/l/:5:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.11 Process termination Upon termination of a process, the OS de-allocates the resources held by the process, updates the appropriate statistics, and notifies other processes, specifically these include: cancel pending timers and signals; release virtual memory spaces; release locks, closing open files; notifying the parent in response to a wait system call. What happens if the parent is not currently executing a wait()? The child process’s kernel management meta info (e.g. task struct) will remain there, though the child process image is gone. The child process hence becomes a zombie. A normal termination occurs if there was A return from main, An implicit return from main, A call to the C function exit, or A call to the _exit system call exit calls user-defined exit handlers and may provide additional cleanup before it invokes the _exit system call. exit takes a single, integer argument, called exit status, which will be made available to the parent process (which may be waiting). By convention, a zero means success, some non-zero value means something has gone wrong. 2.11.1 Abnormal process termination A process can terminate abnormally by calling abort, causing the SIGABRT signal to be sent to the calling process, or processing a signal that causes termination. A code dump may be produced. User-installed exit handlers will not be called upon abnormal termination. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.12 Background processes Recall that the shell is a command interpreter which Prompts for commands. Reads the commands from standard input, forks children to execute the commands, and waits for the children to finish. A user can terminate execution of a command by ctrl-c. Most shells interpret a command line ending with \u0026 as one that should be executed by a background process When a shell creates a background process, it does not wait for the process to complete before issuing a prompt and accepting additional commands. Cannot send ctrl-c to a background process via the command input. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:11","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"2.13 Daemons A daemon is a background process that normally runs indefinitely (have an infinite loop). Unix relies on many daemon processes to perform routine tasks pageout daemon handling paging, in.rlogind handling remote login requests, The web server daemon receiving http connection requests ftp daemon, mail daemon, … etc. Demo Task 11 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003csyslog.h\u003e #include \u003cstring.h\u003e #define MAX_I 100 void main (void){ pid_t pid, sid; FILE* p_output; int i = 0; pid = fork(); if (pid \u003c 0) exit(EXIT_FAILURE); if (pid \u003e 0) exit(EXIT_SUCCESS); umask(0); sid = setsid(); // create the daemon process if (sid \u003c 0) exit(EXIT_FAILURE); if ((chdir(\".\")) \u003c 0) // change the directory to the current directory exit(EXIT_FAILURE); printf(\"Daemon: Hello!\\n\"); // the child session will inherit the stdout from the parent, so it will still print out on the current terminal(\"parent\" session) close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); printf(\"Daemon: Goodbye!\\n\"); // `STDIN/OUT` are closed, the child session cannot access parent I/O, so it will not print out in current terminal while(1){ if ((p_output = fopen( “daemon_output.txt”, “a”)) != NULL){ fprintf(p_output, “%d\\n”, i++); i %= MAX_I; fclose(p_output); } sleep(3); } exit(EXIT_SUCCESS); } umask umask(0): set the file mode creation mask(umask) to 0, so that the file mode of the daemon output file is not restricted. umask() sets the calling process’s file mode creation mask to mask \u0026 0777, 7 means 111 in binary open() and mkdir() mkdir(): the mode of the created directory is (mode \u0026 ~umask \u0026 0777) mode is default mode e.g. umask(0) -\u003e mkdir() -\u003e 0777 \u0026 ~0 \u0026 0777 -\u003e 0777: the deafult mode will be remained setsid although setsid will move to another session, but the opened file is still be accessed the child process calls setsid() to create a new session and obtain a new session ID (SID). If setsid() fails (returns -1), the program exits with a failure status. The child process then changes the current working directory to the root directory using chdir(\".\"). If the chdir() call fails, the program exits with a failure status. child process closes the standard input, standard output, and standard error file descriptors. This is done to disconnect the daemon process from the terminal, as it no longer needs them. above code is a daemon process, which is terminal-realted not login-related. ","date":"2023-09-04","objectID":"/posts/sp/l/:5:12","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3 Unix File System What is a file in Unix? How many types of files? How are the files in a file system structured? How is a file represented in memory and disk? How to find the file using its name? How to access files from a Unix program? ","date":"2023-09-04","objectID":"/posts/sp/l/:6:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.1 Unix File System File system provides abstractions of naming, storage, and access of files. A file is a container of some information: data, program. In Unix, devices (disks, tapes, CD ROMs, screens, keyboards, printers, mice, etc.) are also treated as files, so as to provide a unified and device independent interface to applications. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.2 How to handel devices? system calls to the programmer for performing control and I/O to devices. handled by device drivers, which hide the details of device operation and protect the devices from unauthorized use. In Unix, disk files and other devices are named and accessed in the same way as data files. Unix provides a uniform device interface (called file descriptors). Allow uniform access to most devices through file system calls – open,close, read, write, etc. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.3 Types of files in Unix Regular file: an ordinary data file on disk – contains bytes of data organized into a linear array; Special file: a file representing a device – located in the /dev directory Block special file: devices transferring info in blocks or chunks, just like disks, CD ROM Character special file: devices transferring info in stream of bytes that must be accessed sequentially, just like keyboards, mice, printers, etc. Directories: provided to allow names (not physical locations) of files to be used. User gives a file name and Unix makes a translation to the location of the physical file-done via directories ","date":"2023-09-04","objectID":"/posts/sp/l/:6:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.4 Difference between regular and directory file Contents: data vs file info Operations: what can be done and who can do them, the access right ","date":"2023-09-04","objectID":"/posts/sp/l/:6:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.5 ls -l command For each file there are ten characters before the user and group owner. The first character shows the types of file access right Demo Task 1 What are the differences between a regular file and a device file? \u003ecp /etc/passwd /tmp/garbage \u003ecp /etc/passwd /dev/tty // \u003e cp normal.txt /dev/tty Hello world! content will be displayed on the terminal for tty device file ","date":"2023-09-04","objectID":"/posts/sp/l/:6:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.6 Hierarchical file organization A Unix file system has a hierarchical tree structure where internal nodes are directories and leaf nodes are files fully-quallified path name uniquely specifies a file: /dirA/dirB/My1.dat. relative pathname, begining from the current directory rather the root ditrectory: ../My2.dat ","date":"2023-09-04","objectID":"/posts/sp/l/:6:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.7 Current working directory At anytime, every process has an associated directory called the current working directory (cwd) Denoted by a dot ., e.g., mv ../file1 . The cwd associated with a user’s login shell is called the user’s home directory. pwd prints the name of cwd A relative pathname always starts with the path to the cwd. The C library function getcwd returns the pathname of the current working directory char *getcwd(char *buf, size_t size) size specifies maximum length pathname. If longer than the maximum, returns NULL and sets errono to ERANGE. #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cerrno.h\u003e int main(){ char cwd[1024]; if (getcwd(cwd, sizeof(cwd)) != NULL) printf(\"Current working dir: %s\\n\", cwd); else perror(\"getcwd() error\"); return 0; } ","date":"2023-09-04","objectID":"/posts/sp/l/:6:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.8 File representation 3.8.1 i-node Information about a filesystem structure is stored both on disk and main memory. Unix uses a logical structure called i-node to store the information about a file on disk – each file in a file system is represented by an i-node: i-nodes are stored at the front of each region of disk that contains a Unix file system. both conceptual and physical A regular file has a number called the i-number, which is an index into an array of the i-nodes on disk, one-to-one mapping. Each i-node corresponds to a unique i-number (index). data blocks may be placed in neighboring disk blocks, but it can not be guaranteed. more layers(tree structures) to access the data blocks store pointers in data blocks find the i-number of a file, by given the file name A directory contains a list of entries mapping file names to i-numbers (hence the i-node). A \u003cname, i-node\u003e pair is called a link. You can create many links for a file (multiple names). i-nodes are the hidden part, while directories are the visible structure of the Unix file system. Hence, the correspondence between a file name and its i-node is stored in the directory file. [Example of directory file] 3.8.2 Hard link \u0026 Symbolic link [Example of directory file: hard link] Hard link creation command: ln My1.dat My2.dat Hard link create a new entry for the same i-node, when modifying any of entry, the result will change [Example of directory file: symbolic link] create a new i-ndoe index Symbolic link normal symbolic link: when the “root” is moved, the link will be broken absolute symbolic link: when the “root” is moved, the link will not be broken i-node reference a new data block which stores a URL, of which the reference of source file absulute path or relative path Hard links must be on the same file system, while symbolic links can cross file systems. Hard linked files stay linked even if either one is moved; Symbolic linked files break if the original is moved. Remove links deep remove and shallow remove deep - remove the entire file from disk shallow - remove the reference not the file itself reference counter(part of i-node in filr info.) from the memory perspective to check using deep remove or shallow remove The key of links is checking whether the reference/path is valid or not. 3.8.4 File storage 12 direct pointer can point to $12 * 8KB = 96KB$ of file content. A single indirect pointer points to a block of direct pointers. A block can contain 8KB/4bytes = 2K pointers = 2048 pointers. 2048 direct pointers can point to $2048 x 8KB = 16MB$ of file content. A double indirect pointer points to 2048 single indirect pointers, that is $2048 * 16MB = 32GB$ of file content. Similarly, a triple indirect pointer points to $64TB$ of file content. So one I-node can at the most point to $64TB + 32GB + 16MB + 96KB$ of file content. ","date":"2023-09-04","objectID":"/posts/sp/l/:6:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.9 File Access In C programs, a file is represented by a file pointer or file descriptors. provide logical names (handles) for performing device-independent I/O. Unix file system calls use file descriptors (via open, read, write, close, and ioctl). ANSI C I/O library uses file pointers (via fopen, fscanf, fprintf, fread, fwrite, fclose, etc.). File descriptors - (in unistd.h) standard input: STDIN_FILENO standard output: STDOUT_FILENO standard error files: STDERR_FILENO Corresponding to constants 0, 1, 2 in \u003cunistd.h\u003e file pointers - (in stdio.h) standard input: stdin standard onput: stdout standard error files: stderr 3.9.1 File Descriptor low-level identifiers provided by the operating system to access files and I/O resources Process specialized System File Table(SFT) entry contains information about whether a file(within a process) is opened for read/write; permission; lock; read/write offset etc. Several entries in SFT may point to the same physical file. When new files are opened, it is assigned the lowest available FD. Accessing files for I/O is a three-step process, whether it is a regular file or a device: Open the file for I/O Read and write to the file Close the file when finished with I/O open a file int open(const char* pathname, int flags) int open(const char* pathname, int flags, mode_t mode) pathname: absolute or relative path name of the file to be opened flags: access mode - O_RDONLY, O_WRONLY, O_RDWR and bitwise-or’d(using |) with sero or more of the following flags: O_APPEND: the file is opened in append mode. O_CREAT: if the pathname does not exist, create the file as a regular file; must add the access permission mode parameter (e.g. 0644). … Return of open Returns the opened file’s file descriptor or –1 if an error occurred (the errno is set accordingly) read a file bytes = read(fd, buffer, count) Read from file associated with fd; place count bytes into buffer fd: file descriptor to reasd from buffer: pointer to any array count: number of bytes to read Returns number of bytes read or -1 if an error occured Demo Task 3 int fd = open(\"someFile\", O_RDONLY); char buffer[4]; // store in stack, no need to de-allocate char * buff2 = malloc(4*sizeof(char)); // store in heap, need to de-allocate int bytes = read(fd, buffer, 4*sizeof(char)); free(buff2); // de-allocate the memory or there will be memory leak write a file - overwrite bytes = write(fd, buffer, count) Write contents of buffer to the file associated with fd, write count bytes into the file O_TRUNC: if the file already exists and is a regular file and the access mode allows writing, truncate it to length 0. fd: file descriptor to write to buffer: pointer to any array count: number of bytes to write Returns number of bytes written or -1 if an error occured Demo Task 4 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void main(){ char buff4[4] = {'a','b','c',0} int i = 0; int bytes_written = 0; int fd; fd = open(\"someFile\", O_WRONLY|O_CREAT, 0644); printf(\"sizeof(buffer) is %d\\n\", sizeof(buffer)); // char buffer[4]; bytes_written = write(fd, buffer, 4*sizeof(char)); for (i = 0; i \u003c 4; i++) { printf(\"The %dth byte is %c\\n\", i, buffer[i]); } fsync(fd); // flashes the content into disk before close (for written) close(fd); // when open, close it } close a file return_val = close(fd) Close an open file descriptor Returns 0 if successful, -1 if an error occured 3.9.2 File Pointer higher-level abstractions used by programming languages or libraries to manage the current position and perform high-level file operations. A file pointer points to a data structure FILE, called a file structure in the user area of the process. A file structure contains a buffer and a file descriptor (so a file pointer is a handle to a handle) Demo Task 5 #include \u003cstdio.h\u003e FILE *myfp; if ((myfp = fopen(\"/home/ann/my.dat\", \"w\")) == NULL) fprintf(stderr, \"Could not fopen file\\n\"); else fprintf(myfp, \"This is a test\"); overwrite #include \u003cstdio.h\u003e void mai","date":"2023-09-04","objectID":"/posts/sp/l/:6:9","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"3.10 I/O Redirection process modifies its file descriptor table entry so that it points to a different entry in the system file table. Recall: to access a file, a process uses a file descriptor, which is an index into the process file descriptor table, which in turn points to an entry in the system file table. cat: reads a file and outputs to stdout. cat test \u003e my.file 3.10.1 I/O redirection realization using Table dup() int dup(int oldfd) duplicates the given file descriptor to the lowest numbered unused file descriptor in the file descriptor table. Demo Task 8 #include\u003cstdio.h\u003e #include\u003cfcntl.h\u003e #include\u003cunistd.h\u003e char* cmd[] = {\"/bin/ls\", \"-l\", 0}; int main(int argc, char* argv[]){ int fd = open(argv[1], O_WRONLY | O_CREAT, 0600); //fd will be 3; a file will be opened in write mode int fd2 = dup(fd); //duplicate the fd-th pointer to entry 4, the lowest available entry close(STDOUT_FILENO); // the entry 1 is now available(free) dup(fd); //duplicate the fd-th pointer into entry 1, \"my.dat\" become the standard output file execvp(cmd[0], cmd); // the old process image is replaced by the new process image for ls // the File Descriptor Table is \"inherited\" by the new process image, // still the same process(PID), but the image is replaced close(fd); //close file descriptor 3 in the parent process. return; } 3.10.2 Communication between parent/child via pipe System call pipe() returns two file descriptors by whilch we can access the input/outpur of a pipe(and I/O mechanism) int fd[2]; int pipe(int fd[2]); Return: 0 success; -1 error Demo Task 9 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstring.h\u003e int main(){ int fd[2]; pipe(fd); //fd[0] is for read and fd[1] is for write pid_t child = fork(); char* data = \"hello world\"; if (child == 0){ //child process close(fd[1]); char buf[100]; //a large enough buffer to share data int bytes_to_read = strlen(data)+1; while (bytes_to_read \u003e 0) { int count = read(fd[0], buf, sizeof(data)); bytes_to_read -= count; } printf(\"child process read: \\\"%s\\\" .\\n\", buf); } else { //parent process close(fd[0]); int bytes_to_write = strlen(data)+1; while (bytes_to_write \u003e 0) { int count = write(fd[1], data, strlen(data)+1) // \"+1\" for null byte, terminateing 0 bytes_to_write -= count; } fsync(fd[1]); //flush the data into pipe before close printf(\"parent process written: \\\"%s\\\" .\\n\", data); close(fd[1]); } return 0; } ","date":"2023-09-04","objectID":"/posts/sp/l/:6:10","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4 Device Driver What is a device driver? Related OS infrastructure Devices and files Major design issues Types of device drivers ","date":"2023-09-04","objectID":"/posts/sp/l/:7:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.1 What is a device driver? Device driver is a special kind of library, which can be loaded into the OS kernel, and links application program with the I/O devices ","date":"2023-09-04","objectID":"/posts/sp/l/:7:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.2 Related OS infrastructure Unix system architecture File subsystem and its relations with char/block device driver tables Char/block device driver tables Most of device derivers are character device drivers, like printer; block device driver operats on massive file system, like disk, CD-ROM, etc. Advantages to separate device drivers from the OS For OS designer Devices may not be available when an OS is designed. no need to worry about how to operate devices (set up registers, check statuses, …). Focus on OS itself by providing a generic interface for device driver development. For Device driver designers Do not need to worry about how I/O is managed in OS (how to design kernel data structures to efficiently operate devices, …) Focus on implementing functions of devices with device-related commands following the generic I/O interface ","date":"2023-09-04","objectID":"/posts/sp/l/:7:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.3 Device and Files devices are treated as special files. A file is associated with an inode. We can use mknod \u003cfile_name\u003e \u003cc or b\u003e \u003cmajor_number\u003e \u003cminor_number\u003e to create a special filr for a device file When we create a special file (an inode) for a device file, we associate major/minor numbers with the file (the inode). Major number associated with a special file is used to identify its corresponding device drivers in the kernel. 4.3.1 Character/Block Device Files Two types of device files: character and block [Example] ls -l /dev/null crw-rw-rw-r 1 root root 1 3 June 1, 1970 null character device file major number 1, minor number 3 ls -l /dev/bon br--r--r-- 1 root root 97 0 June 1, 1970 0 bolck device file major number 97, minor number 0 ","date":"2023-09-04","objectID":"/posts/sp/l/:7:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.4 Major Design Issues OS/Device Driver Communication Device Driver/Hardware Communication Device Driver Operations Interpret commands received from OS Schedule multiple requests for services Manage data transfer across both interfaces Accept \u0026 process hardware interrupts Maintain the integrity of the device’s and kernel’s data structures ","date":"2023-09-04","objectID":"/posts/sp/l/:7:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"4.5 Types of Device Drivers Differences in the way that device drivers communicate with Linux Block Character Network 4.5.1 Block Device Driver Communicate with the OS through a collection of fixed size buffers OS manages a buffer cache; satisfy user requests for data by accessing buffers in the cache. Driver is invoked when requested data is NOT in the cache; when buffers in the cache have been changed and must be written out (write back to the devices). By using buffer cache, block drivers are insuxlated from the many details of user requests; only need to handle requests from the OS to fill or empty fixed size buffers. Many support devices contain file system 4.5.2 Character Device Driver handle I/O requests of arbitrary size; support almost any type of devices. Handel data a byte at a time(keyboard); or work best with data in chunks smaller or larger than the standard fixed size buffer used by device driver (e.g. ADC) [Communication structure] Difference between block \u0026 character deivers Block driver – only interacts with buffer cache Character driver – directly interacts with user requests from user processes I/O requests are directly passed (essentially unchanged) to the drivers from the user processes Character driver is responsible for transferring data directly to/from the kernel memory space and the user memory space. 4.5.3 General Programming Considerations Device drivers are parts of the kernel and not normal user processes, which means we can only use the kernel routines in device driver programs, particularly C library functions or system calls for user level cannot be used. Some kernel routines may have the same names as C library functions, but they are of totally different implementations. Make frugal use of stack (local arrays \u0026 recursive function calls), as the stack space in the kernel is limited and not expandable. Be aware of floating-point arithmetic: may cause incorrect results Be aware of busy wait: may lock up the whole system ","date":"2023-09-04","objectID":"/posts/sp/l/:7:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Summary A device driver is a computer program that glues OS and its I/O devices together. A device is treated as a special file in Unix. There are three types of device drivers in Linux based on the different communication manner between device drivers and OS: block, character, and network. ","date":"2023-09-04","objectID":"/posts/sp/l/:7:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5 Character Device Driver Development two generic interfaces are related to character device driver development User programs: devices are treated as special files and users can only access devices through file operation system call (such as open, close, read, write, etc.), just like accessing regular files. Kernel: provides a generic interface and kernel routines for all device drivers to implement functionalities and register functions into the kernel data structures (such as char/block device driver tables). ","date":"2023-09-04","objectID":"/posts/sp/l/:8:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.1 The Interface for User Programs Device are treated as files: user programs access devices through file operation system calls. Each file has an inode, and each device driver has a major number. When using a device driver in user programs, we need to create a special file by associate its major number (driver) with an inode, e.g. mknod /dev/lab1 c 251 0 ","date":"2023-09-04","objectID":"/posts/sp/l/:8:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.2 Device Driver Development Two Tasks: Implement functionalities based on the generic interface Register the device driver into the kernel data structure (the char/block device driver table) The major number is the ID of a device driver ","date":"2023-09-04","objectID":"/posts/sp/l/:8:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.3 The Generic Interface for Char Device Driver in Linux Data structure called file_operations is defined in \u003clinux/fs.h\u003e . It is basically an array of function pointers. struct file_operations{ struct module * owner; … int (*open)(struct inode *, struct file *); ssize_t (*read)(struct file *, char *, size_t, loff_t *); ssize_t (*write)(struct file *, const char *, size_t, loff_t *); int (*release)(struct inode *, struct file *); … } To develop a char driver, we need to implement the corresponding functions for a device based on the above generic interface. ","date":"2023-09-04","objectID":"/posts/sp/l/:8:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"Demo task 1 // Header files include the prototypes of kernel routines and data structures needed in the program #include \u003clinux/config.h\u003e #include \u003clinux/module.h\u003e #include \u003clinux/kernel.h\u003e #include \u003clinux/init.h\u003e #include \u003clinux/fs.h\u003e #include \u003clinux/string.h\u003e #include \u003casm/uaccess.h\u003e #define DEVICE_NAME \"comp309_char_lab1\" static char msg[] = \"Hello World!!!\\n\" static int major; // Use \"static\", the effective range of a variable is limited in the file containing it, so we can avoid name pollution. static int zili_demo_char1_open(struct inode *inode, struct file *fp){ MOD_INC_USE_COUNT; printk(\"Device \" DEVICE_NAME \" open.\\n\"); return 0; } static ssize_t zili_demo_char1_read(struct file *fp, char *buf, size_t count, loff_t *position){ int num; if (count \u003c strlen(msg)) num = count; else num = strlen(msg); copy_to_user(buf, msg, num); return num; } static int zili_demo_char1_release(struct inode *inode, struct file*fp){ MOD_DEC_USE_COUNT; printk(\"Device \" DEVICE_NAME \" release.\\n\"); return 0; } #include \u003clinux/module.h\u003e // no need to write \"include/linux/module.h\" #define N_D 10 // at most 10 devices #define S_N 1 // minor# from 1 static dev_t devno // call when module is load into the kernel int __init helloworld_init(void) { } // call when module is unload from the kernel void __exit helloworld_exit(void) { } module_init(helloworld_init); module_exit(helloworld_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"YE Haowen\"); MODULE_DESCRIPTION(\"Char Device Driver for helloworld!\"); ","date":"2023-09-04","objectID":"/posts/sp/l/:8:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"5.4 Kernel Memory Space and User Memory Space The kernel virtual memory address space and user virtual memory address space are separate in Unix. The resources that only kernel can access are also called the “kernel land”, while the resources that the user can access are also called the “user land”. declaration: not only declare, but memory allocation definition: not only define, but implementation ","date":"2023-09-04","objectID":"/posts/sp/l/:8:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6 Complier Design Overview of Compiler Construction Syntax and semantics of programming languages; language translation approaches; tasks of a compiler; the compiler process. Lexical Analysis: Tasks of lexical analysis; specifying tokens by regular grammars and regular expressions; recognizing tokens by Finite Automata (FA); construction of FA from regular expressions; converting NFA to DFA; simulating DFA. Syntax Analysis: Tasks of syntax analysis; specifying language constructs by context-free grammars; BNF; derivation; parse and syntax trees; recognizing language constructs by Pushdown Automata; top-down and bottom-up parsing methods. Code Generation: Intermediate compilation phases; symbol table; intermediate code generation; code optimisation; code generation. ","date":"2023-09-04","objectID":"/posts/sp/l/:9:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.1 Complier Overview Complier: A well-established discipline Programming languages: high-level vs. low-level Complier Phases of a complier Programming Languages: Machine Language Everything is a binary number: operation, data, address In MIPS 2000: 0010 0100 1010 0110 0000 0000 0000 0100 means $t5 + 4 -\u003e $6 Programming Languages: Assembly Language Symbolic representation/mnemonics of machine language add $t6, $t5, 4 Benefit of High-level Language human readable Hide unnecessary details, so have a higher level of abstraction, increased productivity Make programs more robust: information is specified before its use, enabling subsequent error checking at compile time Make programs portable: the same program can be compiled on different machines ","date":"2023-09-04","objectID":"/posts/sp/l/:9:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.2 Translation Mechanism Development time translation: Compilation Translate source programs in one language into executable programs C, C++ Runtime translation: Inerpretation Read source programs, understand and produce execution results in the meantime line by line Perl, Shell commands Hybrid: Compilation + Interpretation Java, complied into byte code, and then interpreted by JVM during runtime ","date":"2023-09-04","objectID":"/posts/sp/l/:9:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.3 Complier and Phases of a Compliation Definition A compiler is a software that takes a program written in one language (called the source language) and translates it into another (usually equivalent) program in another language (called the target language). Also reports errors (bugs) in the source program. [Phases of a Compliation] 6.3.1 Lexical Analysis Scan the source program and group sequences of characters into tokens. A token is the smallest element of a language A group of characters (e.g., a series of alphabetic characters form a keyword; a series of digits form a number). The sub-module of the compiler that performs lexical analysis is called a lexical analyzer. Example: position := initial + rate * 60 Read one by one 6.3.2 Syntax Analysis Once the tokens are identified, syntax analysis groups sequences of tokens into language constructs. e.g., identifiers, numbers, and operators can be grouped into expressions. e.g., keywords, identifiers, expressions, and operators can be combined to form statements. The sub-module of the compiler that performs syntax analysis is called the parser/syntax analyzer. 6.3.3 Syntax(Parse) Tree Result of syntax analysis is recorded in a hierarchical structure called a syntax tree. Each node represents an operation and its children represent the arguments of the operation. Evaluation begins from bottom and moves up. E.g., parse tree for position := initial + rate * 60 6.3.4 Semantic Analysis Put semantic meaning into the syntax tree: syntax analysis recognizes grammatical events; semantic analysis processes such events, e.g., type checking, or triggering corresponding intermediate code generation 6.3.5 Intermediate Code Generation Generate IR (Intermediate Representation) code: Easier to generate machine code from IR code. 6.3.6 Code Optimization Modify program representation so that program can run faster, use less memory, power, etc. 6.3.7 Code Generation Generate the target program 6.3.8 Distinction between Phases and Passes Passes: the times going through a program representation. 1-pass, 2-pass, multiple-pass compliation Language become more complex – more passes Phases: conceptual stages, or modules of the compiler Not completely separate: Semantic phase may do things that syntax should do ","date":"2023-09-04","objectID":"/posts/sp/l/:9:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.4 Lexical Analysis(I) Why we need lexical analysis? Its input and output. How to specify tokens: Regular Expression How to recognize tokens – two methods Regular Expression $\\to$ Lex (software tool) Regular Expression $\\to$ Finite Automata Why need Lexical Analysis? Group the character into meaningful words 6.4.1 Input and Output of Lexical Analysis In lexical analysis, a source program is read from left-to-right and grouped into tokens. A token is a sequence of characters with a collective meaning. Token A syntactic category In English: a noun, a verb, an adjective, … In a programming language: an identifier, an integer value, a keyword, a white space, … Tokens correspond to sets of strings with a collective meaning Identifier: strings of letters and digits, starting with a letter Integer value: a non-empty string of digits Keyword: else, if, where, … [Expression] [Mini Program] Reason for tokens Classify program substrings according to their syntactic role. As the output of lexical analysis, tokens are the input to the parser (syntax analysis) Parser relies on token distinctions Different tokens are treated differently by the parser(keyword vs. identifier) Recognize tokens First, specify tokens using regular expressions (patterns) Second, based on regular expression, two ways to implement a lexical analyzer: Method 1: use Lex, a software tool Method 2: use finite automata (write your own program) ","date":"2023-09-04","objectID":"/posts/sp/l/:9:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"6.5 Lexical Analysis(II) Part II: Regular Expression 6.5.1 Regular Expression Specify tokens A token is specified by a pattern: a set of rules that describe the formation of the token The lexical analyzer uses the pattern to identify the lexeme: a sequence of characters in the input that matches the pattern. Once matched, the corresponding token is recognized. For example: The rule (pattern) for identifier: letter followed by letters and digits abc1 and A1By match the rule (pattern), hence they are identifier tokens; 1A does not match the rule (pattern), hence it is not an identifier token. The rules for specifying token patterns are called regular expression. A regular set (regular language) is the set of strings generated by a regular expression over an alphabet. 6.5.2 Alphabet and Strings An alphabet (usually denoted as $\\sum$) is a finite set of symbols. E.g. ${0,1}$ is the binary digits alphabet; ${a,b,c}$ is the English letter alphabet. A string $s$ over an alphabet $\\sum$ is a finite sequence of symbols drawn from that alphabet. E.g. 01001 is the string over $\\sum_{\\text{bin_digits}}$ $= {0,1}$ wxyasd is the string over $\\sum_{\\text{lower_case_letters}}$ $= {a,b,…,z}$ $ε$ is the empty string (without any symbol) The length of a string $s$ is denoted as $|s|$. E.g. $|ε|$ = 0; $|101| = 3$; $|abcdef| = 6$. 6.5.3 Kleene Closure and Language The Kleene closure of alphabet Σ, denoted as Σ∗, is the set of all strings, including the empty string , over the alphabet Σ. E.g. given alphabet Σ = {0,1}, then Σ∗ = {ε,0,1,00,01,10,11,000,001,….} Any set of strings over an alphabet Σ, i.e. any subset of Σ∗, is called a language. E.g. the empty set ∅, { }, Σ, and Σ∗ are all languages; abc, Def, D, z is a language over Σ letters = a, b, … , z, A, B, … , Z . 6.5.4 Operations on languages Particularly union, concatenation, Kleene closure, and positive closure. Precedence Kleene closure $\\succ$ concatenation $\\succ$ union {1}|{2}{3}* Exponentiation (concatenating the same language) ≻ multiplication (concatenating different/same languages) ≻ addition (union) {1} + {2} $\\cdot$ {3}^2. Let $L={a,b,…,z,A,B,…,Z}$ and $D={0,1,2,…,9}$ 6.5.6 Reaular Expressions Let $\\sum = {a,b}$ 6.5.7 Identifiers in Pascal Pascal identifier: a string of letters and digits beginning with a letter. Regular definition [Unsigned Numbers in Pascal] [Notation Shorthands] 6.5.8 Implementation of Lexical Analyzer After regular expressions are obtained, we have two methods to implement a lexical analyzer: Use tools: lex (for C), flex (for C/C++), jlex (for Java) Specify tokens using regular expressions Tool generates source code for the lexical analysis Use regular expressions and finite automata Write code to express the recognition of tokens Table drivern Lex: a lexical analyzer generator Lex is a Unix software tool, automatically constructs a lexical analyzer. Input: a specification containing regular expressions written in the Lex language. Assumes that each token matches a regular expression. Need an action specification for each expression. Output: Produces a C program that can recognize the matching tokens and trigger the specified actions. Especially useful when coupled with a parser generator ","date":"2023-09-04","objectID":"/posts/sp/l/:9:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7 Lexical Analysis(III) - Finite Automata ","date":"2023-09-04","objectID":"/posts/sp/l/:10:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.1 NFA, DFA, and NFA $\\to$ DFA Conversion Recognizing Tokens Regular Expression à Specify tokens Finite Automaton à Recognize tokens A language recognizer: Input: string x $\\to_{\\test{Recognizer for L}}$ $\\to$ Ouputs “yes” if x $\\in$ L, “no” otherwise A recognizer for a language is a program that takes a string and answers “yes” if is a string of , and “no” otherwise. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.2 Nondeterministic Finite Automata (NFA) A Nondeterministic Finite Automaton (NFA) consists of 5 components (Σ,S,S_0,F,move). Σ is the input alphabet S is the set of states S_0 is the start state F $\\subset$ S is the set of accepting states move is the transition function that maps state-symbol pairs to sets of states. Transition Graphs ","date":"2023-09-04","objectID":"/posts/sp/l/:10:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.3 State Transition Table The transition function of an NFA can also be implemented by a transition table, where the entries of rows are states and columns, respectively. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.4 ε - Transition A nother kind of transition, where the automaton transits from one state to another state without reading any input. NFA based recognitions (decisions) are hard to implement Can have multiple transitions from one input in a given state Can have ε-transitions Easy to form from regular expressions Hard to implement the recognition (decision) algorithm ","date":"2023-09-04","objectID":"/posts/sp/l/:10:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.5 Deterministic Finite Automata A DFA is a special case of NFA: One transition per input per state No ε-transitions Examples of NFA and DFA Given alphabet NFA: Easy to generate strings. May go to anyone of several states given an input symbol. May go to another state when there is no input, due to -transition(s). DFA: Easy to both generate and recognize strings. Goes to only one deterministic state given an input symbol. Does not go anywhere when there is no input; does not have any ε-transition. Table Implementation of DFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:5","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.6 Algorithm: Simulating a DFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:6","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.7 Regular Expression to NFA [Break Regular Expression to NFA] NFA to DFA A DFA is a special case of NFA. The conversion of an NFA to a DFA needs to meet the two requirements on DFA: -closure(s): the set of all states reachable from on -transition (to meet the no ε-transition requirement of DFA). Regard all reachable states from one state on one input symbol as one state (to meet the one transition per input per state requirement of DFA). Conversion Algorithm States of DFA obtained from NFA An NFA may be in many states at any time. If there are states, the NFA must be in some subset of those states. Given a set of elements, it has $2^N$ subsets. The DFA can have at the most $2^N$ states, where is the number of states of the NFA. ","date":"2023-09-04","objectID":"/posts/sp/l/:10:7","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"7.8 Regular Expression to NFA ","date":"2023-09-04","objectID":"/posts/sp/l/:10:8","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8 Syntax Analysis ","date":"2023-09-04","objectID":"/posts/sp/l/:11:0","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.1 Introduction Input: sequence of tokens from lexical analysiss Output: a parse tree (syntax tree) based on the gsrammar of a programming language. [Comparison between Lexical and Syntax] [Example] Syntax and Grammar In Pascal, program à blocks; block à statements; … var a,b,c; begin a = b+c; end The syntax of programming language constructs can be described by context-free grammar (CFG). ","date":"2023-09-04","objectID":"/posts/sp/l/:11:1","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.2 Context-Free Grammar $ G= (N,T,S,P)$ $N$ is a finite set of nonterminal symbols (simplified as “nonterminals”); $T$ is a finite set of terminal symbols (simplified as “terminals”); $S$ is the unique start nonterminal($S\\in N$); $P$ is a finite set of productions. Every production in $P$ is of the form $A \\to \\beta$, where $A \\in N$ and $\\beta \\in (N \\cup T)^*$. e.g., $N = {S}$, $T = {a,b}$, $S,P = {S \\to aSb|ab}$, where $S \\to aSb|ab$ denotes the language $L = {a^nb^n|n \\geq 0}$. Not Regular Expression Regular Expression, CFG, and Automata Language Classfication Regular Expression vs. CFG Every language that can be described by a regular expression can also be described by a CFG e.g., $(a|b)^*abb$ Derivations, Language of a CFG Based on a grammar for a language, we can generate sentences (strings consisting only of terminals) of the language. This is done by derivations. For CFG, derivation means start from the start nonterminal, repeatedly use productions to replace nonterminals, until a sentence is produced (i.e. all nonterminals are replaced). Grammar: $S \\to aSb|ab$ Derivation: $S \\Rightarrow aSb \\Rightarrow aaSbb \\Rightarrow aabbb$ where $\\Rightarrow$ means “derives in one step” A CFG language is the set of all the sentences that can be derived from the start symbol of the CFG grammar. The reverse is syntax analysis (parsing): given an input string of terminals, is there a derivation for the string based on the grammar (is the string a sentence of the grammar)? Parse Tree, Leftmost/Rightmost Derivation For CFG, a parse tree is a tree with the following properties The root is labeled by the start nonterminal; Each leaf node is labeled by a terminal or by ; An interior node is labeled by a nonterminal; If A is the nonterminal labeling some interior node, and $X_1X_2…X_n$ are the labels of the children of that node from left to right, then $A \\to X_1X_2…X_n$ is a production. A string of terminals is a sentence of a CFG grammar iff there is a (can have more) parse tree for this string. The derivation of the sentence can be shown pictorially by this parse tree. Suppose the parse tree of the sentence is found. Leftmost derivation: only the leftmost nonterminal is replaced at each derivation step. E.g., grammar: $E \\to E+E|E*E|(E)|id$ Leftmost derivation: $E \\Rightarrow -E \\Rightarrow -(E+E) \\Rightarrow -(id+E) \\Rightarrow -(id+id)$ Similarly, for rightmost derivation, the rightmost nonterminal is replaced at each step. ","date":"2023-09-04","objectID":"/posts/sp/l/:11:2","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.3 Parsing Methods 8.3.1 Bottom-Up Parsing Start at the leaves and build the parse tree from bottom up. Basic method: shift-reduce Shift symbols onto the stack; Reduce when handle is identified by left side. Used to implement automatic parser generator such as Yacc. Shift-reduce Parser Two data structures: A Stack to hold the grammar symbols; An Input buffer to hold the string to be parsed; Stack contains only $ symbol; Input buffer contains input string followed by $ symbol. Possible actions: Shift: move the next input symbol to the top of the stack; Reduce: replace the top of the stack with the appropriate non-terminal symbol ; Accept: parser reports the successsful completion of parsing; Error: parser is confused and is not able to make any decision. It can neither perform shift action nor reduce action nor accept action. Important rules: If the priority of incoming operator is more than the priority of in stack operator, then shift action is performed. If the priority of in stack operator is same or less than the priority of in stack operator, then reduce action is performed. 8.3.2 Top-Down Parsing Start at the root of the parse tree and try to get to leaves. Can be efficiently written by hand. Only work for certain class of grammars: Unambiguous No left recursion No left factoring Left recursion: A grammar is left-recursive if and only if there exists a nonterminal symbol that can derive to a sentential form with itself as the leftmost symbol. That is, $A \\Rightarrow^+ A\\alpha$, where $\\Rightarrow^+$ means the operation of making one or more substitutions, and is any sequence of terminal and nonterminal symbols. Left factoring: A grammar is left factoring if and only if there exists a nonterminal symbol $A$ that $A$ has $\\alpha \\beta_1 |\\alpha \\beta_2 $, where $\\alpha, \\beta$ are any sequence of terminal and nonterminal symbols, with $\\alpha \\neq e$ . Recursive Production Recursive Production: if the same non-terminal at both left and right hand side of production $$ S \\to aSb, S \\to aS, S \\to Sa $$ Recursive Grammar:if at least one recursive production is present $$ S \\to aS | a, S \\to Sa|as, S \\to aSb|ab $$ 8.3.3 Convert Left recursion into Right recursion If a CFG contains left recursion then the compiler may go to infinity loop, hence, to avoid the looping of the compiler, we need to convert the left recursive grammar into its equivalent right recursive production [Examples] Ambiguous Grammars Each parse tree has a unique leftmost/rightmost derivation. Sometimes a grammar may have (produce, imply) more than one parse tree for some of its sentences. Such a grammar is said to be ambiguous. For such a sentence (i.e., having more than one parse tree), its leftmost and rightmost derivations may be different. e.g., grammar: $E\\to E+E|E*E|id$, sntence id+id*id Grammar which is both left and right recursive is always ambiguous but ambiguous grammar need not be both left and right recursive [Example] 8.3.4 Non-deteministic Grammar The grammar with common prefix is known as non-deterministic grammar. $A\\to \\alpha\\beta_1, \\alpha\\beta_2$ Grammar with common prefixes requires a lot of Back-tracking, which is time consuming and inefficient. To avoid the back-tracking, we need to remove the common prefix from the grammar, like convert non-deterministic grammar into deterministic grammar. Normalization of CFG Chomsky Normal Form (CNF), if every production is in form: $A\\to BC|a$ ","date":"2023-09-04","objectID":"/posts/sp/l/:11:3","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["学习笔记"],"content":"8.4 First and Follow Sets First First(S) is the set of all terminals that may begin the strings in the language generated by S. [Examples] Follow Follow(A) is the set of all terminals that may follow to the right of (A) in any form of sentential Grammar. Rules: if A is the start symbol then Follow(A) = {$} if $A \\to \\alpha A B, B \\to \\varepsilon$, Follow(A) = First(B) if $S \\to \\alpha A$ Follow(A) = Follow(S) $S \\to \\alpha A \\beta$, where $\\beta \\to \\varepsilon$, Follow(A) = First(B) U Follow(S) - {$\\varepsilon$} [Examples] 学习笔记，仅供参考 ","date":"2023-09-04","objectID":"/posts/sp/l/:11:4","tags":["笔记"],"title":"System Programming","uri":"/posts/sp/l/"},{"categories":["个人博客相关"],"content":"这篇文章展示了基础的博客搭建","date":"2023-05-09","objectID":"/posts/serverfile/server-build/","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"Hugo个人博客搭建 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:0:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"1 快速开始 基于Mac系统 主要流程 安装相关环境 安装git 安装Homebrew 安装hugo 博客相关操作 新建自己的博客站点 设置主题 本地启动博客 构建网站 服务器部署(github) 将博客部署到github远端 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:1:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2 相关环境安装 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.1 安装git Git是一个版本控制工具，可以用来帮忙管理我们的博客，直接前往官网下载安装包即可 下载地址。 然后打开终端,即terminal, 输入以下命令，回车执行 # 检查是否安装成功 git --version 如果已经安装，则会显示安装的版本信息；若没有安装，则会提示安装，按照提示安装即可。 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.2 安装Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 同样可以通过，brew -v来检查是否已经安装或者是否安装成功 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"2.3 安装hugo brew install hugo # 检查是否安装成功 hugo version ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:2:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3 博客相关操作 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.1 新建自己的博客站点 首先新建一个网站，名字随便起，这里以 myblog 为例，[PATH] 为自己想要存放的路径，myblog 为网站名。 hugo new site [PATH]/myblog ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:1","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.2 设置主题 这里以LoveIt为例, 该主题仓库是：https://github.com/dillonzq/LoveIt 通常来说，我们将这个主题直接克隆clone到theme目录即可 # 先进入myblog目录下 cd [PATH]/myblog # 克隆操作 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:2","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.3 创建第一篇文章 hugo new posts/first_post.md ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:3","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.4 本地启动博客 hugo serve 去查看 http://localhost:1313. ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:4","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.4 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:5","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"3.5 将博客部署到github远端 首先在自己的GitHub赏创建一个新的仓库，名称必须为Github用户名.github.io，例如我的就是shanyu0205.github.io,用户名必须全小写. 创建成功后，将自己的博客文件夹下的public文件夹下的所有文件复制到Github用户名.github.io仓库下，然后提交到远端即可。 所有git命令都应在public文件夹下执行，应为public文件夹下才是真正的博客文件，其他的都是配置文件 cd public # 进入public文件夹 git init git add . # 注意后面有个点 git commit -m \"我的第一个hugo博客\" # 注意为英文双引号 git remote add origin \"https://github.com/\"你的库的地址\"\" # 与远端的git仓库进行关联 git push # 如果是第一次提交，需要加上-u参数: git push -u origin master 注意：由于Github修改了关于公钥的条例，所以在push的时候,可能会出现Permission denied的错误 所以需要在push之前,先在Github的Settings的Developer settings里,找到Personal access token,并选择token(classic)，然后点击Generate new token，然后在弹出的页面中，勾选repo，然后点击Generate token，然后将生成的token复制下来输入终端. 详情请见：https://blog.csdn.net/qq_43382853/article/details/119221234 接下来就可以通过[].github.io直接访问自己的博客了。[]中填写自己的github用户名 此时，如果你的博客还没有显示出来，那么就需要等待一段时间，因为github需要一段时间来构建你的博客，一般来说，等待时间不会超过10分钟。 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:3:6","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["个人博客相关"],"content":"参考链接： Hugo官网 雨临Lewis的博客 b站CodeSheep: BV1q4411i7gL 感谢你的支持 ","date":"2023-05-09","objectID":"/posts/serverfile/server-build/:4:0","tags":["Server and blog"],"title":"Hugo个人博客搭建(极简版)","uri":"/posts/serverfile/server-build/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Disk Storage Devices Data stored as magnetized areas on magnetic disk surfaces. A disk pack contains several magnetic disks connected to a rotating spindle. Disks are divided into concentric circular tracks on each disk surface. Track capacities vary typically from 4 to 50 Kbytes. A track is divided into blocks (In some systems, there is an intermediate unit called sectors). The block size B is fixed for each system. Typical block sizes range from B=512 bytes to B=4096 bytes. Whole blocks are transferred between disk and main memory for processing. A read-write head moves to the track that contains the block to be transferred. Disk rotation moves the block under the read-write head for reading or writing A physical disk block address consists of a surface number, track number (within surface), and block number (within track) Reading or writing a disk block is time consuming because of the seek time $s$ and rotational delay (latency) $rd$ Double buffering can be used to speed up the transfer of contiguous disk blocks 2.1 File of Records A file is sequence of records, where each record is a collection of data values or items. A file descriptotr or header includes information that describes the file, such as the field names and their data tpyes, and the addressseds of the file blocks on the disk. Records are stored on disk blocks. The blocking factor bfr for a file is the (average) number of file records stored in a disk block. A file can have fixed-length records or variable-length records. File records can be unspanned: no record can span two blocks spanned: a record can be stored in more than one block In a file of fixed-length records, all records have the same format. Usually, unspanned blocking is used with such files. Files of variable-length records require additional information to be stored in each record. Usually spanned blocking is used with such files. The records of a file can be contiguous, linked, or indexed. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:0:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.2 Operation on Files ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:1:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.3 Unordered Files \u0026 ordered Files Unordered Files: also called pile file New records are insterted at the end of the file Linear search through the file is necessary, which requires reading and searching half the file blocks on the average. QUITE EXPENSIVE. Insertion is quite efficient Reading the records in order of a particular field requires sorting the file records. 9 16 50 2 10 4 8 12 60 100 Ordered Files: also called sequential file File records are kept sorted by the values of an ordering field. Insertion is expensive: records must be inserted in the correct position. It is common to keep a separate unordered overflow file for new records to improve insertion efficiency; this is periodically merged with the main ordered file A binary search can be used to search for a record on its ordering field value. This requires reading and searching ${log_2}^{n}$ of the file blocks on the average. Reading the records according to the order of the ordering field is quite efficient. 2 4 6 14 18 50 100 5000 9000 100000 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:2:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.4 Hashed Files Hashing for disk files is called External Hashing Collisions occur when a new record hashes to a bucket that is already full an overflow file is kept for storing such records; overflow records that hash to each bucket can be linked together. [Resolution] Open addressing: Proceeding from the occupied position specified by the hash address, the program checks the subsequent positions in order until an unused (empty) position is found. Linear Prob: If collide, try Bucket_id+1, Bucket_id+2, … Quadratic Prob: If collide, try Bucket_id+1, Bucket_id+4,…(try to not affect the close neighbors like linear probing) Main disadvantagesof static external hashing: Fixed number of buckets M is a problem when the number of records in the file grows or shrinks. ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:3:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"2.5 Dynamic and Extendible Hashing Techniques Both dynamic and extendible hashing use the binary representation of the hash value h(K) in order to access a directory. In dynamic hashing the directory is a binary tree. In extendible hashing the directory is an array of size $2^d$ where d is called the global depth. The directories can be stored on disk, and they expand or shrink dynamically. An insertion in a bucket that is full causes the bucket to split into two buckets and the records are redistributed among the two buckets. Dynamic and extendible hashing do not require an overflow area. 3 Types of Single-level Indexes One form of an index: a file of entries \u003cfield value, ptr to record\u003e, which is ordered by field value The index is called an access path on the field ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:4:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.1 Primary Indexes Defined on an ordered data file The data file is ordered on a key field Includes one index entry for each block in the data file; the index entry has the key field value for the first record in the block, which is called the block anchor A similar scheme can use the last record in a block ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:5:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.2 Clustering Indexes Defined on an ordered data file The data file is ordered on a non-key field Includes one index entry for each distinct value of the field; the index entry points to the first data block that contains records with that field value ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:6:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.3 Secondary Indexes A secondary index provides a secondary means of accessing a file for which some primary access already exists The secondary index may be on a candidate key field or a non-key field There can be many secondary indexes for the same data file. The index is an ordered file with two fields. The first field is of the same data type as some non-ordering field (ie.,the indexing field) of the data file. The second field is either a block pointer or a record pointer If we include one entry for each record in the data file, then it is called a dense index ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:7:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"3.4 Multi-level Indexes Because a single-level index is an ordered file, we can create a primary index to the index itself ; in this case, the original index file is called the first-level index and the index to the index is called the second-level index 4 B-Trees and B+-Trees as Dynamic Multi-level Indexes In B Tree and B+ Tree data structures, each node corresponds to a disk block Each node is kept between half-full and completely full [An insertion into a node that is not full is quite efficient; if a node is full the insertion causes a split into two nodes] [If a deletion causes a node to become less than half full, it must be merged with neighboring nodes] In a B tree, pointers to data records exist at all levels of the tree In a B+ tree, all pointers to data records exists at the leaf-level nodes Internal pointer must point to a block A search tree of order $p$ is a tree such that each node contains at most $p−1$ search values and $p$ pointers Each internal node has at most $p$ tree pointers, $p-1$ value(s). Each internal node, except the root, has at least $⎡(p/2)⎤$ tree pointers, $⎡(p/2)⎤-1$ value(s). The root node has at least two tree pointers if it is an internal node. During the insertion, the node has to be splited when it is full. During the deletion, the node has to be merge when it is too small (number of value \u003c $⎡(p/2)⎤-1$). Normally, we choose the left leaf node of the same subtree to merge. (When there exists right or left leaf node within a same subtree, it should be different results.) 5 Physical Database Design Decisions 5.1 Physical Database Design Decisions Denormalization as a design decision for speeding up queries The goal of normalization is to separate the logically related attributes into tables to minimize redundancy and thereby avoid the update anomalies that cause an extra processing overheard to maintain consistency of the database. The goal of denormalizationis to improve the performance of frequently occurring queries and transactions. (Typically the designer adds to a table attributes that are needed for answering queries or producing reports so that a join with another table is avoided.) ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:8:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"5.2 Tuning Goal: To make application run faster To lower the response time of queries/transactions To improve the overall throughput of transactions Tuning Index Tuning Queries 学习笔记，仅供参考 ","date":"2022-10-08","objectID":"/posts/db/db_l6-7/l6-7/:9:0","tags":["Data Base"],"title":"Data base system - L6-7","uri":"/posts/db/db_l6-7/l6-7/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Integrity Constraints \u0026 Normal Forms 1 Key constraints Superkey of R: A set of attributes SK of R such that no two tuples in any valid relation instance r(R) will have the same value for SK. That is, for any distinct tuples t1 and t2 in r(R), t1[SK] \u003c\u003e t2[SK]. Candidate key of R: A “minimal” superkey; that is, a superkey K such that removal of any attribute from K results in a set of attributes that is not a superkey. Primary key of R: choice by the DB designer when there are more than one candidate key 2 Domain/Entity integrity constraints No “NULL” value for particular attributes Must be “UNIQUENESS” 3 Referential integrity constraints(Foreign key constraints) Two relation constraints (single relation above) To ensure that a value appears in one relation also appears in another relation. Implies “subset dependency” relationship between 2 sets of attributes in 2 tables Supplier relation is a foreign table of Shipment When to check integrity constraints? INSERT, DELETE, MODIFY the tuple 4 Functional Dependency FD is a particular kind of constraints Definition R is a relation schema, and $\\alpha \\subseteq R$, $\\beta \\subseteq R$, then $$\\alpha \\to \\beta$$ for all pairs of tuples tq and t2 in any legal relation instance r(R), we have $$t1[\\alpha]=t2[\\alpha]\\to t1[\\beta]=t2[\\beta]$$ As a result, FD can be used to identify and find primary key. ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:0:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"4.1 Inference Rules for FDs Given a set of FDs $F$, we can infer additional FDs that hold whenever the FDs in $F$: IR1 - Reflexive: If $Y$ is a subset of $X$, then $X\\to Y$ IR2 - Augmentation: If $X\\to Y$, then $XZ\\to YZ$, ($XZ$ stands for $X \\cup Z$) IR3 - Transitive: If $X\\to Y$ and $Y\\to X$, then $X\\to Z$ Closure of a set $F$ of FDs is the set $F^+$ of all FDs that can be inferred from $F$ Equivalence of two sets $F$ and $G$ of FDs Every FD in $F$ can be inferred from $G$ Every FD in $F$ can be inferred from $G$ Hence, $F$ and $G$ are equivalent if $F^+$ = $G^+$ 5 Relational Database Design ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:1:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.1 First Normal Form (1NF - 第一范式) A relation R is in 1NF if and only if all underlying domians cantain atomic(indivisible) value only atomic: an attribute can not be decomposed, like, address can be decomposed to province, city, road number, door number, etc. Problem Insert Anomalies Inability to represent certain information Eg, cannot enter “Supplier and City” info until Supplier supplies at least one part(P#) Delete Anomalies Deleting the “only tuple” for a supplier will destroy all the information about that supplier Update Anomalies “S# and City” could be redundantly represented for each P#, which may cause potential inconsistency when updating a tuple Solution(2NF) Replace original table by two sub-tables(Normalization) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:2:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.2 Second Normal Form (2NF - 第二范式) A relation R is in 2NF if amd only if it is in 1NF and every non-key attributes is fully dependent on any candidate/primary key(include that nonprime attribute is transitively dependent on the primary key) R(I,C,D,N) FD:{I-\u003eC, I-\u003eD, CD-\u003eN, IO-\u003eG} R is 2NF I is a candidate key C, D, N are fully (transitively) dependent on I, which can be treated as CD-\u003eN \u003c==\u003e I-\u003eN There is only one type of data stored a particular table, rather a combined-type data. Both relations are in 2NF in the above case. Solution(3NF) Replcae second table by two sub-tables SC(S#,City) CS(City,Status) Keep SP(S#,P#,Qty) ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:3:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 Third Normal Form (3NF - 第三范式) A relation R is in 3NF if and only if it is in 2NF and every non-key attribute is non-transitively dependent on any candidate key. Some redundancy still exists Solution Replace original SSP by two sub-tables SS(S#,Sname) SP(S#,P#,Qty) [or,SP(Sname,P#,Qty)] ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:4:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"5.3 BCNF - BC范式 A relation R is in BCNF if and only if every determinant (left-hand side of an FD) is a candidate key. 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可分解； 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。 参考 学习笔记，仅供参考 ","date":"2022-09-30","objectID":"/posts/db/db_l5/l5/:5:0","tags":["Data Base"],"title":"Data base system - L5","uri":"/posts/db/db_l5/l5/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 Relational Algebra ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:0:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1 SELECT σ and PROJECT π ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.1 SELECT SELECT operation (denoted by σ): Form of the operation: $σ_{c}(R)$ Selects the tuples (rows) from a relation R that satisfy a certain selection condition c. The condition c is an arbitrary Boolean expression on the attributes of R Resulting relation has the same attributes as R. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.1.2 PROJECT PROJECT operation (denoted by π): Form of the operation: $π_{L}(R)$ Keeps only certain attributes (columns) from a relation R specified in an attribute list L. Resulting relation has only those attributes of R specified in L(subtable of R). ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:1:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2 Select \u0026 Project Not allow any duplicated for a combined attribute value (e.g. $\\pi_{Sex,Salary}$ not allow the same combined attribute(Sex,salary), so the (F,25000) appears only once) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.1 Combined Select and Project Operation Several operations can be combined to form a relational algebra expression (query) EX: Retrieve the names and salaries of employees whon work in department 4 $π_{FNAME,LNAME,SALARY}(σ_{DNO=4}(EMPLOYEE))$ We also can specify explicitly: DEPT4_EMPS$\\leftarrow$$σ_{DNO=4}(EMPOYEE)$ R$\\leftarrow$ $π_{FNAME,LNAME,SALARY}$(DEPT4_EMPS) ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"1.2.2 Rename ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:2:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1 Set Operation For $\\cap, \\cup, - $ The operand must have the same number of attributes The domain of corresponding attributes must be compatible(union compatibility) The resulting relation for $\\cap, \\cup, -$ has the same attribute names as the first relation R1 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"2.1.1 CARTESIAN PRODUCT R(A1,A2,A3,…,B1,B2,B3,…)$\\leftarrow$R1(A1,A2,A3,…,Am) X R2(B1,B2,B3,…,Bm) If R1 has n1 tuples and R2 has n2 tuples, then R will have $n1*n2$ tuples. CARTESIAN PRODUCT is a meaningless operation on its own. It can combine related tuples from two relations if followed by the appropriate SELECT operation. The table EMP_DEPENDENTS has (3 x 7)21 tuples. To find the tuple which ESSN=SSN ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:3:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1 JOIN OPERATION ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:0","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.1 Equal Join and Theta Join Theta Join: Similar to a Cartesian Product followed by a Select. The condition c (often use θ) is called a join condition. Equal Join: The join condition c includes one or more equality conparisons involving arrtibutes from R1 and R2. ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:1","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"3.1.2 Natural Join There shoule be some column have same attribute(s) Based on the same value of attributes, adding two table tigether directly Delet the column which has same attribute value 学习笔记，仅供参考 ","date":"2022-09-21","objectID":"/posts/db/db_l4/l4/:4:2","tags":["Data Base"],"title":"Data base system - L4","uri":"/posts/db/db_l4/l4/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 1 Rational Data Model (record-based logical model) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:0:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.1 Basic structure Relations: Data stored as tables (called relations); each has a unique name A relation consists of rows (called tuples) and columns (called attributes) Attributes: An attribute has a “domain” Record: Each row/tuple in a relation is a record (an entity) Each attribute in a relation corresponds to a particular filed of a record DB Schema: relatively static, the whole structure DB instance: dynamic, data \u0026 structure ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:1:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.2 Key Candidate and primary keys are also defined by relational data model Super keys are similar to candidate/primary keys, but are not required to be minimal. (可以有其他属性) ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:2:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"1.3 Characteristic of Relations Ordering of tuples in a relation r(R): The tuples are not considered to be ordered, even though they appear in order in the table form. Ordering of attributes in a relation schema R (and of values within each tuple): We will consider the attributes in R(A1, A2, …, An) and the values in t=\u003cv1, v2, …, vn\u003e to be ordered . Values in a tuple: All values are considered atomic (indivisible). A special null value is used to represent values that are unknown or inapplicable to certain tuples. Can a key attribute contain NULL values? Why? No, since a key attribute is a unique data to identify an entity in an entity set, if the key is null, which is meaningless. 2 ER vs. Rational Data Model ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:3:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1 Mapping ER Diagrams into Tables ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.1 Repersentation of Entity(Strong) sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:1","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.2 Repersentation of Weak Entity sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:2","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.3 Repersentation of M:N Relationship Sets ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:3","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.1.4 ER to relational schema Relation Table \u0026 Entity Table Relation table Strong relation primary keys of connecting entities relation attributes(if any) Weak relation primary keys of connecting strong entities all attributes of all weak entities — — Entity table Strong entity all attributes (sign the key attribute(s)) Weak entity all primary keys of corresponding strong entity — ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:4:4","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"2.2 (min,max) notation (min,max) notation replaces the cardinality ratio(1:1,1:N,M:N) and single/double-line notation for participation constraints; Definition: For EACH entity e in E, e MUST participate in at least $min$ and at most $max$ relationship instances in R at any point in time. Conver it into English: for a particular entity(e.g. Stundet A in Student Entity), MUST appear(participate) in at most $max$ \u0026 at least $min$ tuples in the table(relation R). As a result For $min$ $min = 0\\to$ partial participation - single line, not all entities participate $min\u003e0\\to$ total paricipation - double line, all entities MUST appear in rows For $max$ For a entity, it MUST appear in at most $max$ rows in a table [Example] Translation between Cardinality ratio and (min,max) notation: Cardinality ratio 1:1 $\\to$ (min,max): $(x,1)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example: ID === HAS === Student Cardinality ratio 1:1: double lines mean total participation For every ID, it MUST be hold by one and only one student For each student, he/she MUST has one and only one ID ID =(1,1)= HAS =(1,1)= Student (min,max) notation: in HAS tabke Each student MUSt appear in the table one and only one row Each ID MUSt appear in the table one and only one row Cardinality ratio 1:N $\\to$ (min,max): $(x,N)$;$(1,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Cardinality ratio N:1 $\\to$ (min,max): $(x,1)$;$(N,x)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation Example Employee === WORKS_FOR === Department Cardinality ratio 1:N: double lines mean total participation One employee must work for one and only one department One department must has at least one employee working for it (min,max) notation: =(1,1)= WORKS_FOR =(1,N)= Department Each employee MUST appear in the table one and only one row Each department MUST appear in the table at least one row, at most N rows Cardinality ratio M:N $\\to$ (min,max): $(x,N)$;$(x,M)$ $x=0$, the entity has partial participation $x=1$, the entity has total participation 3 SQL ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:5:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.1 Basic syntax (structure) of SQL SELECT [DISTINCT] attribute1,... FROM table1 [name1], tabel2 [name2],... [WHERE requirement] [GROUP BY (attribute) HAVING requirement]; [Example] Following relational schema: Customer (cname, street, city) Branch (bname, assets, b-city) Borrow (bname, loan#, cname, amount) Deposit (bname, acct#, cname, balance) E1: Find all customers of the Sai Kong branch (SELECT cname FROM Deposit WHERE bname = 'Sai Kong') -- 注意是单引号 UNION -- not only Deposit customres, but borrow customers (SELECT cname FROM Borrow WHERE bname = 'Sai Kong'); E2: Find the name and city of all customers having a loan at the Sai Kong branch SELECT DISTINCT Customer.cname,city FROM Borrow,Customer WHERE Borrow.cname = Customer.cname AND Borrow.bname = 'Sai Kong'; E3: Find the names of all customers whose street has the substring ‘Main’ included SELECT cname FROM Customer WHERE Customer.street LIKE '%Main%'; E4: Find all customers who have an account at some branch in which Jones has an account SELECT DISTINCT S1.cname FROM Deposit S1 WHERE S1.bname IN (SELECT bname FROM Deposit S2 WHERE S2.cname = 'Jones') AND S1.cname != 'Jnoes'; SELECT DISTINCT S2.cname FROM Deposit S1,Deposit S2 WHERE S1.cname = 'Jnoes' AND S1.bname = S2.bname AND S1.cname != S2.cname; E5: Find branches having greater assets than all branches in N.T. SELECT B1.bname FROM Branch B1 WHERE B1.assets \u003e ALL (SELECT B2.assets FROM Branch B2 WHERE B2.b-city = 'N.T.' ); SELECT B1.bname FROM Branch B1 WHERE NOT EXISTS (SELECT * FROM Branch B2 WHERE B2.assets \u003e= B1.assets AND B2.b-city = 'N.T.' ); E6: Find names of all branches that have greater assets than some branch located in Kowloon SELECT bname FROM Branch WHERE assets \u003e SOME (SELECT assets FROM Branch WHERE b-city = 'Kwoloon'); SELECT bname FROM Branch B1,Branch B2 WHERE B1.assets \u003e B2.assets AND B2.b-city = 'Kwoloon'; E7: Find all customers who have a deposit account at allbranches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE (SELECT T.bname FROM Deposit T account WHERE S.cname = T.cname) -- the set of branches he/she has a deposit account CONTAINS (SELECT bname FROM Branch WHERE b-city = 'Kowloon'); -- the set of branches on Kwoloon E8: Find all customers of Central branch who have an account there but no loan there SELECT C.cname FROM Customer C WHERE EXISTS (SELECT * FROM Deposit D WHERE D.cname = C.cname AND D.bname = 'Central') AND NOT EXISTS (SELECT * FROM Borrow B WHERE B.cname = C.cname AND B.bname = 'Central'); E9: Find all customers who have a deposit account at ALL branches located in Kowloon SELECT DISTINCT S.cname FROM Deposit S WHERE NOT EXISTS( (SELECT bname FROM Branch WHERE b-city = 'Kowloon') MINUS (SELECT T.bname customer S FROM Deposit T WHERE S.cname = T.cname)); E10: List in alphabetic order all customers having a loan at branches in Kowloon SELECT DISTINCT cname FROM Borrow WHERE b-city = 'Kowloon' ORDER BY cname; --By default, in ascending order. E11: List the entire borrow table in descending order of amount, and if several loans have the same amount, order them in ascending order by loan# SELECT * FROM Borrow ORDER BY amount DESC, loan# ASC; -- when the \u003camount\u003e is the same, order aomunt by \u003cloan#\u003e in ascending, and so on. ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:6:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.2 NULL Value All comparisons involving Null become FALSE!!! A modification is permitted through a view ONLY IF the view is defined in terms of ONE base/physical relation(whether all the values of tuple are full). In most SQL-based DBMSs, the special keyword NULL may be used to test for a null value. [like] SELECT c-name FROM Deposit WHERE balance IS NOT NULL; ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:7:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"3.3 Aggregate Function Compute functions on groups of tuples using the group by clause Tuples with the same value on all attributes in the group by clause are placed in one group Aggregate function includeds: avg, sum, min, count, max E1: Find the average account balance at each branch: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name; E2: If only interested in branches where average balance is \u003e $12000: SELECT b-name, AVG(balance) FROM Deposit GROUP BY b-name HAVING AVG(balance) \u003e 12000; E3: Find those branches with the highest average balance: SELECT b-name FROM Deposit GROUP BY b-name HAVING AVG(balance) = SELECT MAX(AVG(balance)) FROM Deposit GROUP BY b-name); E4: Find the average balance of all depositers who live in Laguna city and have at least 3 accounts: SELECT AVG(balance) FROM Deposit, Customer WHERE Deposit.c-name = Customer.c-name AND city = 'Laguna' GROUP BY Deposit.c-name HAVING COUNT(DISTINCT acct#) \u003e= 3; 学习笔记，仅供参考 ","date":"2022-09-11","objectID":"/posts/db/db_l2/l2/:8:0","tags":["Data Base"],"title":"Data base system - L2","uri":"/posts/db/db_l2/l2/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"这篇文章展示了数据库系统的学习记录 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:0:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.1 What is Database(DB)? A non-redundant, persistent(like store in hard disk) collection of logically related records/files that are structured to support various processing and retrieval needs. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:1:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.2 Database Management System A set of software programs for creating, storing, updating, and accessing the data of a DB. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:2:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.3 Basic concept and terminologies instance (compared to the instance in oop) the collection of data (information) stored in the DB at a particular moment (ie, a snapshot) The data in the database at a particular moment in time is called a database state or snapshot. It is also called the current set of occurrences or instances in the database. scheme/schema the overall structure (design) of the DB – relatively static ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:3:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.4 Data Abstraction: 3-level architecture Internal/Physical Level: the complete details of data storage and access paths for the database. (i.e., SSD,Cloud,disk)(how data are actually stored) Internal level has an internal schema, which describes the physical storage structure of the database. Conceptual Level: which describes the structure of the whole database. For a 2D array, it will be stored as a “table” in database. It hides the detail of internal level.(what data are actually stored) The conceptual schema hides the details of physical storage structures and concentrates on describing entities, data types, relationships, user operations, and constraints.(data model) External Level: It only privides the data which the user wants and hide the rest of the datbase. Consider a two-dimensional integer array of size n*m The physical level would simply be n × m (probably consecutive) storage locations The conceptual level is a grid of boxes, each possibly containing an integer, which is n boxes high by m boxes wide. There are $2^{n×m}$ possible views (external level). For example, a view might be the entire array, or may be a part of array. ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:4:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"1.5 Data Independence The ability to modify a schema definition in one level without affecting a schema in the next higher level Physical data independence: capacity to change the internal schema without having to change the conceptual schema Logical data independence: the capacity to change the conceptual schema without having to change external schemas or application programs. DB System Architecture 2 The Entity-Relationship Model(实体关系模型) ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:5:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1 Basic Definition ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.1 ER模型的作用 数据库设计的第一步是需求分析阶段，也是最重要的一步 概念建模也就是ER建模,将需求以ER图的方式进行可视化 ER图可以描述一个数据库的逻辑结构 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.1.2 ER模型的组成 2.1.2.1 entity entity(实体): a distinguishable object with an independent existence 一个entity可以是具体的(如：人，书，CityU), 也可以是抽象的(如：假期) entity set: a set of entities of the same type Like: Student Bank…… 2.1.2.2 attribute attribute(属性): 一个entity用一组attributes来表示，每一个attribute有一个对应的值，比如一个人可以有name，SSN，gender，phone number等attributes Different type of Attributes: Simple: Each entity has a single atomic value for the attribute. For example SSN or Sex Composite: The attribute may consist of several components. For example, Name(FirstName, MiddleName, LastName). Multi-valiue: An entity may have multiple values for that attribute. For example, Color of a CAR, denoted as {Color}. In general, composite and multi-valued attributes may be nested. Domain: 一个attribute的domain是这个attribute值的有效范围 Formally, an attribute A is a function which maps from an entity set E into a domain D: $$A: E\\to D$$ 2.1.2.3 relationship Relationship: the relationship(association) among several entities An attribite $A:E\\to D$ is a “simplified form of a relationshihp” if we allow D to be an Entity Set, then A becomes a relationship A realtionship can carry attribute Example: Patrick takes cs2450 with a grade of B+. “takes” is relationship bteween “Patrick” and “CS2450”, “B+” is the attribute of this relationship, since “B+” is neither the attribute of “Patrick” nor “CS2450”, which is “Patrick takes cs2450” The degree of a relationship set/type is the number of participating entity sets/types. Both MANAGES and WORKS_ON are binary relationships. In general, an n-ray relationship is not equialent to n binary relationships. The relationship has participation constraint partial participation: single line (not all entity participate) total participation: double line (every entity participate) (min,max) notation for relationship Specified on each participationof an entity set E in a relationship set R Specifies that each entity e in E participates in at least min and at most max relationship instances in R Default (no constraint): min=0, max=n ! Must have: $min\u003c=max,min\u003e=0,max\u003e=1$ (a) is not equivalent to (b) but to (c). ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:6:2","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3 ER diagram ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:0","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["学习笔记"],"content":"2.3.1 ER图的基本构成 Rectangles(正方形): Entity Sets Ellipses(椭圆形): Attributes Diamonds(菱形): Relationship Sets Lines: Attributes to Entity/ Relationship Sets or, Entity Sets to Realtionship Sets 不同的键(Key): to distinguish individual entities or relationships Superkey (超键): a set of one or more attributes which, taken together, identify uniquely an entity in an entity set 在关系中能唯一标识元组的属性集称为关系模式的超键 Example: 一般来说，学号是标识学生实体的唯一标识，所以该元组的超键就为学号。我们可以将学号和其他属性结合起来，(学号，性别)，(学号，年龄)等也为超键。 Candiaite key(候选键): minimal set of attributes which can identify uniquely an entity in an entity set 最小的超键，仅包括独一标识实体所必需得最小属性的数量，即不含多余属性的超键为候选键 Example: stident ID identify a student, but Name is not a candidate key 候选键是超键的子集 Primary key(主键): a candidate key chosen by the DB designer to identify an entity in an entity set 是从候选码(candidate key)中人为挑选的一个 Foreign key: FK is a set of attributes of R1, which refers to the PK(primary key(s)) of R2 Domain of FK should be the same as PK t1[FK] in R1 either occurs as a value of t2[PK] in R2 or is NULL. 实体间的联系 Integrity Constraints One-to-one(一对一): 例如班级和班长之间就是一对一联系，一个班级只有一个班长 One-to-many(一对多/多对一): 例如一个班级有一个辅导员，但担任辅导员的老师可以同时担任其他班级的辅导员，所以辅导员和班级之间就是一对多联系 Many-to-many(多对多): 例如一个学生可以学习多门课程，每门课程也可以有多个学生，那么学生和课程之间的关系就是多对多联系 Weak Entity Set An entity set that does NOT have enough attributes to form a primary/candidate key 学习笔记，仅供参考 ","date":"2022-09-04","objectID":"/posts/db/db_l1/l1/:7:1","tags":["Data Base"],"title":"Data Base system - L1","uri":"/posts/db/db_l1/l1/"},{"categories":["我的博客"],"content":"Java学习记录（一） JAVA 学习 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:0:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.JAVA语言基础 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1Java中的数值类型 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.1.1 数值类型 1.1.2 数据类型转换 顾名思义，即为将一个值从一个类型转换为另一个类型的过程。例如，可以将String类型的数据“457”转换为数值型，也可以将任意类型的数据转换为String类型。 如果从低精度数据类型向高精度数据类型转换，则永远不会溢出，即更加安全，并且总是成功，；而把高精度类型数据转换为低精度类型数据时，被可能存在数据的丢失，又可能失败。 数据转换有两种形式，隐式转换（由低精度转换为高精度）与显式转换（由高精度转换为低精度）。 精度由低到高：（不包含逻辑类型与字符类型） byte \u003c short \u003c int\u003c long \u003c float \u003c double 例： int x =50; float y = x; //由于浮点型精度高于整数型，所以此转换为隐式转换，结果为50.0 当我们需要把高精度的变量赋给低精度的变量时，必须使用显示类型转换运算（又称强制类型转换）。 例: int a = (int)45.23; // 输出为45 long y = (long)456.5F; // 输出为456 int b = (int)'d'; // 输出为100 除布尔型以外，其他基本类型数据都能进行显型类型转换。 1.1.3 运算符 在Java中有着算数运算符，关系运算符，位运算符，逻辑运算符，赋值运算符以及其他运算符。在此，我们主要讨论自增、自减运算符和位运算符。 b = ++a; b = a++; 上述两行代码看似差不多，实际上有很大区别：第一行翻译为先将a的值+1，然后再赋给b；第二行则是先将a的值赋给b，a的值再+1。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.2类中的变量类型 局部变量：在方法，构造方法或者语句块中被定义的变量。方法结束后，变量会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量，可以被类中方法、构造方法等语句块访问，没有static修饰。 类变量：类变量也申明在类中，方法体之外，但必须声明为static类型。 例： public class Variable{ static int allclicks = 0; // 类变量（静态变量） String str = \"hello world\"; // 实例变量（成员变量） public void method(){ int i = 0; // 局部变量 } } 在Java中，所有变量在使用前都必须声明。 例： int a,b,c; // 声明了3个int型整数：a，b，c。 int d = 3,e,f = 5; // 声明三个整数并赋予初值。 byte z =22; // 声明并初始化。 char x = 'x'; // 变量x的值是字符‘x’。 double pi = 3.14159;// 声明了pi。 既然有变量，那就会有常量。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.3Java常量 常量就是一个固定值。他们不需要计算，直接代表相应的值。 常量指不能改变的值，在Java中用final标志： final double PI = 3.1415927; ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:4","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.4构造方法 每个类都有构造方法。 在创建一个对象时，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 例： public class Puppy(){ public Puppy(){ } public Puppy(String name){ } } 上述代码类的构造方法为Puppy(),返回值为字符串类型的‘name’，即调用该构造方法时，Puppy(\"name\"), ’name’ 即为用户想输入的小狗的名字。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:5","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.5创建对象 在Java中使用关键字 new 来创建一个新的对象。 声明：声明一个对象，包括对象名称和类型。 实例化：使用关键字 new 来创建一个对象。 初始化：使用 new 创建对象时，会调用构造方法(constructor)初始化对象。 例： public class Puppy(){ public Puppy(String name){ System.out.println(\"Puppy name is : \"+ name); } public static void main(String []args){ Puppy myPuppy = new Puppy(\"tommy\"); // 上述语句创建了一个Puppy对象 } } 代码块的结果会显示为：Puppy name is tommy ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:6","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"1.6访问实例变量和方法 /*实例化对象*/ ObjectReference = new Constructor(); /*访问其中的变量*/ ObjecReference.variableName; /*访问类中的变量*/ bjecReference.MethodName(); public class Puppy(){ int puppyAge; //定义了一个名为puppyAge的int型成员变量 public Puppy(String name){ System.out.println(\"Passed Name is: \"+ name); } public void setAge(int age){ puppyAge = age; } public int getAge(){ System.out.println(\"Puppy's age is: \" + puppyAge); return puppyAge; } public static void main(String []args){ /*创建对象*/ Puppy myPuppy = new Puppy(\"tommy\"); /*调用方法来设定age*/ myPuppy.setAge(2); /*调用另一个方法来获取age*/ myPuppy.getAge(); /*访问成员变量*/ System.out,println(\"Variable Value: \" + myPuppy.puppyAge); } } 结果为： Passed name is: tommy Puppy’s age is: 2 Variable Value: 2 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:1:7","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"2.JAVA修饰符 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类) public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"默认访问修饰符-不使用任何关键字 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 如下例，变量和方法的声明可以不适用任何修饰符： String version = \"1.5.1\" boolean processOder(){ return true } ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"私有访问修饰符-private 私有访问修饰符是最严格的访问级别，所以被声明为private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 声明为私有访问类型的变量只能通过类中公共的getter 方法被外部类访问。 Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 下面的类使用了私有访问修饰符private public class Logger { private String format; public String getFormat() { return this.format; } public void setFormat(String format) { this.format = format; } } Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 public方法：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）。 公有访问修饰符-public 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。最常见的公有访问即为public static void main(String []args){...}。Java 程序的main()方法必须设置成公有的，否则Java 解释器将不能运行该类。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"受保护的访问修饰符-protected 被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能被不同包中的字类访问。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:2:3","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"非访问修饰符 例如static修饰符，用来创建方法和类变量。 final修饰符，用来修饰类、方法和变量，final修饰的类不能被继承，修饰的方法不能被继承重新定义，修饰的变量是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。 -synchronized和volatie修饰符，主要用于线程的编程。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:0","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"final修饰符(关键字) final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同对象。但是final对象里的数据可以被改变，也就是说final对象的引用不能改变，但是里面的值可以改变。 final修饰符通常和static修饰符一起是用来创建常量。 例： public class Test{ final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = \"Manager\"; public void changeValue(){ value = 12;//将输出一个错误 } } 由于value的值已经被final定义过，所以无法被改变。 类中的final方法可以被字类继承，但是不能被字类修改。fianl类不能被继承，没有类能够继承final类的任何特性。 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:1","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"static修饰符 静态变量： static关键字用来声明独立于对象的静态变量，静态变量也被称为类变量。局部变量不能被声明为static变量。 例： public class InstanceCounter{ private static int numInstances = 0; protected static int getCount(){ return numInstances; } private static void addInstance(){ numInstances++; } InstanceCounter(){ InstanceCounter.addInstance(); } public static void main(String []args){ System.out.println(\"Starting with \"+:InstanceCounter.getCount()+ \"instances\"); for (int i = 0; i \u003c 500; i++){ new InstanceCounter(); } System.out.println(\"Created \"+ InstanceCounter.getCount()+\" instances\"); } } 结果如下： Started with 0 instances Created 500 instances 引用时请标明出处 ","date":"2021-10-02","objectID":"/posts/blog/blog1/:3:2","tags":["Java"],"title":"Java学习1","uri":"/posts/blog/blog1/"},{"categories":["我的博客"],"content":"Java学习记录（二） Java 数据类型 变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。 内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有着两大数据类型，内置数据类型和引用数据类型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:0:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"内置数据类型 其中包括6种数字类型（4个整数型和2个浮点数型），一种字符类型，及一种布尔型。 ","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:0","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":["我的博客"],"content":"数字类型 byte： byte的数据类型是8位、有符号的，以二进制补码（2‘s）表示的整数。 最小值是-128（-2^7） 最大值是127（2^7-1） 默认值是0 byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short: short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15） 最大值是 32767（2^15 - 1） Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一 默认值是0 例子：short s = 1000，short r = -20000。 int: int 数据类型是32位、有符号的以二进制补码表示的整数 最小值是-2^31（-2147483638） 最大值是2^31-1（-2147483637） 一般的整型变量默认为int型 默认值是0 例子：int i = 100； long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）最大值是 9,223,372,036,854,775,807（2^63 -1） 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double: double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数； 浮点数的默认类型为 double 类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char: char 类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（十进制等效值为 0）； 最大值是 \\uffff（即为 65535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’; 测试","date":"2021-09-08","objectID":"/posts/blog/blog2/:1:1","tags":["Java"],"title":"Java学习2","uri":"/posts/blog/blog2/"},{"categories":null,"content":"L3 ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:0","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task1 ps ps -a ps -l Task 2: ls: list the files in the current directory ls -l: list the files in the current directory in long format ls -a: list the files in the current directory, including the hidden files ls -t: list the files in the current directory, sorted by time ls -lat: list the files in the current directory, including the hidden files, in long format, sorted by time cd: change the current directory .: the current directory ..: the parent directory cp: copy a file cp file1 file2: copy file1 to file2 cp file1 file2 file3 dir: copy file1, file2, file3 to dir cp -r dir1 dir2: copy dir1(all the content) to dir2 recursively mv: move a file mv file1 file2: move file1 to file2 mv file1 file2 file3 dir: move file1, file2, file3 to dir mv dir1 dir2: rename dir1 to dir2 rm: remove a file rm -rf dir: remove dir recursively and forcefully mkdir: make a directory mkdir dir: make a directory named dir who: show the users who are currently logged in whami: show the current user who -q: show the number of users who are currently logged in who -u: show the idle time of the users who are currently logged in cat: concatenate files and print on the standard output cat file: print the content of file on the standard output cat file1 file2: print the content of file1 and file2 on the standard output cat file1 file2 \u003e file3: concatenate file1 and file2, and write the result to file3 cat file1 file2 \u003e\u003e file3: concatenate file1 and file2, and append the result to file3 man: an interface to the on-line reference manuals man command: show the manual of command man -k keyword: search the manual for keyword man -f command: show the manual of command man -a command: show all the manual of command gcc: GNU project C and C++ compiler gcc file: compile file gcc file -o file: compile file and output the executable file to file gcc file1 file2 -o file: compile file1 and file2 and output the executable file to file Task 3: vi: a text editor vi file: open file in vi i: enter insert mode esc: exit insert mode, enter command mode Under command mode: :w: save the file :q: quit vi :wq: save and quit vi :q!: quit vi without saving h: move leftward; l: move rightward; j: move downward; k: move upward w: move rightward word by word; b: move leftward word by word dw: delete the word after the cursor u: undo the last command dd: delete the current line $: move to the end of the line; ^: move to the beginning of the line gedit: a text editor gedit file: open file in gedit Task 4: Shell output redirection who \u003e users: redirect the output of who to file users, overwriting(replace) the original content of users who \u003e\u003e users: append the output of who to file users Task 5: Shell input redirection wc \u003c users: redirect the content of users to wc, and count the number of lines, words, and characters in users wc -l: count the number of lines wc -l \u003c output.txt \u003e output1.txt: count the number of lines in output.txt, and write the result to output1.txt Task 6: write, compile, and run a C program vim hello.c: write a C program in vi gcc hello.c -o hello: compile the C program and output the executable file to hello ./hello: run the executable file External Task: pipeline - make a pipe among processes ls -l | wc -l: count the number of files in the current directory ls -l | grep \"hello\": list the files in the current directory whose name contains “hello” ls -l | grep \"hello\" | wc -l: count the number of files in the current directory whose name contains “hello” ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:1","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task2 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main (void){ printf(\"Process ID: %ld\\n\", (long)getpid()); printf(\"Parent ID: %ld\\n\", (long)getppid()); printf(\"Onwer user ID: %ld\\n\", (long)getuid()); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:2","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task3 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int ret_from_fork, mypid; mypid = getpid(); printf(\"Before: my pid is %d\\n\", mypid); ret_from_fork = fork(); sleep(1); printf(\"After: my pid is %d, fork() said %d\\n\", getpid(), ret_from_fork); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:3","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task5 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if (childpid = fork()) break; //parent breaks out; child continues fprintf(stdout, \"This is process %ld with parent %ld, i = %d\\n\",(long)getpid(), (long)getppid(), i); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:4","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task6 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e void main(void){ int i, n = 4; pid_t childpid; for (i = 1; i \u003c n; ++i) if ((childpid = fork()) \u003c= 0) break; //child and error break out; parent continues fprintf(stdout, \"This is process %ld with parent %ld\\n, i = %d\",(long)getpid(), (long)getppid(), i); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:5","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task7 #include \u003cstdio.h\u003e #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cerrno.h\u003e void main(void){ int i, n = 4, status; pid_t childpid, waitreturn; for (i = 1; i \u003c n; ++i) { if (childpid = fork()) { break; //parent breaks from for loop } } // parent process waits for all children to terminate // in parent process, childpid is the PID of the child process // if child terminated, the return value is positive and is the PID of that child while (childpid != (waitreturn = wait(\u0026status))){ // child process has not terminated if ((waitreturn == -1) \u0026\u0026 (errno != EINTR)) // child process has terminated break; } fprintf(stdout, \"I am process %ld, my parent is %ld\\n\", (long)getpid(), (long)getppid()); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:6","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 8 In-class demo: exec example on creating a process to run ls -l #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void main(void){ int status; pid_t childpid; if ((childpid = fork()) == -1){ perror(\"Error in the fork\"); exit(1); }else if (childpid == 0){ /* child code */ if (execl(\"/usr/bin/ls\", \"ls\", \"-l\", NULL) \u003c 0){ // user/bin/ls is not the path of ls - use \u0026 user perror(\"Exec of ls failed\"); exit(1); } } else if (childpid != wait(\u0026status)) // /* parent code */ perror(\"A signal occurred before child exited\"); exit(0); } Compare with typing ls -l directly in terminal, the process performs ls -l in ./l3demo8 is the grandson of the terminal process, and the process performs ls -l in ./l3demo8 is the child of the terminal process. ","date":"0001-01-01","objectID":"/posts/sp/demo/:1:7","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 9 In -class demo: exec example on creating a process to run ls -l execvp(): p - search the executable file in the PATH environment variable v - arguments are passed to main as an array of char *const pointers, each pointing to a C string. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void main(void){ int status; pid_t childpid; char *argv[3]; argv[0] = \"ls\"; argv[1] = \"-l\"; argv[2] = 0; //NULL pointer if ((childpid = fork()) == -1){ perror(\"Error in the fork\"); exit(1); } else if (childpid ==0) { /* child code */ if (execv(\"/user/bin/ls\", argv) \u003c 0){ perror(\"Exec of ls failed\"); exit(1); } } else if (childpid != wait(\u0026status)) /* parent code */ perror(\"A signal occurred before child exited\"); exit(0); } Demo Task 10 In-class demo: exec has no return. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(void){ printf(\"Old image: pid=%d\\n\", getpid()); execlp(\"./newimage\", \"newimage\", NULL); printf(\"Old image: hello\\n\"); return 0; } #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main (void) { printf(\"New image: pid=%d\\n\", getpid()); return 0; } exec will not create a new process, still the same process. The memory will be re-written by the new image. #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main(void){ char * envp[2] envp[0] = \"PATH=test\" envp[1] = NULL; printf(\"Old image: pid=%d\\n\", getpid()); execle(\"./newimage\", \"newimage\", NULL, envp); printf(\"Old image: hello\\n\"); return 0; } #include \u003csys/types.h\u003e #include \u003csys/wait.h\u003e #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main (void) { printf(\"New image: pid=%d\\n\", getpid()); printf(\"New image: PATH=%s\\n\", getenv(\"PATH\")); return 0; e: entire Demo Task 11 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003csys/types.h\u003e #include \u003csys/stat.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003csyslog.h\u003e #include \u003cstring.h\u003e #define MAX_I 100 void main (void){ pid_t pid, sid; FILE* p_output; int i = 0; pid = fork(); if (pid \u003c 0) exit(EXIT_FAILURE); if (pid \u003e 0) exit(EXIT_SUCCESS); umask(0); sid = setsid(); // create the daemon process if (sid \u003c 0) exit(EXIT_FAILURE); if ((chdir(\".\")) \u003c 0) // change the directory to the current directory exit(EXIT_FAILURE); printf(\"Daemon: Hello!\\n\"); // the child session will inherit the stdout from the parent, so it will still print out on the current terminal(\"parent\" session) close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); printf(\"Daemon: Goodbye!\\n\"); // `STDIN/OUT` are closed, the child session cannot access parent I/O, so it will not print out in current terminal while(1){ if ((p_output = fopen( “daemon_output.txt”, “a”)) != NULL){ fprintf(p_output, “%d\\n”, i++); i %= MAX_I; fclose(p_output); } sleep(3); } exit(EXIT_SUCCESS); } umask umask(0): set the file mode creation mask(umask) to 0, so that the file mode of the daemon output file is not restricted. umask() sets the calling process’s file mode creation mask to mask \u0026 0777, 7 means 111 in binary open() and mkdir() mkdir(): the mode of the created directory is (mode \u0026 ~umask \u0026 0777) mode is default mode e.g. umask(0) -\u003e mkdir() -\u003e 0777 \u0026 ~0 \u0026 0777 -\u003e 0777: the deafult mode will be remained setsid although setsid will move to another session, but the opened file is still be accessed the child process calls setsid() to create a new session and obtain a new session ID (SID). If setsid() fails (returns -1), the program exits with a failure status. The child process then changes the current working directory to the root directory using chdir(\".\"). If the chdir() call fails, the program exits with a failure status. child process closes the standard input, standard output, and standard error file descriptors. This is done to disconnect the daemon process from the terminal, as it no longer needs them. abo","date":"0001-01-01","objectID":"/posts/sp/demo/:1:8","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"L4 ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:0","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 1 **What are the differences between a regular file and a device file? ** \u003ecp /etc/passwd /tmp/garbage \u003ecp /etc/passwd /dev/tty // \u003e cp normal.txt /dev/tty Hello world! content will be displayed on the terminal for tty device file ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:1","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 2 The C library function getcwd returns the pathname of the current working directory char *getcwd(char *buf, size_t size) size specifies maximum length pathname. If longer than the maximum, returns NULL and sets errono to ERANGE. #include \u003cunistd.h\u003e #include \u003cstdio.h\u003e #include \u003cerrno.h\u003e int main(){ char cwd[1024]; if (getcwd(cwd, sizeof(cwd)) != NULL) printf(\"Current working dir: %s\\n\", cwd); else perror(\"getcwd() error\"); return 0; } read a file bytes = read(fd, buffer, count) Read from file associated with fd; place count bytes into buffer fd: file descriptor to reasd from buffer: pointer to any array count: number of bytes to read Returns number of bytes read or -1 if an error occured ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:2","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 3 int fd = open(\"someFile\", O_RDONLY); char buffer[4]; // store in stack, no need to de-allocate char * buff2 = malloc(4*sizeof(char)); // store in heap, need to de-allocate int bytes = read(fd, buffer, 4*sizeof(char)); free(buff2); // de-allocate the memory or there will be memory leak write a file - overwrite bytes = write(fd, buffer, count) Write contents of buffer to the file associated with fd, write count bytes into the file O_TRUNC: if the file already exists and is a regular file and the access mode allows writing, truncate it to length 0. fd: file descriptor to write to buffer: pointer to any array count: number of bytes to write Returns number of bytes written or -1 if an error occured ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:3","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 4 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void main(){ char buff4[4] = {'a','b','c',0} int i = 0; int bytes_written = 0; int fd; fd = open(\"someFile\", O_WRONLY|O_CREAT, 0644); printf(\"sizeof(buffer) is %d\\n\", sizeof(buffer)); // char buffer[4]; bytes_written = write(fd, buffer, 4*sizeof(char)); for (i = 0; i \u003c 4; i++) { printf(\"The %dth byte is %c\\n\", i, buffer[i]); } fsync(fd); // flashes the content into disk before close (for written) close(fd); // when open, close it } Demo Task 5 #include \u003cstdio.h\u003e FILE *myfp; if ((myfp = fopen(\"/home/ann/my.dat\", \"w\")) == NULL) fprintf(stderr, \"Could not fopen file\\n\"); else fprintf(myfp, \"This is a test\"); overwrite #include \u003cstdio.h\u003e void main() { FILE *fp; fp = fopen(\"someFile\", \"w\"); if (fp == NULL) { fprintf(stderr, \"Could nor fopen file.\\n\"); } else { fprintf(fp, \"This is a test\"); } fflush(fp); fclose(fp); } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:4","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 6 printf(\"The sum of %d, %d, and %d is %d\\n\", 65, 87, 33, 65+87+33); // output: The sum of 65, 87, and 33 is 185 printf(\"Error %s occurred at line %d \\n\", emsg, lno); // output: Error invalid variable occurred at line 27 printf(\"Hexadecimal form of %d is %x \\n\", 59, 59); // output: Hexadecimal form of 59 is 3B #include \u003cstdio.h\u003e void main() { int x = -1; printf(\"%%d = (%d) , %%i = (%i), %%u = (%u), %%o = (%o), %%x = (%x), %%X = %X\\n\", x, x, x, x, x, x); char c = 'a'; char* s = \"hello world.\\n\"; // literal string float f = 1.12345678901234567890e20; double lf = 1.12345678901234567890e20; printf(\"%%c = (%c).\\n\", c); printf(\"%%s = (%s).\\n\", s); printf(\"%%f = (%f), %%lf = (%lf), %%e = (%e), %%E = (%E), %%g = (%g), %%G = (%G).\\n\", f,lf,lf,lf,lf,lf); } %d = (-1) , %i = (-1), %u = (4294967295), %o = (37777777777), %x = (ffffffff), %X = FFFFFFFF ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:5","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 7 fgets(): #include \u003cstdio.h\u003e void main() { int i; char c; char buf[256]; while (1) { fgets(buf, sizeof(buf), stdin); printf(\"%s = \\\"%s\\\".\\n\", buf); } fscanf(): #include \u003cstdio.h\u003e void main() { int i; char c; char buf[256]; FILE* datafile; datafile = fopen(\"mydata.txt\", \"r\"); while (!feof(datafile)) { fscanf(datafile, \"%d %c %s\", \u0026i, \u0026i, \u0026buf); printf(\"i = %d, c = \\'%c\\', s = \\\"%s\\\".\\n, i, c , buf\"); } } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:6","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 8 #include\u003cstdio.h\u003e #include\u003cfcntl.h\u003e #include\u003cunistd.h\u003e char* cmd[] = {\"/bin/ls\", \"-l\", 0}; int main(int argc, char* argv[]){ int fd = open(argv[1], O_WRONLY | O_CREAT, 0600); //fd will be 3; a file will be opened in write mode int fd2 = dup(fd); //duplicate the fd-th pointer to entry 4, the lowest available entry close(STDOUT_FILENO); // the entry 1 is now available(free) dup(fd); //duplicate the fd-th pointer into entry 1, \"my.dat\" become the standard output file execvp(cmd[0], cmd); // the old process image is replaced by the new process image for ls // the File Descriptor Table is \"inherited\" by the new process image, // still the same process(PID), but the image is replaced close(fd); //close file descriptor 3 in the parent process. return; } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:7","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":"Demo Task 9 #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003cstring.h\u003e int main(){ int fd[2]; pipe(fd); //fd[0] is for read and fd[1] is for write pid_t child = fork(); char* data = \"hello world\"; if (child == 0){ //child process close(fd[1]); char buf[100]; //a large enough buffer to share data int bytes_to_read = strlen(data)+1; while (bytes_to_read \u003e 0) { int count = read(fd[0], buf, sizeof(data)); bytes_to_read -= count; } printf(\"child process read: \\\"%s\\\" .\\n\", buf); } else { //parent process close(fd[0]); int bytes_to_write = strlen(data)+1; while (bytes_to_write \u003e 0) { int count = write(fd[1], data, strlen(data)+1) // \"+1\" for null byte, terminateing 0 bytes_to_write -= count; } fsync(fd[1]); //flush the data into pipe before close printf(\"parent process written: \\\"%s\\\" .\\n\", data); close(fd[1]); } return 0; } ","date":"0001-01-01","objectID":"/posts/sp/demo/:2:8","tags":null,"title":"","uri":"/posts/sp/demo/"},{"categories":null,"content":" Lighthouse (image) 网站概述 | Website Abstract eshanwu是我的一个个人博客网站, 我会在网站上不定期的更新一些文章以及学习笔记, 自学过程, 也会有一些人生感悟。 关于我 | About Me 香港理工大学计算机科学本科生 Major in Computer Science, The Hong Kong Polytechnic University Minor in Financial Services and Institutions; Lighthouse (image) ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"}]